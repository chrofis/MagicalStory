<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Magical Story</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>âœ¨</text></svg>">
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
  <script>
    // Initialize Firebase
    const firebaseConfig = {
      apiKey: "AIzaSyCtdyVIpckWhIfy1_9O8qOaEnTXFuiRYaQ",
      authDomain: "magical-story-3b745.firebaseapp.com",
      projectId: "magical-story-3b745",
      storageBucket: "magical-story-3b745.firebasestorage.app",
      messagingSenderId: "69965481554",
      appId: "1:69965481554:web:d264515ca92d2306f5018b",
      measurementId: "G-TERDSLHHDG"
    };
    firebase.initializeApp(firebaseConfig);
    const firebaseAuth = firebase.auth();
    // Set persistence to LOCAL (uses localStorage, more reliable on iOS Safari than IndexedDB)
    firebaseAuth.setPersistence(firebase.auth.Auth.Persistence.LOCAL).catch(err => {
      console.warn('Firebase persistence error:', err);
    });
  </script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/lucide@latest"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Cinzel:wght@700&family=Libre+Baskerville:wght@400&display=swap" rel="stylesheet">
  <!-- Preload art style images for faster display -->
  <link rel="preload" as="image" href="images/Pixar style.jpg">
  <link rel="preload" as="image" href="images/cartoon style.jpg">
  <link rel="preload" as="image" href="images/anime style.jpg">
  <link rel="preload" as="image" href="images/chibi style.jpg">
  <link rel="preload" as="image" href="images/steampunk style.jpg">
  <link rel="preload" as="image" href="images/water color style.jpg">
  <link rel="preload" as="image" href="images/comic book style.jpg">
  <link rel="preload" as="image" href="images/manga style.jpg">
  <script>
    // Tailwind config for style guide colors
    tailwind.config = {
      theme: {
        extend: {
          fontFamily: {
            sans: ['Inter', 'system-ui', '-apple-system', 'sans-serif'],
            title: ['Cinzel', 'serif'],
            body: ['Libre Baskerville', 'serif'],
          },
        },
      },
    }
  </script>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
    }
    .font-title {
      font-family: 'Cinzel', serif;
      font-weight: 700;
    }
    .font-body {
      font-family: 'Libre Baskerville', serif;
      font-weight: 400;
    }
    /* Animation for adding new items */
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(-10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    .animate-fade-in {
      animation: fadeIn 0.3s ease-out;
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect } = React;
    const { createRoot } = ReactDOM;

    // Lucide Icons Component Wrapper
    const Icon = ({ name, size = 24, className = "", ...props }) => {
      useEffect(() => {
        if (window.lucide) {
          window.lucide.createIcons();
        }
      }, []);
      return React.createElement('i', {
        'data-lucide': name,
        className,
        style: { width: size, height: size },
        ...props
      });
    };

    const storyTypes = [
      { id: 'christmas', name: { en: 'Christmas Story', de: 'Weihnachts-\nGeschichte', fr: 'Histoire de NoÃ«l' }, emoji: 'ðŸŽ„' },
      { id: 'newyear', name: { en: 'New Year Story', de: 'Neujahrs-\nGeschichte', fr: 'Histoire du Nouvel An' }, emoji: 'ðŸŽ†' },
      { id: 'pirate', name: { en: 'Pirate Adventure', de: 'Piraten-Abenteuer', fr: 'Aventure de Pirates' }, emoji: 'ðŸ´â€â˜ ï¸' },
      { id: 'cowboy', name: { en: 'Wild West', de: 'Wilder Westen', fr: 'Far West' }, emoji: 'ðŸ¤ ' },
      { id: 'fireman', name: { en: 'Brave Firefighter', de: 'Tapferer Feuerwehrmann', fr: 'Pompier Courageux' }, emoji: 'ðŸš’' },
      { id: 'unicorn', name: { en: 'Magical Unicorn', de: 'Magisches Einhorn', fr: 'Licorne Magique' }, emoji: 'ðŸ¦„' },
      { id: 'ninja', name: { en: 'Secret Ninja', de: 'Geheimer Ninja', fr: 'Ninja Secret' }, emoji: 'ðŸ¥·' },
      { id: 'space', name: { en: 'Space Explorer', de: 'Weltraum-Entdecker', fr: 'Explorateur Spatial' }, emoji: 'ðŸš€' },
      { id: 'dinosaur', name: { en: 'Dinosaur World', de: 'Dinosaurier-Welt', fr: 'Monde des Dinosaures' }, emoji: 'ðŸ¦–' },
      { id: 'princess', name: { en: 'Princess Story', de: 'Prinzessinnen-Geschichte', fr: 'Histoire de Princesse' }, emoji: 'ðŸ‘‘' },
      { id: 'knight', name: { en: 'Knight Adventure', de: 'Ritter-Abenteuer', fr: 'Aventure de Chevalier' }, emoji: 'âš”ï¸' },
      { id: 'detective', name: { en: 'Detective Mystery', de: 'Detektiv-Geheimnis', fr: 'MystÃ¨re de DÃ©tective' }, emoji: 'ðŸ”' }
    ];

    const artStyles = [
      {
        id: 'pixar',
        name: { en: 'Pixar 3D', de: 'Pixar 3D', fr: 'Pixar 3D' },
        emoji: 'ðŸŽ¬',
        image: 'images/Pixar style.jpg',
        description: {
          en: 'Vibrant, warm Disney/Pixar style 3D animation',
          de: 'Lebendige, warme Disney/Pixar 3D-Animation',
          fr: 'Animation 3D Disney/Pixar vibrante et chaleureuse'
        },
        prompt: 'pixar style 3d character, vibrant Disney/Pixar 3D animation, warm lighting, child-friendly'
      },
      {
        id: 'cartoon',
        name: { en: 'Cartoon', de: 'Cartoon', fr: 'Dessin animÃ©' },
        emoji: 'ðŸŽ¨',
        image: 'images/cartoon style.jpg',
        description: {
          en: 'Classic 2D cartoon style with bold colors',
          de: 'Klassischer 2D-Cartoon-Stil mit krÃ¤ftigen Farben',
          fr: 'Style cartoon 2D classique aux couleurs vives'
        },
        prompt: '2D cartoon style, bold outlines, vibrant flat colors, classic animation look'
      },
      {
        id: 'anime',
        name: { en: 'Anime', de: 'Anime', fr: 'Anime' },
        emoji: 'â­',
        image: 'images/anime style.jpg',
        description: {
          en: 'Japanese anime style with expressive features',
          de: 'Japanischer Anime-Stil mit ausdrucksstarken Features',
          fr: 'Style anime japonais aux traits expressifs'
        },
        prompt: 'anime style, Japanese animation, expressive eyes, dynamic poses, cel-shaded'
      },
      {
        id: 'chibi',
        name: { en: 'Chibi', de: 'Chibi', fr: 'Chibi' },
        emoji: 'ðŸŒ¸',
        image: 'images/chibi style.jpg',
        description: {
          en: 'Cute chibi style with big heads and small bodies',
          de: 'Niedlicher Chibi-Stil mit groÃŸen KÃ¶pfen und kleinen KÃ¶rpern',
          fr: 'Style chibi mignon avec grandes tÃªtes et petits corps'
        },
        prompt: 'chibi style, super deformed, cute, big head, small body, kawaii, adorable'
      },
      {
        id: 'steampunk',
        name: { en: 'Steampunk', de: 'Steampunk', fr: 'Steampunk' },
        emoji: 'âš™ï¸',
        image: 'images/steampunk style.jpg',
        description: {
          en: 'Victorian-era inspired with gears and brass',
          de: 'Von der viktorianischen Ã„ra inspiriert mit ZahnrÃ¤dern und Messing',
          fr: 'InspirÃ© de l\'Ã¨re victorienne avec engrenages et laiton'
        },
        prompt: 'steampunk anime style, Victorian era, gears, brass, copper, goggles, mechanical details, vintage technology, anime influenced'
      },
      {
        id: 'comic',
        name: { en: 'Comic Book', de: 'Comic', fr: 'Bande dessinÃ©e' },
        emoji: 'ðŸ’¥',
        image: 'images/comic book style.jpg',
        description: {
          en: 'Comic book style with bold lines and halftone',
          de: 'Comic-Stil mit krÃ¤ftigen Linien und Raster',
          fr: 'Style bande dessinÃ©e avec lignes Ã©paisses et trames'
        },
        prompt: 'comic book style, bold ink lines, halftone dots, dynamic action, speech bubbles aesthetic, superhero comic art'
      },
      {
        id: 'manga',
        name: { en: 'Manga', de: 'Manga', fr: 'Manga' },
        emoji: 'ðŸ“š',
        image: 'images/manga style.jpg',
        description: {
          en: 'Japanese manga style, black and white with screentones',
          de: 'Japanischer Manga-Stil, schwarz-weiÃŸ mit Rastern',
          fr: 'Style manga japonais, noir et blanc avec trames'
        },
        prompt: 'manga style, Japanese comic art, detailed linework, screentones, dramatic shading, expressive characters'
      },
      {
        id: 'watercolor',
        name: { en: 'Watercolor', de: 'Aquarell', fr: 'Aquarelle' },
        emoji: 'ðŸŽ¨',
        image: 'images/water color style.jpg',
        description: {
          en: 'Soft watercolor painting with flowing colors',
          de: 'Sanfte Aquarellmalerei mit flieÃŸenden Farben',
          fr: 'Peinture aquarelle douce aux couleurs fluides'
        },
        prompt: 'watercolor painting style, soft edges, flowing colors, delicate washes, artistic brushstrokes, dreamy atmosphere, traditional watercolor illustration'
      }
    ];

    const defaultStrengths = {
      en: ['Brave', 'Smart', 'Kind', 'Strong', 'Fast', 'Creative', 'Funny', 'Leader', 'Helpful', 'Patient', 'Honest', 'Loyal', 'Curious', 'Determined', 'Caring', 'Confident', 'Cheerful', 'Generous', 'Clever', 'Adventurous', 'Resourceful', 'Protective', 'Imaginative', 'Hardworking', 'Trustworthy'],
      de: ['Mutig', 'Klug', 'Freundlich', 'Stark', 'Schnell', 'Kreativ', 'Lustig', 'FÃ¼hrungspersÃ¶nlichkeit', 'Hilfsbereit', 'Geduldig', 'Ehrlich', 'Treu', 'Neugierig', 'Entschlossen', 'FÃ¼rsorglich', 'Selbstbewusst', 'FrÃ¶hlich', 'GroÃŸzÃ¼gig', 'Schlau', 'Abenteuerlustig', 'Einfallsreich', 'BeschÃ¼tzend', 'Fantasievoll', 'FleiÃŸig', 'VertrauenswÃ¼rdig'],
      fr: ['Courageux', 'Intelligent', 'Gentil', 'Fort', 'Rapide', 'CrÃ©atif', 'DrÃ´le', 'Leader', 'Serviable', 'Patient', 'HonnÃªte', 'Loyal', 'Curieux', 'DÃ©terminÃ©', 'AttentionnÃ©', 'Confiant', 'Joyeux', 'GÃ©nÃ©reux', 'Astucieux', 'Aventureux', 'DÃ©brouillard', 'Protecteur', 'Imaginatif', 'Travailleur', 'Digne de confiance']
    };

    const defaultWeaknesses = {
      en: ['Shy', 'Clumsy', 'Impatient', 'Forgetful', 'Messy', 'Talkative', 'Stubborn', 'Lazy', 'Greedy', 'Jealous', 'Anxious', 'Distracted', 'Reckless', 'Bossy', 'Easily scared', 'Too trusting', 'Perfectionist', 'Indecisive', 'Secretive', 'Boastful', 'Quick-tempered', 'Careless', 'Overly cautious', 'Selfish'],
      de: ['SchÃ¼chtern', 'Tollpatschig', 'Ungeduldig', 'Vergesslich', 'Unordentlich', 'GesprÃ¤chig', 'Stur', 'Faul', 'Gierig', 'EifersÃ¼chtig', 'Ã„ngstlich', 'Abgelenkt', 'Leichtsinnig', 'HerrschsÃ¼chtig', 'Leicht Ã¤ngstlich', 'Zu vertrauensvoll', 'Perfektionist', 'Unentschlossen', 'Verschlossen', 'Prahlerisch', 'JÃ¤hzornig', 'NachlÃ¤ssig', 'Ãœbervorsichtig', 'Egoistisch'],
      fr: ['Timide', 'Maladroit', 'Impatient', 'Distrait', 'DÃ©sordonnÃ©', 'Bavard', 'TÃªtu', 'Paresseux', 'Avide', 'Jaloux', 'Anxieux', 'Distrait', 'Imprudent', 'Autoritaire', 'Facilement effrayÃ©', 'Trop confiant', 'Perfectionniste', 'IndÃ©cis', 'Secret', 'Vantard', 'ColÃ©rique', 'NÃ©gligent', 'Trop prudent', 'Ã‰goÃ¯ste']
    };

    const fearOptions = {
      en: ['Fear of heights', 'Fear of spiders', 'Fear of the dark', 'Fear of being alone', 'Fear of loud noises'],
      de: ['HÃ¶henangst', 'Angst vor Spinnen', 'Angst vor der Dunkelheit', 'Angst allein zu sein', 'Angst vor lauten GerÃ¤uschen'],
      fr: ['Peur du vide', 'Peur des araignÃ©es', 'Peur du noir', 'Peur d\'Ãªtre seul', 'Peur des bruits forts']
    };

    const relationshipTypes = [
      { value: { en: 'Best Friends with', de: 'Beste Freunde mit', fr: 'Meilleurs amis avec' }, inverse: { en: 'Best Friends with', de: 'Beste Freunde mit', fr: 'Meilleurs amis avec' } },
      { value: { en: 'Friends with', de: 'Freunde mit', fr: 'Amis avec' }, inverse: { en: 'Friends with', de: 'Freunde mit', fr: 'Amis avec' } },
      { value: { en: 'Married to', de: 'Verheiratet mit', fr: 'MariÃ©(e) Ã ' }, inverse: { en: 'Married to', de: 'Verheiratet mit', fr: 'MariÃ©(e) Ã ' } },
      { value: { en: 'In a relationship with', de: 'In einer Beziehung mit', fr: 'En relation avec' }, inverse: { en: 'In a relationship with', de: 'In einer Beziehung mit', fr: 'En relation avec' } },
      { value: { en: 'Older Sibling of', de: 'Ã„lteres Geschwister von', fr: 'FrÃ¨re/SÅ“ur aÃ®nÃ©(e) de' }, inverse: { en: 'Younger Sibling of', de: 'JÃ¼ngeres Geschwister von', fr: 'FrÃ¨re/SÅ“ur cadet(te) de' } },
      { value: { en: 'Younger Sibling of', de: 'JÃ¼ngeres Geschwister von', fr: 'FrÃ¨re/SÅ“ur cadet(te) de' }, inverse: { en: 'Older Sibling of', de: 'Ã„lteres Geschwister von', fr: 'FrÃ¨re/SÅ“ur aÃ®nÃ©(e) de' } },
      { value: { en: 'Parent of', de: 'Elternteil von', fr: 'Parent de' }, inverse: { en: 'Child of', de: 'Kind von', fr: 'Enfant de' } },
      { value: { en: 'Child of', de: 'Kind von', fr: 'Enfant de' }, inverse: { en: 'Parent of', de: 'Elternteil von', fr: 'Parent de' } },
      { value: { en: 'Rivals with', de: 'Rivalen mit', fr: 'Rivaux avec' }, inverse: { en: 'Rivals with', de: 'Rivalen mit', fr: 'Rivaux avec' } },
      { value: { en: 'Neighbors with', de: 'Nachbarn mit', fr: 'Voisins avec' }, inverse: { en: 'Neighbors with', de: 'Nachbarn mit', fr: 'Voisins avec' } },
      { value: { en: 'Not Known to', de: 'Nicht bekannt mit', fr: 'Pas connu de' }, inverse: { en: 'Not Known to', de: 'Nicht bekannt mit', fr: 'Pas connu de' } }
    ];

    // Helper to get "Not Known to" relationship (avoid magic number)
    const getNotKnownRelationship = (lang) => {
      const notKnown = relationshipTypes.find(r => r.value.en === 'Not Known to');
      return notKnown ? notKnown.value[lang] : 'Not Known to';
    };

    // Check if a relationship value means "Not Known to" in any language
    const isNotKnownRelationship = (value) => {
      const notKnown = relationshipTypes.find(r => r.value.en === 'Not Known to');
      if (!notKnown) return false;
      return value === notKnown.value.en || value === notKnown.value.de || value === notKnown.value.fr;
    };

    const translations = {
      en: {
        title: 'Magical Story',
        subtitle: 'Personalize your story to create magic',
        heroTitle: 'Become the hero of your story',
        heroSubtitle: '',
        heroDescription: 'Turn your wildest ideas into a breathtaking personalized tale.',
        bookText: 'Get a beautifully printed book and make someone feel like the legend they truly are.',
        startJourney: 'Start Your Adventure',
        selectLanguage: 'Choose your language',
        login: 'Login',
        register: 'Register',
        logout: 'Logout',
        username: 'Username',
        password: 'Password',
        email: 'Email (optional)',
        welcomeBack: 'Welcome Back!',
        createAccount: 'Create Account',
        noAccount: 'Don\'t have an account?',
        haveAccount: 'Already have an account?',
        signUp: 'Sign up',
        signIn: 'Sign in',
        loginRequired: 'Please login to continue',
        continueWithGoogle: 'Continue with Google',
        continueWithApple: 'Continue with Apple',
        orContinueWith: 'or continue with',
        forgotPassword: 'Forgot password?',
        resetPassword: 'Reset Password',
        resetPasswordDesc: 'Enter your email and we\'ll send you a reset link',
        sendResetLink: 'Send Reset Link',
        resetLinkSent: 'Password reset email sent! Check your inbox.',
        backToLogin: 'Back to login',
        chooseStoryType: 'Choose Your Story Type',
        chooseArtStyle: 'Choose Your Art Style',
        artStyleDescription: 'Select the visual style for your story',
        addCustomStoryType: 'Add Custom Story Type',
        storyTypeName: 'Story Type Name',
        storyTypeEmoji: 'Emoji',
        addStoryType: 'Add',
        createCharacters: 'Create Your Characters',
        characterCreated: 'Character Created!',
        createAnother: 'Create Another Character',
        continueToRelationships: 'Continue to Relationships',
        yourCharacters: 'Your Characters:',
        startCreating: 'Start Creating Character',
        characterName: 'Character Name',
        characterPhoto: 'Character Photo',
        uploadPhoto: 'Upload Photo',
        uploadPhotoFirst: 'Please upload a photo to continue',
        photoGoodExamples: 'Good: Full body or upper body',
        photoBadExamples: 'Avoid: Close-up face only, sunglasses, hats, helmets, blurry',
        orDescribe: 'OR describe the character',
        characterAge: 'Age',
        hairColor: 'Hair Color',
        otherFeatures: 'Other Features',
        descriptionPlaceholder: 'e.g., Blue eyes, wears glasses, has freckles',
        gender: 'Gender',
        male: 'Male',
        female: 'Female',
        other: 'Unknown',
        age: 'Age',
        strengths: 'Strengths',
        weaknesses: 'Weaknesses',
        selectAtLeast: 'Select at least',
        selected: 'Selected',
        addCustomStrengths: 'Add custom strengths',
        addCustomWeaknesses: 'Add custom weaknesses',
        addCustomFears: 'Add custom fears',
        specialDetails: 'Hobbies, Hopes & Fears, Favourite Animals and Other Details',
        specialDetailsPlaceholder: 'e.g., Enjoys painting, dreams of becoming an astronaut, scared of spiders, loves horses',
        fears: 'Fears',
        addCustomRelationship: 'Add custom relationship',
        cancel: 'Cancel',
        saveCharacter: 'Save Character',
        editCharacter: 'Edit',
        deleteCharacter: 'Delete',
        defineRelationships: 'Define Character Relationships',
        defineRelationshipsDesc: 'Define how each character relates to the others.',
        is: 'is',
        reverseRelationship: 'Reverse relationship:',
        storySettings: 'Story Settings',
        selectMainCharacters: 'Select Main Characters (max 2)',
        numberOfPages: 'Number of Pages',
        readingLevel: 'Reading Level',
        firstGrade: 'Picture Book',
        firstGradeDesc: 'Image and text on both pages',
        standard: 'Standard',
        standardDesc: 'Text on one page, image on the other',
        advanced: 'Advanced',
        advancedDesc: 'Longer text, image on opposite page',
        generateStory: 'Generate Story!',
        creating: 'Creating Your Story...',
        storyReady: 'Your Story is Ready!',
        downloadTXT: 'Download as TXT',
        downloadPDF: 'Download as PDF',
        downloadPrompt: 'Download Prompt',
        viewPrompt: 'View Prompt',
        hidePrompt: 'Hide Prompt',
        promptUsed: 'Prompt Used to Generate Story:',
        createAnotherStory: 'Create Another Story',
        back: 'Back',
        next: 'Next',
        exportConfig: 'Export Configuration',
        exportStoryInfo: 'Export Story Info (MD)',
        importConfig: 'Import Configuration',
        charactersCreated: "You've created {count} character{s} so far.",
        mainCharacter: 'Main Character',
        apiKeyRequired: 'API Key Required',
        apiKeyPrompt: 'Please enter your Anthropic API key to generate stories:',
        apiKeyPlaceholder: 'sk-ant-...',
        saveApiKey: 'Save API Key',
        apiKeyNote: 'Your API key is stored locally in your browser and never sent anywhere except to Anthropic.',
        promptPreview: 'Prompt Preview',
        showPromptPreview: 'Show Prompt',
        hidePromptPreview: 'Hide Prompt',
        editPrompt: 'Edit Prompt',
        resetPrompt: 'Reset to Default',
        storyDetails: 'Additional Story Details (Optional)',
        storyDetailsPlaceholder: 'e.g., Location: Enchanted forest, Special elements: Magical talking animals, Time period: Medieval times...',
        generateOutline: 'Generate Outline',
        generatingOutline: 'Generating Outline...',
        outlineReady: 'Story Outline',
        editOutline: 'You can edit the outline below before generating the full story:',
        regenerateOutline: 'Regenerate Outline',
        createScenes: 'Create Scene Descriptions',
        creatingScenes: 'Creating Scene Descriptions...',
        scenesReady: 'Scene Descriptions',
        downloadScenes: 'Download Scenes',
        sceneForPage: 'Scene for Page',
        yourStory: 'Your Story',
        uploadStory: 'Upload Story',
        uploadStoryDesc: 'Upload an existing story text file to generate scene descriptions',
        generateImages: 'Generate Scene Images',
        generatingImages: 'Generating Images...',
        imagesReady: 'Scene Images',
        downloadImage: 'Download Image',
        geminiApiKey: 'Gemini API Key',
        geminiApiKeyPrompt: 'Enter your Google Gemini API key to generate images:',
        geminiApiKeyNote: 'Get your key from Google AI Studio',
        imageForPage: 'Image for Page',
        generateAvatar: 'Generate Pixar Avatar',
        generatingAvatar: 'Generating Avatar...',
        avatarGenerated: 'Avatar Generated!',
        useGeneratedAvatar: 'Use Generated Avatar',
        keepOriginal: 'Keep Original Photo',
        uploadType: 'What are you uploading?',
        uploadRealPhoto: 'Real Photo (will generate avatar)',
        uploadReadyAvatar: 'Ready Avatar (already stylized)',
        editStory: 'Edit Story',
        saveStory: 'Save Story',
        editScene: 'Edit Scene',
        saveScene: 'Save Scene',
        editImage: 'Edit Image',
        regenerateImage: 'Regenerate Image',
        showPrompt: 'Show Prompt',
        hidePrompt: 'Hide Prompt',
        editInstruction: 'What should be changed?',
        applyEdit: 'Apply Edit'
      },
      de: {
        title: 'Magical Story',
        subtitle: 'Personalisiere deine Geschichte fÃ¼r Magie',
        heroTitle: 'Werde zum Helden deiner Geschichte',
        heroSubtitle: '',
        heroDescription: 'Verwandle deine wildesten Ideen in eine atemberaubende personalisierte Geschichte.',
        bookText: 'Erhalte ein wunderschÃ¶n gedrucktes Buch und gib jemandem das GefÃ¼hl, die Legende zu sein, die er wirklich ist.',
        startJourney: 'Starte dein Abenteuer',
        selectLanguage: 'WÃ¤hle deine Sprache',
        login: 'Anmelden',
        register: 'Registrieren',
        logout: 'Abmelden',
        username: 'Benutzername',
        password: 'Passwort',
        email: 'E-Mail (optional)',
        welcomeBack: 'Willkommen zurÃ¼ck!',
        createAccount: 'Konto erstellen',
        noAccount: 'Noch kein Konto?',
        haveAccount: 'Bereits ein Konto?',
        signUp: 'Registrieren',
        signIn: 'Anmelden',
        loginRequired: 'Bitte melde dich an, um fortzufahren',
        continueWithGoogle: 'Mit Google fortfahren',
        continueWithApple: 'Mit Apple fortfahren',
        orContinueWith: 'oder fortfahren mit',
        forgotPassword: 'Passwort vergessen?',
        resetPassword: 'Passwort zurÃ¼cksetzen',
        resetPasswordDesc: 'Gib deine E-Mail ein und wir senden dir einen Link zum ZurÃ¼cksetzen',
        sendResetLink: 'Link senden',
        resetLinkSent: 'E-Mail zum ZurÃ¼cksetzen gesendet! ÃœberprÃ¼fe deinen Posteingang.',
        backToLogin: 'ZurÃ¼ck zur Anmeldung',
        chooseStoryType: 'WÃ¤hle deinen Geschichtentyp',
        chooseArtStyle: 'WÃ¤hle deinen Kunststil',
        artStyleDescription: 'WÃ¤hle den visuellen Stil fÃ¼r deine Geschichte',
        addCustomStoryType: 'Eigenen Geschichtentyp hinzufÃ¼gen',
        storyTypeName: 'Name des Geschichtentyps',
        storyTypeEmoji: 'Emoji',
        addStoryType: 'HinzufÃ¼gen',
        createCharacters: 'Erstelle deine Charaktere',
        characterCreated: 'Charakter erstellt!',
        createAnother: 'Weiteren Charakter erstellen',
        continueToRelationships: 'Weiter zu Beziehungen',
        yourCharacters: 'Deine Charaktere:',
        startCreating: 'Charakter erstellen beginnen',
        characterName: 'Charaktername',
        characterPhoto: 'Charakterfoto',
        uploadPhoto: 'Foto hochladen',
        uploadPhotoFirst: 'Bitte laden Sie ein Foto hoch, um fortzufahren',
        photoGoodExamples: 'Gut: GanzkÃ¶rper oder OberkÃ¶rper',
        photoBadExamples: 'Vermeiden: Nur Gesicht, Sonnenbrille, HÃ¼te, Helme, unscharf',
        orDescribe: 'ODER Figur beschreiben',
        characterAge: 'Alter',
        hairColor: 'Haarfarbe',
        otherFeatures: 'Sonstige Merkmale',
        descriptionPlaceholder: 'z.B. Blaue Augen, trÃ¤gt Brille, hat Sommersprossen',
        gender: 'Geschlecht',
        male: 'MÃ¤nnlich',
        female: 'Weiblich',
        other: 'Unbekannt',
        age: 'Alter',
        strengths: 'StÃ¤rken',
        weaknesses: 'SchwÃ¤chen',
        selectAtLeast: 'WÃ¤hle mindestens',
        selected: 'AusgewÃ¤hlt',
        addCustomStrengths: 'Eigene StÃ¤rken hinzufÃ¼gen',
        addCustomWeaknesses: 'Eigene SchwÃ¤chen hinzufÃ¼gen',
        addCustomFears: 'Eigene Ã„ngste hinzufÃ¼gen',
        specialDetails: 'Hobbys, Hoffnungen & Ã„ngste, Lieblingstiere und andere Besonderheiten',
        specialDetailsPlaceholder: 'z.B. Malt gerne, trÃ¤umt davon Astronaut zu werden, hat Angst vor Spinnen, liebt Pferde',
        fears: 'Ã„ngste',
        addCustomRelationship: 'Eigene Beziehung hinzufÃ¼gen',
        cancel: 'Abbrechen',
        saveCharacter: 'Charakter speichern',
        editCharacter: 'Bearbeiten',
        deleteCharacter: 'LÃ¶schen',
        defineRelationships: 'Charakterbeziehungen definieren',
        defineRelationshipsDesc: 'Definiere, wie die Charaktere zueinander stehen.',
        is: 'ist',
        reverseRelationship: 'Umgekehrte Beziehung:',
        storySettings: 'Geschichten-Einstellungen',
        selectMainCharacters: 'Hauptfiguren auswÃ¤hlen (max 2)',
        numberOfPages: 'Anzahl der Seiten',
        readingLevel: 'Lesestufe',
        firstGrade: 'Bilderbuch',
        firstGradeDesc: 'Bild und Text auf beiden Seiten',
        standard: 'Standard',
        standardDesc: 'Text auf einer Seite, Bild auf der anderen',
        advanced: 'Fortgeschritten',
        advancedDesc: 'LÃ¤ngerer Text, Bild auf der gegenÃ¼berliegenden Seite',
        generateStory: 'Geschichte erstellen!',
        creating: 'Erstelle deine Geschichte...',
        storyReady: 'Deine Geschichte ist fertig!',
        downloadTXT: 'Als TXT herunterladen',
        downloadPDF: 'Als PDF herunterladen',
        downloadPrompt: 'Prompt herunterladen',
        viewPrompt: 'Prompt anzeigen',
        hidePrompt: 'Prompt ausblenden',
        promptUsed: 'Verwendeter Prompt:',
        createAnotherStory: 'Neue Geschichte erstellen',
        back: 'ZurÃ¼ck',
        next: 'Weiter',
        exportConfig: 'Konfiguration exportieren',
        exportStoryInfo: 'Story-Info exportieren (MD)',
        importConfig: 'Konfiguration importieren',
        charactersCreated: 'Du hast bisher {count} Charakter{s} erstellt.',
        mainCharacter: 'Hauptfigur',
        apiKeyRequired: 'API-SchlÃ¼ssel erforderlich',
        apiKeyPrompt: 'Bitte geben Sie Ihren Anthropic API-SchlÃ¼ssel ein:',
        apiKeyPlaceholder: 'sk-ant-...',
        saveApiKey: 'API-SchlÃ¼ssel speichern',
        apiKeyNote: 'Ihr API-SchlÃ¼ssel wird lokal im Browser gespeichert.',
        promptPreview: 'Prompt-Vorschau',
        showPromptPreview: 'Prompt anzeigen',
        hidePromptPreview: 'Prompt ausblenden',
        editPrompt: 'Prompt bearbeiten',
        resetPrompt: 'Auf Standard zurÃ¼cksetzen',
        storyDetails: 'ZusÃ¤tzliche Story-Details (Optional)',
        storyDetailsPlaceholder: 'z.B. Ort: Verzauberter Wald, Besondere Elemente: Magische sprechende Tiere, Zeitperiode: Mittelalter...',
        generateOutline: 'Gliederung erstellen',
        generatingOutline: 'Gliederung wird erstellt...',
        outlineReady: 'Story-Gliederung',
        editOutline: 'Sie kÃ¶nnen die Gliederung unten bearbeiten, bevor Sie die vollstÃ¤ndige Geschichte erstellen:',
        regenerateOutline: 'Gliederung neu erstellen',
        createScenes: 'Szenen-Beschreibungen erstellen',
        creatingScenes: 'Szenen-Beschreibungen werden erstellt...',
        scenesReady: 'Szenen-Beschreibungen',
        downloadScenes: 'Szenen herunterladen',
        sceneForPage: 'Szene fÃ¼r Seite',
        yourStory: 'Deine Geschichte',
        uploadStory: 'Geschichte hochladen',
        uploadStoryDesc: 'Laden Sie eine vorhandene Story-Textdatei hoch, um Szenenbeschreibungen zu generieren',
        generateImages: 'Szenenbilder generieren',
        generatingImages: 'Bilder werden generiert...',
        imagesReady: 'Szenenbilder',
        downloadImage: 'Bild herunterladen',
        geminiApiKey: 'Gemini API-SchlÃ¼ssel',
        geminiApiKeyPrompt: 'Geben Sie Ihren Google Gemini API-SchlÃ¼ssel ein:',
        geminiApiKeyNote: 'Holen Sie sich Ihren SchlÃ¼ssel von Google AI Studio',
        imageForPage: 'Bild fÃ¼r Seite',
        generateAvatar: 'Pixar-Avatar erstellen',
        generatingAvatar: 'Avatar wird erstellt...',
        avatarGenerated: 'Avatar erstellt!',
        useGeneratedAvatar: 'Generierten Avatar verwenden',
        keepOriginal: 'Originalfoto behalten',
        uploadType: 'Was laden Sie hoch?',
        uploadRealPhoto: 'Echtes Foto (Avatar wird generiert)',
        uploadReadyAvatar: 'Fertiger Avatar (bereits stilisiert)',
        editStory: 'Geschichte bearbeiten',
        saveStory: 'Geschichte speichern',
        editScene: 'Szene bearbeiten',
        saveScene: 'Szene speichern',
        editImage: 'Bild bearbeiten',
        regenerateImage: 'Bild neu generieren',
        showPrompt: 'Prompt anzeigen',
        hidePrompt: 'Prompt ausblenden',
        editInstruction: 'Was soll geÃ¤ndert werden?',
        applyEdit: 'Ã„nderung anwenden'
      },
      fr: {
        title: 'Magical Story',
        subtitle: 'Personnalisez votre histoire pour crÃ©er la magie',
        heroTitle: 'Devenez le hÃ©ros de votre histoire',
        heroSubtitle: '',
        heroDescription: 'Transformez vos idÃ©es les plus folles en un conte personnalisÃ© Ã©poustouflant.',
        bookText: 'Obtenez un livre magnifiquement imprimÃ© et donnez Ã  quelqu\'un le sentiment d\'Ãªtre la lÃ©gende qu\'il est vraiment.',
        startJourney: 'Commencez Votre Aventure',
        selectLanguage: 'Choisissez votre langue',
        login: 'Connexion',
        register: 'S\'inscrire',
        logout: 'DÃ©connexion',
        username: 'Nom d\'utilisateur',
        password: 'Mot de passe',
        email: 'Email (facultatif)',
        welcomeBack: 'Bon retour !',
        createAccount: 'CrÃ©er un compte',
        noAccount: 'Pas encore de compte ?',
        haveAccount: 'Vous avez dÃ©jÃ  un compte ?',
        signUp: 'S\'inscrire',
        signIn: 'Se connecter',
        loginRequired: 'Veuillez vous connecter pour continuer',
        continueWithGoogle: 'Continuer avec Google',
        continueWithApple: 'Continuer avec Apple',
        orContinueWith: 'ou continuer avec',
        forgotPassword: 'Mot de passe oubliÃ© ?',
        resetPassword: 'RÃ©initialiser le mot de passe',
        resetPasswordDesc: 'Entrez votre e-mail et nous vous enverrons un lien de rÃ©initialisation',
        sendResetLink: 'Envoyer le lien',
        resetLinkSent: 'E-mail de rÃ©initialisation envoyÃ© ! VÃ©rifiez votre boÃ®te de rÃ©ception.',
        backToLogin: 'Retour Ã  la connexion',
        chooseStoryType: 'Choisissez votre type d\'histoire',
        chooseArtStyle: 'Choisissez votre style artistique',
        artStyleDescription: 'SÃ©lectionnez le style visuel pour votre histoire',
        addCustomStoryType: 'Ajouter un type d\'histoire personnalisÃ©',
        storyTypeName: 'Nom du type d\'histoire',
        storyTypeEmoji: 'Emoji',
        addStoryType: 'Ajouter',
        createCharacters: 'CrÃ©ez vos personnages',
        characterCreated: 'Personnage crÃ©Ã©!',
        createAnother: 'CrÃ©er un autre personnage',
        continueToRelationships: 'Continuer vers les relations',
        yourCharacters: 'Vos personnages:',
        startCreating: 'Commencer Ã  crÃ©er un personnage',
        characterName: 'Nom du personnage',
        characterPhoto: 'Photo du personnage',
        uploadPhoto: 'TÃ©lÃ©charger une photo',
        uploadPhotoFirst: 'Veuillez tÃ©lÃ©charger une photo pour continuer',
        photoGoodExamples: 'Bien: Corps entier ou buste',
        photoBadExamples: 'Ã‰viter: Visage seul, lunettes de soleil, chapeaux, casques, flou',
        orDescribe: 'OU dÃ©crire le personnage',
        characterAge: 'Ã‚ge',
        hairColor: 'Couleur des cheveux',
        otherFeatures: 'Autres caractÃ©ristiques',
        descriptionPlaceholder: 'par ex. Yeux bleus, porte des lunettes, a des taches de rousseur',
        gender: 'Genre',
        male: 'Masculin',
        female: 'FÃ©minin',
        other: 'Inconnu',
        age: 'Ã‚ge',
        strengths: 'Forces',
        weaknesses: 'Faiblesses',
        selectAtLeast: 'SÃ©lectionnez au moins',
        selected: 'SÃ©lectionnÃ©',
        addCustomStrengths: 'Ajouter des forces personnalisÃ©es',
        addCustomWeaknesses: 'Ajouter des faiblesses personnalisÃ©es',
        addCustomFears: 'Ajouter des peurs personnalisÃ©es',
        specialDetails: 'Hobbies, Espoirs & Peurs, Animaux PrÃ©fÃ©rÃ©s et Autres DÃ©tails',
        specialDetailsPlaceholder: 'par ex. Aime peindre, rÃªve de devenir astronaute, peur des araignÃ©es, aime les chevaux',
        fears: 'Peurs',
        addCustomRelationship: 'Ajouter une relation personnalisÃ©e',
        cancel: 'Annuler',
        saveCharacter: 'Sauvegarder le personnage',
        editCharacter: 'Modifier',
        deleteCharacter: 'Supprimer',
        defineRelationships: 'DÃ©finir les relations entre personnages',
        defineRelationshipsDesc: 'DÃ©finissez comment chaque personnage est liÃ© aux autres.',
        is: 'est',
        reverseRelationship: 'Relation inverse:',
        storySettings: 'ParamÃ¨tres de l\'histoire',
        selectMainCharacters: 'SÃ©lectionner les personnages principaux (max 2)',
        numberOfPages: 'Nombre de pages',
        readingLevel: 'Niveau de lecture',
        firstGrade: 'Livre d\'images',
        firstGradeDesc: 'Image et texte sur les deux pages',
        standard: 'Standard',
        standardDesc: 'Texte sur une page, image sur l\'autre',
        advanced: 'AvancÃ©',
        advancedDesc: 'Texte plus long, image sur la page opposÃ©e',
        generateStory: 'GÃ©nÃ©rer l\'histoire!',
        creating: 'CrÃ©ation de votre histoire...',
        storyReady: 'Votre histoire est prÃªte!',
        downloadTXT: 'TÃ©lÃ©charger en TXT',
        downloadPDF: 'TÃ©lÃ©charger en PDF',
        downloadPrompt: 'TÃ©lÃ©charger le prompt',
        viewPrompt: 'Voir le prompt',
        hidePrompt: 'Masquer le prompt',
        promptUsed: 'Prompt utilisÃ© pour gÃ©nÃ©rer l\'histoire:',
        createAnotherStory: 'CrÃ©er une nouvelle histoire',
        back: 'Retour',
        next: 'Suivant',
        exportConfig: 'Exporter la configuration',
        exportStoryInfo: 'Exporter infos histoire (MD)',
        importConfig: 'Importer la configuration',
        charactersCreated: 'Vous avez crÃ©Ã© {count} personnage{s} jusqu\'Ã  prÃ©sent.',
        mainCharacter: 'Personnage principal',
        apiKeyRequired: 'ClÃ© API requise',
        apiKeyPrompt: 'Veuillez entrer votre clÃ© API Anthropic:',
        apiKeyPlaceholder: 'sk-ant-...',
        saveApiKey: 'Sauvegarder la clÃ© API',
        apiKeyNote: 'Votre clÃ© API est stockÃ©e localement dans votre navigateur.',
        promptPreview: 'AperÃ§u du prompt',
        showPromptPreview: 'Afficher le prompt',
        hidePromptPreview: 'Masquer le prompt',
        editPrompt: 'Modifier le prompt',
        resetPrompt: 'RÃ©initialiser',
        storyDetails: 'DÃ©tails supplÃ©mentaires de l\'histoire (Optionnel)',
        storyDetailsPlaceholder: 'ex: Lieu: ForÃªt enchantÃ©e, Ã‰lÃ©ments spÃ©ciaux: Animaux magiques qui parlent, PÃ©riode: Moyen Ã‚ge...',
        generateOutline: 'GÃ©nÃ©rer le plan',
        generatingOutline: 'GÃ©nÃ©ration du plan...',
        outlineReady: 'Plan de l\'histoire',
        editOutline: 'Vous pouvez modifier le plan ci-dessous avant de gÃ©nÃ©rer l\'histoire complÃ¨te:',
        regenerateOutline: 'RÃ©gÃ©nÃ©rer le plan',
        createScenes: 'CrÃ©er les descriptions de scÃ¨nes',
        creatingScenes: 'CrÃ©ation des descriptions de scÃ¨nes...',
        scenesReady: 'Descriptions de scÃ¨nes',
        downloadScenes: 'TÃ©lÃ©charger les scÃ¨nes',
        sceneForPage: 'ScÃ¨ne pour la page',
        yourStory: 'Votre Histoire',
        uploadStory: 'TÃ©lÃ©charger une histoire',
        uploadStoryDesc: 'TÃ©lÃ©chargez un fichier texte d\'histoire existant pour gÃ©nÃ©rer des descriptions de scÃ¨nes',
        generateImages: 'GÃ©nÃ©rer des images de scÃ¨ne',
        generatingImages: 'GÃ©nÃ©ration d\'images...',
        imagesReady: 'Images de scÃ¨ne',
        downloadImage: 'TÃ©lÃ©charger l\'image',
        geminiApiKey: 'ClÃ© API Gemini',
        geminiApiKeyPrompt: 'Entrez votre clÃ© API Google Gemini:',
        geminiApiKeyNote: 'Obtenez votre clÃ© depuis Google AI Studio',
        imageForPage: 'Image pour la page',
        generateAvatar: 'GÃ©nÃ©rer un avatar Pixar',
        generatingAvatar: 'GÃ©nÃ©ration de l\'avatar...',
        avatarGenerated: 'Avatar gÃ©nÃ©rÃ©!',
        useGeneratedAvatar: 'Utiliser l\'avatar gÃ©nÃ©rÃ©',
        keepOriginal: 'Conserver la photo originale',
        uploadType: 'Que tÃ©lÃ©chargez-vous?',
        uploadRealPhoto: 'Photo rÃ©elle (gÃ©nÃ©rera un avatar)',
        uploadReadyAvatar: 'Avatar prÃªt (dÃ©jÃ  stylisÃ©)',
        editStory: 'Modifier l\'histoire',
        saveStory: 'Sauvegarder l\'histoire',
        editScene: 'Modifier la scÃ¨ne',
        saveScene: 'Sauvegarder la scÃ¨ne',
        editImage: 'Modifier l\'image',
        regenerateImage: 'RÃ©gÃ©nÃ©rer l\'image',
        showPrompt: 'Afficher le prompt',
        hidePrompt: 'Masquer le prompt',
        editInstruction: 'Que doit Ãªtre modifiÃ©?',
        applyEdit: 'Appliquer la modification'
      }
    };

    function StoryCreator() {
      // Auto-detect browser language
      const detectBrowserLanguage = () => {
        const browserLang = navigator.language || navigator.userLanguage;
        if (browserLang.startsWith('de')) return 'de';
        if (browserLang.startsWith('fr')) return 'fr';
        return 'en'; // default to English
      };

      const [language, setLanguage] = useState(detectBrowserLanguage());
      const [developerMode, setDeveloperMode] = useState(false); // false = Auto Mode, true = Developer Mode
      const [imageGenMode, setImageGenMode] = useState(null); // null = use server default, 'parallel' or 'sequential'
      const [serverImageGenMode, setServerImageGenMode] = useState('parallel'); // Default from server
      // Skip landing page if already logged in
      const [step, setStep] = useState(() => {
        const savedToken = localStorage.getItem('auth_token');
        const savedUser = localStorage.getItem('current_user');
        return (savedToken && savedUser) ? 1 : 0;
      });
      const [storyType, setStoryType] = useState('');
      const [artStyle, setArtStyle] = useState('pixar'); // Art style for images
      const [storyDetails, setStoryDetails] = useState('');

      // Authentication state
      const [isAuthenticated, setIsAuthenticated] = useState(false);
      const [currentUser, setCurrentUser] = useState(null);
      const [authToken, setAuthToken] = useState(null);
      const [userQuota, setUserQuota] = useState(null);
      const [storyQuota, setStoryQuota] = useState(2);
      const [storiesGenerated, setStoriesGenerated] = useState(0);
      const [showAuthModal, setShowAuthModal] = useState(false);
      const [authMode, setAuthMode] = useState('login'); // 'login' or 'register'
      const [authForm, setAuthForm] = useState({ username: '', password: '', email: '' });
      const [authError, setAuthError] = useState('');
      const [characters, setCharacters] = useState([]);
      const [currentCharacter, setCurrentCharacter] = useState(null);
      const [characterBackup, setCharacterBackup] = useState(null); // Backup for cancel/language change
      const [showCharacterCreated, setShowCharacterCreated] = useState(false);
      const [customStrengths, setCustomStrengths] = useState([]);
      const [customWeaknesses, setCustomWeaknesses] = useState([]);
      const [customFears, setCustomFears] = useState([]);
      const [customRelationships, setCustomRelationships] = useState([]);
      const [newStrength, setNewStrength] = useState('');
      const [newWeakness, setNewWeakness] = useState('');
      const [newFear, setNewFear] = useState('');
      const [newRelationship, setNewRelationship] = useState('');
      const [relationships, setRelationships] = useState({});
      const [isLoadingCharacters, setIsLoadingCharacters] = useState(false); // Prevent auto-save during load
      const [pages, setPages] = useState(30); // Default to 30 print pages for normal users
      const [dedication, setDedication] = useState(''); // Optional dedication text for page 0
      const [languageLevel, setLanguageLevel] = useState('standard');
      const [mainCharacters, setMainCharacters] = useState([]);
      const [generatedStory, setGeneratedStory] = useState('');
      const [rawAIResponse, setRawAIResponse] = useState(''); // Raw unparsed AI response for developer mode
      const [isGenerating, setIsGenerating] = useState(false);
      const [savedStories, setSavedStories] = useState([]);
      const [showSavedStories, setShowSavedStories] = useState(false);
      const [loadingProgress, setLoadingProgress] = useState(0);
      const [loadingBytes, setLoadingBytes] = useState(0);
      const [loadingTotalBytes, setLoadingTotalBytes] = useState(0);
      const [showLoadingProgress, setShowLoadingProgress] = useState(false);
      const [showAdminPanel, setShowAdminPanel] = useState(false);
      const [showProductsPanel, setShowProductsPanel] = useState(false);
      const [adminUsers, setAdminUsers] = useState([]);
      const [orphanedData, setOrphanedData] = useState(null);
      const [isCheckingOrphaned, setIsCheckingOrphaned] = useState(false);
      const [orphanedJobs, setOrphanedJobs] = useState(null);
      const [isCheckingOrphanedJobs, setIsCheckingOrphanedJobs] = useState(false);
      const [apiKey, setApiKey] = useState('');
      const [showApiKeyPrompt, setShowApiKeyPrompt] = useState(false);
      const [tempApiKey, setTempApiKey] = useState('');
      const [generatedPrompt, setGeneratedPrompt] = useState('');
      const [showPrompt, setShowPrompt] = useState(false);
      const [customStoryTypes, setCustomStoryTypes] = useState([]);
      const [newStoryTypeName, setNewStoryTypeName] = useState('');
      const [newStoryTypeEmoji, setNewStoryTypeEmoji] = useState('ðŸŽ­');
      const [showLanguageDropdown, setShowLanguageDropdown] = useState(false);
      const [showMenu, setShowMenu] = useState(false);
      const [editablePrompt, setEditablePrompt] = useState('');
      const [showPromptPreview, setShowPromptPreview] = useState(false);
      const [generationProgress, setGenerationProgress] = useState({ current: 0, total: 0, message: '' });
      const [storyOutline, setStoryOutline] = useState('');
      const [editableOutline, setEditableOutline] = useState('');
      const [isGeneratingOutline, setIsGeneratingOutline] = useState(false);
      const [shortSceneDescriptions, setShortSceneDescriptions] = useState({}); // Map of pageNumber -> short description from outline
      const [sceneDescriptions, setSceneDescriptions] = useState([]);
      const [isGeneratingScenes, setIsGeneratingScenes] = useState(false);
      const [sceneImages, setSceneImages] = useState([]);
      const [isGeneratingImages, setIsGeneratingImages] = useState(false);
      const [coverImages, setCoverImages] = useState({
        frontCover: null,  // Also serves as title page
        initialPage: null,
        backCover: null
      });
      const [storyTitle, setStoryTitle] = useState('');
      const [coverSceneDescriptions, setCoverSceneDescriptions] = useState({
        titlePage: '',
        initialPage: '',
        backCover: ''
      });
      const [geminiApiKey, setGeminiApiKey] = useState('');
      const [showGeminiApiKeyPrompt, setShowGeminiApiKeyPrompt] = useState(false);
      const [tempGeminiApiKey, setTempGeminiApiKey] = useState('');
      const [generatedAvatar, setGeneratedAvatar] = useState(null);
      const [generatedAvatars, setGeneratedAvatars] = useState([]); // Array of {type, image, traits} for 3 variants
      const [isGeneratingAvatar, setIsGeneratingAvatar] = useState(false);
      const [uploadType, setUploadType] = useState('photo'); // 'photo' or 'avatar'
      const [editingStory, setEditingStory] = useState(false);
      const [editableStory, setEditableStory] = useState('');
      const [editingSceneIndex, setEditingSceneIndex] = useState(null);
      const [editableScene, setEditableScene] = useState('');
      const [imagePrompts, setImagePrompts] = useState({}); // Store prompts used for each image
      const [apiCalls, setApiCalls] = useState({}); // Store full API calls for admin debugging
      const [editingImageIndex, setEditingImageIndex] = useState(null);
      const [imageEditInstruction, setImageEditInstruction] = useState('');
      const [editingCoverImage, setEditingCoverImage] = useState(null); // 'frontCover', 'initialPage', 'backCover', or null
      const [coverEditInstruction, setCoverEditInstruction] = useState('');
      const [avatarPrompt, setAvatarPrompt] = useState('');
      const [showAvatarPrompt, setShowAvatarPrompt] = useState(false);
      const [analyzedTraitsText, setAnalyzedTraitsText] = useState(''); // Full analyzed description
      const [characterDevMode, setCharacterDevMode] = useState(false); // Developer mode for character creation (admin only)
      const [sceneDescriptionPrompts, setSceneDescriptionPrompts] = useState({}); // Map of pageNumber -> prompt
      const [showSceneDescriptionPrompt, setShowSceneDescriptionPrompt] = useState(false);
      const [relationshipTexts, setRelationshipTexts] = useState({}); // Custom user-written text for each relationship (NOT translated on language change - user content)
      const [coverImagePrompts, setCoverImagePrompts] = useState({}); // Store prompts for cover images
      const [coverImageApiCalls, setCoverImageApiCalls] = useState({}); // Store API calls for cover images
      const [storyOutlinePrompt, setStoryOutlinePrompt] = useState(''); // Store outline generation prompt
      const [storyOutlineApiCall, setStoryOutlineApiCall] = useState(null); // Store outline API call
      const [storyTextPrompt, setStoryTextPrompt] = useState(''); // Store story text generation prompt
      const [storyTextApiCall, setStoryTextApiCall] = useState(null); // Store story text API call

      // Character Consistency System
      const [characterManifest, setCharacterManifest] = useState(null); // Character manifest from story generation
      const [characterConsistencyGuide, setCharacterConsistencyGuide] = useState(''); // Text guide for image prompts
      const [baseCharacterImages, setBaseCharacterImages] = useState({}); // Map of character ID -> cartoon base64
      const [isGeneratingCartoons, setIsGeneratingCartoons] = useState(false);
      const [currentStoryId, setCurrentStoryId] = useState(null); // Track current story ID for print orders
      const [showShippingModal, setShowShippingModal] = useState(false);
      const [shippingForm, setShippingForm] = useState({
        firstName: '',
        lastName: '',
        addressLine1: '',
        city: '',
        postCode: '',
        country: 'CH', // Hardcoded to Switzerland only
        email: ''
      });
      const [emailChanged, setEmailChanged] = useState(false);
      const [adminTab, setAdminTab] = useState('users'); // 'users', 'products', or 'orders'
      const [impersonateUserId, setImpersonateUserId] = useState(null); // Admin impersonation mode
      const [impersonateUsername, setImpersonateUsername] = useState(null);
      const [failedOrders, setFailedOrders] = useState([]);
      const [isLoadingOrders, setIsLoadingOrders] = useState(false);
      const [retryingOrderId, setRetryingOrderId] = useState(null);
      const [printProducts, setPrintProducts] = useState([]);
      const [showProductForm, setShowProductForm] = useState(false);
      const [editingProduct, setEditingProduct] = useState(null);
      const [productForm, setProductForm] = useState({
        product_uid: '',
        product_name: '',
        description: '',
        size: '',
        cover_type: '',
        min_pages: 24,
        max_pages: 24,
        available_page_counts: '[24]',
        is_active: true
      });
      const [showOrderModal, setShowOrderModal] = useState(false);
      const [orderData, setOrderData] = useState(null); // { orderId, dashboardUrl, pdfUrl, pdfFilename, isDraft, previewUrls }

      const characterFormRef = React.useRef(null);

      useEffect(() => {
        // Check for saved authentication token
        const savedToken = localStorage.getItem('auth_token');
        const savedUser = localStorage.getItem('current_user');

        console.log('ðŸ” Checking saved auth:', {
          hasToken: !!savedToken,
          hasUser: !!savedUser,
          token: savedToken ? savedToken.substring(0, 20) + '...' : 'none'
        });

        if (savedToken && savedUser) {
          const user = JSON.parse(savedUser);
          setAuthToken(savedToken);
          setCurrentUser(user);
          setIsAuthenticated(true);
          console.log('âœ… Auto-login successful - data will be loaded by useEffect');
        } else {
          console.log('âŒ No saved auth found');
        }
        // Don't show auth modal automatically - user needs to click "Start Your Adventure"

        // Keep API key loading for backwards compatibility (will be deprecated)
        const savedApiKey = localStorage.getItem('anthropic_api_key');
        if (savedApiKey) {
          setApiKey(savedApiKey);
        }
        const savedGeminiKey = localStorage.getItem('gemini_api_key');
        if (savedGeminiKey) {
          setGeminiApiKey(savedGeminiKey);
        }
        if (window.lucide) {
          window.lucide.createIcons();
        }
      }, []); // Run only once on mount - don't re-run when step changes!

      // Fetch server config on mount
      useEffect(() => {
        const fetchConfig = async () => {
          try {
            const response = await fetch(`${API_URL}/api/config`);
            if (response.ok) {
              const config = await response.json();
              if (config.imageGenMode) {
                setServerImageGenMode(config.imageGenMode);
                console.log('ðŸ“‹ Server config loaded:', config);
              }
            }
          } catch (error) {
            console.log('Could not fetch server config, using defaults');
          }
        };
        fetchConfig();
      }, []);

      // Set default page count based on user role
      useEffect(() => {
        if (currentUser) {
          if (currentUser.role === 'admin') {
            setPages(10); // Admin default: 10 pages for testing
          } else {
            setPages(30); // Normal user default: 30 print pages
          }
        }
      }, [currentUser]);

      // Set up browser error tracking - send errors to server
      useEffect(() => {
        const logErrorToServer = async (errorData) => {
          try {
            await fetch(`${API_URL}/api/log-error`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                ...errorData,
                userId: currentUser?.id || 'anonymous',
                userAgent: navigator.userAgent,
                timestamp: new Date().toISOString()
              })
            });
          } catch (err) {
            // Silently fail if logging fails - don't want to create error loops
            console.warn('Failed to log error to server:', err);
          }
        };

        // Capture global JavaScript errors
        const handleError = (event) => {
          logErrorToServer({
            errorType: 'JavaScript Error',
            message: event.message || 'Unknown error',
            url: event.filename || window.location.href,
            line: event.lineno,
            column: event.colno,
            stack: event.error?.stack || 'No stack trace'
          });
        };

        // Capture unhandled promise rejections
        const handleUnhandledRejection = (event) => {
          logErrorToServer({
            errorType: 'Unhandled Promise Rejection',
            message: event.reason?.message || String(event.reason) || 'Unknown rejection',
            url: window.location.href,
            stack: event.reason?.stack || 'No stack trace'
          });
        };

        // Capture console errors
        const originalConsoleError = console.error;
        console.error = function(...args) {
          // Call original console.error
          originalConsoleError.apply(console, args);

          // Log to server (but skip if it's our own error logging to avoid loops)
          if (!args[0]?.toString().includes('BROWSER ERROR:')) {
            logErrorToServer({
              errorType: 'Console Error',
              message: args.map(arg => String(arg)).join(' '),
              url: window.location.href,
              stack: new Error().stack
            });
          }
        };

        // Attach event listeners
        window.addEventListener('error', handleError);
        window.addEventListener('unhandledrejection', handleUnhandledRejection);

        // Cleanup on unmount
        return () => {
          window.removeEventListener('error', handleError);
          window.removeEventListener('unhandledrejection', handleUnhandledRejection);
          console.error = originalConsoleError;
        };
      }, [currentUser]);

      // Load characters and story draft when user logs in (stories loaded on-demand when opening "My Stories")
      useEffect(() => {
        if (authToken && isAuthenticated) {
          console.log('ðŸ”„ Loading user data (characters, story draft, quota)...');
          loadCharacters();
          loadStoryDraft();
          fetchUserQuota();
        }
      }, [authToken, isAuthenticated]);

      // Check for Stripe payment callback on page load
      useEffect(() => {
        const urlParams = new URLSearchParams(window.location.search);
        const paymentStatus = urlParams.get('payment');
        const sessionId = urlParams.get('session_id');

        if (paymentStatus === 'success' && sessionId) {
          console.log('âœ… [STRIPE] Payment successful!');
          console.log('   Session ID:', sessionId);
          console.log('   Checking order status...');

          // Check order status in database
          fetch(`${API_URL}/api/stripe/order-status/${sessionId}`, {
            headers: { 'Authorization': `Bearer ${authToken}` }
          })
            .then(res => res.json())
            .then(data => {
              console.log('ðŸ“¦ [STRIPE] Order Status:', data);
              if (data.order) {
                console.log('   Customer:', data.order.customer_name);
                console.log('   Email:', data.order.customer_email);
                console.log('   Shipping Address:', {
                  name: data.order.shipping_name,
                  line1: data.order.shipping_address_line1,
                  city: data.order.shipping_city,
                  postal_code: data.order.shipping_postal_code,
                  country: data.order.shipping_country
                });
                console.log('   Amount:', (data.order.amount_total / 100).toFixed(2), data.order.currency.toUpperCase());
                // Language-aware success message
                const amount = `CHF ${(data.order.amount_total / 100).toFixed(2)}`;
                const successMessages = {
                  en: `Payment successful! Your book order has been received.\n\nOrder Details:\nCustomer: ${data.order.customer_name}\nEmail: ${data.order.customer_email}\nAmount: ${amount}\n\nYour book will be printed and shipped to:\n${data.order.shipping_name}\n${data.order.shipping_address_line1}\n${data.order.shipping_city}, ${data.order.shipping_postal_code}\n${data.order.shipping_country}`,
                  de: `Zahlung erfolgreich! Ihre Buchbestellung wurde entgegengenommen.\n\nBestelldetails:\nKunde: ${data.order.customer_name}\nE-Mail: ${data.order.customer_email}\nBetrag: ${amount}\n\nIhr Buch wird gedruckt und versendet an:\n${data.order.shipping_name}\n${data.order.shipping_address_line1}\n${data.order.shipping_city}, ${data.order.shipping_postal_code}\n${data.order.shipping_country}`,
                  fr: `Paiement rÃ©ussi! Votre commande de livre a Ã©tÃ© reÃ§ue.\n\nDÃ©tails de la commande:\nClient: ${data.order.customer_name}\nE-mail: ${data.order.customer_email}\nMontant: ${amount}\n\nVotre livre sera imprimÃ© et expÃ©diÃ© Ã :\n${data.order.shipping_name}\n${data.order.shipping_address_line1}\n${data.order.shipping_city}, ${data.order.shipping_postal_code}\n${data.order.shipping_country}`
                };
                const storedLang = localStorage.getItem('magicalstory_language') || 'en';
                alert(successMessages[storedLang] || successMessages.en);
              }

              // Clean up URL
              window.history.replaceState({}, document.title, window.location.pathname);
            })
            .catch(err => {
              console.error('âŒ [STRIPE] Error checking order status:', err);
            });

        } else if (paymentStatus === 'cancelled') {
          console.log('âš ï¸  [STRIPE] Payment cancelled by user');
          const cancelMsg = {
            en: 'Payment was cancelled. You can try again when ready.',
            de: 'Zahlung wurde abgebrochen. Sie kÃ¶nnen es erneut versuchen, wenn Sie bereit sind.',
            fr: 'Paiement annulÃ©. Vous pouvez rÃ©essayer quand vous Ãªtes prÃªt.'
          };
          alert(cancelMsg[storedLang] || cancelMsg.en);

          // Clean up URL
          window.history.replaceState({}, document.title, window.location.pathname);
        }

        // Check for admin impersonation mode
        const impersonateUser = urlParams.get('impersonate');
        const impersonateStory = urlParams.get('story');
        if (impersonateUser && impersonateStory) {
          console.log(`ðŸ” [ADMIN] Impersonation mode: user=${impersonateUser}, story=${impersonateStory}`);
          setImpersonateUserId(impersonateUser);

          // Load the story via admin endpoint
          const token = localStorage.getItem('auth_token');
          if (token) {
            fetch(`${API_URL}/api/admin/users/${impersonateUser}/stories/${impersonateStory}`, {
              headers: { 'Authorization': `Bearer ${token}` }
            })
              .then(res => {
                if (!res.ok) throw new Error('Failed to load story');
                return res.json();
              })
              .then(fullStory => {
                console.log('âœ… [ADMIN] Loaded impersonated story:', fullStory.title);
                setImpersonateUsername(fullStory.userId || impersonateUser);
                setCurrentStoryId(fullStory.id);
                setStoryType(fullStory.storyType);
                setArtStyle(fullStory.artStyle);
                setPages(fullStory.pages);
                setLanguageLevel(fullStory.languageLevel || 'standard'); // Critical for display mode (picture book vs standard)
                setLanguage(fullStory.language || 'en');
                setDedication(fullStory.dedication || '');
                setCharacters(fullStory.characters || []);
                setMainCharacters(fullStory.mainCharacters || []);
                setRelationships(fullStory.relationships || {});
                setRelationshipTexts(fullStory.relationshipTexts || {});
                setStoryOutline(fullStory.outline || '');
                setGeneratedStory(fullStory.story || '');
                setSceneDescriptions(fullStory.sceneDescriptions || []);
                setSceneImages(fullStory.sceneImages || []);
                setStoryTitle(fullStory.title || '');
                setCoverImages(fullStory.coverImages || { frontCover: null, initialPage: null, backCover: null });
                setImagePrompts(fullStory.imagePrompts || {});
                setCoverImagePrompts(fullStory.coverImagePrompts || {});
                setRawAIResponse(fullStory.rawAIResponse || '');
                setStep(5);
              })
              .catch(err => {
                console.error('âŒ [ADMIN] Error loading impersonated story:', err);
                alert('Failed to load story in impersonation mode. Make sure you are logged in as admin.');
              });
          }
        }
      }, []);

      // Scroll to top when step changes
      useEffect(() => {
        window.scrollTo({ top: 0, behavior: 'smooth' });
      }, [step]);

      // Always load stories when user opens the stories modal
      useEffect(() => {
        if (showSavedStories && authToken) {
          console.log('ðŸ“– Refreshing stories when opening modal...');
          loadStories().then(async (stories) => {
            console.log('ðŸ“š Stories refreshed:', stories.length, stories);

            // Lazy load thumbnails for stories that don't have them
            const storiesNeedingThumbnails = stories.filter(story => !story.thumbnail);

            if (storiesNeedingThumbnails.length > 0) {
              console.log(`ðŸ–¼ï¸  Loading thumbnails for ${storiesNeedingThumbnails.length} stories...`);

              const thumbnailPromises = storiesNeedingThumbnails.map(async (story) => {
                try {
                  console.log(`ðŸ–¼ï¸  Fetching thumbnail for story: ${story.id}`);
                  const response = await fetch(`${API_URL}/api/stories/${story.id}`, {
                    headers: { 'Authorization': `Bearer ${authToken}` }
                  });

                  if (response.ok) {
                    const fullStory = await response.json();
                    if (fullStory.coverImages?.frontCover) {
                      console.log(`âœ… Got thumbnail for story: ${story.id}`);
                      const thumbnail = getCoverImageData(fullStory.coverImages.frontCover);
                      return { id: story.id, thumbnail };
                    }
                  }
                } catch (err) {
                  console.error(`âŒ Error loading thumbnail for story ${story.id}:`, err);
                }
                return null;
              });

              const thumbnails = await Promise.all(thumbnailPromises);

              // Merge thumbnails into stories before setting state (single update)
              const storiesWithThumbnails = stories.map(story => {
                const thumbnailData = thumbnails.find(t => t && t.id === story.id);
                return thumbnailData ? { ...story, thumbnail: thumbnailData.thumbnail } : story;
              });

              setSavedStories(storiesWithThumbnails);
              console.log('âœ… Thumbnails loaded successfully');
            } else {
              // No thumbnails to load, just set stories
              setSavedStories(stories);
            }
          }).catch(err => {
            console.error('âŒ Error refreshing stories:', err);
          });
        }
      }, [showSavedStories]);

      // Load story metadata on login to show correct count in button
      useEffect(() => {
        if (authToken && !showSavedStories) {
          console.log('ðŸ“š Loading story metadata on login...');
          loadStories().then(stories => {
            console.log(`ðŸ“š Loaded ${stories.length} stories for count display`);
            setSavedStories(stories);
          }).catch(err => {
            console.error('âŒ Error loading story metadata:', err);
          });
        }
      }, [authToken]);

      // Load users when admin panel is opened
      useEffect(() => {
        if (showAdminPanel && currentUser && currentUser.role === 'admin') {
          fetchAllUsers();
        }
      }, [showAdminPanel]);

      // Track previous language for translation
      const prevLanguageRef = React.useRef(language);

      // Translate character data when language changes
      useEffect(() => {
        const prevLang = prevLanguageRef.current;

        if (prevLang && prevLang !== language) {
          console.log(`ðŸŒ Language changed from ${prevLang} to ${language}, translating character data...`);

          // Helper to translate relationship value
          const translateRelationship = (relValue) => {
            if (!relValue) return relValue;

            // Find matching relationship type
            for (const relType of relationshipTypes) {
              if (relType.value[prevLang] === relValue) {
                return relType.value[language];
              }
              if (relType.inverse[prevLang] === relValue) {
                return relType.inverse[language];
              }
            }
            // Custom relationship - keep as is
            return relValue;
          };

          // Translate current character being edited (use functional update to avoid stale closure)
          setCurrentCharacter(prev => {
            if (!prev) return prev;
            return {
              ...prev,
              strengths: translateArray(prev.strengths || [], prevLang, language, defaultStrengths),
              weaknesses: translateArray(prev.weaknesses || [], prevLang, language, defaultWeaknesses),
              fears: translateArray(prev.fears || [], prevLang, language, fearOptions)
            };
          });

          // Translate character backup if exists (use functional update)
          setCharacterBackup(prev => {
            if (!prev) return prev;
            return {
              ...prev,
              strengths: translateArray(prev.strengths || [], prevLang, language, defaultStrengths),
              weaknesses: translateArray(prev.weaknesses || [], prevLang, language, defaultWeaknesses),
              fears: translateArray(prev.fears || [], prevLang, language, fearOptions)
            };
          });

          // Translate all existing characters (use functional update)
          setCharacters(prevChars => {
            if (!prevChars || prevChars.length === 0) return prevChars;
            return prevChars.map(char => ({
              ...char,
              strengths: translateArray(char.strengths || [], prevLang, language, defaultStrengths),
              weaknesses: translateArray(char.weaknesses || [], prevLang, language, defaultWeaknesses),
              fears: translateArray(char.fears || [], prevLang, language, fearOptions)
            }));
          });

          // Translate relationships (use functional update to avoid stale closure - CRITICAL)
          setRelationships(prevRelationships => {
            if (!prevRelationships || Object.keys(prevRelationships).length === 0) {
              console.log('ðŸŒ [TRANSLATE] No relationships to translate');
              return prevRelationships;
            }
            console.log('ðŸŒ [TRANSLATE] Translating', Object.keys(prevRelationships).length, 'relationships');
            const translatedRelationships = {};
            for (const [key, value] of Object.entries(prevRelationships)) {
              translatedRelationships[key] = translateRelationship(value);
            }
            return translatedRelationships;
          });
        }

        // Save language preference to localStorage
        localStorage.setItem('magicalstory_language', language);

        // Update previous language ref
        prevLanguageRef.current = language;
      }, [language]);

      // Initialize character when entering step 2
      useEffect(() => {
        console.log('ðŸ“ Step changed:', {
          step,
          isAuthenticated,
          hasCurrentCharacter: !!currentCharacter,
          existingCharactersCount: characters.length
        });

        if (step === 2) {
          // If there are existing characters and we're navigating TO step 2, clear currentCharacter to show the list
          if (characters.length > 0 && currentCharacter) {
            console.log('ðŸŽ­ Clearing current character to show character list');
            setCurrentCharacter(null);
          }
          // Only auto-create new character if there are NO characters at all
          else if (characters.length === 0 && !currentCharacter) {
            console.log('ðŸŽ­ No characters exist - initializing new character for step 2');
            startNewCharacter();
          }
        }
      }, [step]);

      // Save characters and relationships whenever they change (with debounce)
      // Skip saving while loading OR while editing a character to prevent race conditions
      useEffect(() => {
        // Don't save if:
        // - No auth token
        // - No characters (nothing to save)
        // - Currently loading characters from server
        // - Currently editing a character (characterBackup exists = character temporarily removed from array)
        if (authToken && characters.length > 0 && !isLoadingCharacters && !characterBackup) {
          const timeoutId = setTimeout(() => {
            // Pass all data explicitly to avoid stale closure issues
            console.log('ðŸ’¾ [AUTO-SAVE] Saving characters and relationships...', {
              characterCount: characters.length,
              relationshipCount: Object.keys(relationships).length,
              relationshipKeys: Object.keys(relationships)
            });
            saveCharacters({
              characters,
              relationships,
              relationshipTexts,
              customRelationships,
              customStrengths,
              customWeaknesses,
              customFears
            });
          }, 1000); // Debounce for 1 second

          return () => clearTimeout(timeoutId);
        } else if (characterBackup) {
          console.log('ðŸ’¾ [AUTO-SAVE] Skipped - character being edited');
        }
      }, [characters, relationships, relationshipTexts, customRelationships, customStrengths, customWeaknesses, customFears, authToken, isLoadingCharacters, characterBackup]);

      // Auto-save story draft settings (step 1 & 4) whenever they change
      useEffect(() => {
        // Don't save if not authenticated or still loading draft
        if (!authToken || isLoadingDraft) return;

        // Only save if we have meaningful data (at least storyType or storyDetails)
        if (!storyType && !storyDetails && !dedication) return;

        const timeoutId = setTimeout(() => {
          console.log('ðŸ“ [AUTO-SAVE DRAFT] Saving story settings...', {
            storyType,
            artStyle,
            storyDetails: storyDetails?.substring(0, 50) + '...',
            dedication: dedication?.substring(0, 30) + '...',
            pages,
            languageLevel,
            mainCharactersCount: mainCharacters.length
          });
          saveStoryDraft({
            storyType,
            artStyle,
            storyDetails,
            dedication,
            pages,
            languageLevel,
            mainCharacters
          });
        }, 1500); // Debounce for 1.5 seconds

        return () => clearTimeout(timeoutId);
      }, [storyType, artStyle, storyDetails, dedication, pages, languageLevel, mainCharacters, authToken, isLoadingDraft]);

      // Update prompt when returning to step 4 with prompt visible
      useEffect(() => {
        if (step === 4 && showPromptPreview && storyType && characters.length > 0) {
          try {
            const newPrompt = buildOutlinePrompt();
            setEditablePrompt(newPrompt);
          } catch (error) {
            console.error('Error building prompt:', error);
          }
        }
      }, [step, showPromptPreview]);

      const t = translations[language];
      const allStrengths = [...defaultStrengths[language], ...customStrengths];
      const allWeaknesses = [...defaultWeaknesses[language], ...customWeaknesses];
      const allFears = [...fearOptions[language], ...customFears];
      const allRelationships = [...relationshipTypes, ...customRelationships.map(rel => ({
        value: { en: rel, de: rel, fr: rel },
        inverse: { en: rel, de: rel, fr: rel }
      }))];

      // Helper function to translate values between languages
      const translateValue = (value, fromLang, toLang, options) => {
        if (!value || !fromLang || !toLang || fromLang === toLang) return value;

        // Try to find the value in the source language array
        const sourceArray = options[fromLang];
        const targetArray = options[toLang];

        if (!sourceArray || !targetArray) return value;

        const index = sourceArray.indexOf(value);
        if (index !== -1 && index < targetArray.length) {
          return targetArray[index];
        }

        // If not found in predefined options, keep original (custom value)
        return value;
      };

      // Helper to translate array of values
      const translateArray = (values, fromLang, toLang, options) => {
        if (!values || !Array.isArray(values)) return [];
        return values.map(val => translateValue(val, fromLang, toLang, options));
      };
      const allStoryTypes = [...storyTypes, ...customStoryTypes];

      const detectGender = (name) => {
        const femaleSuffixes = ['a', 'e', 'ie', 'ine', 'elle'];
        const femaleNames = ['sophia', 'emma', 'olivia', 'ava', 'isabella', 'mia', 'charlotte', 'amelia', 'marie', 'anna', 'lisa', 'julia', 'sarah', 'laura', 'lena'];
        const maleNames = ['liam', 'noah', 'oliver', 'james', 'lucas', 'max', 'leon', 'paul', 'ben', 'tom', 'felix', 'lukas', 'tim', 'jan', 'finn'];

        const lowerName = name.toLowerCase();

        if (femaleNames.some(n => lowerName.includes(n))) return 'female';
        if (maleNames.some(n => lowerName.includes(n))) return 'male';
        if (femaleSuffixes.some(suffix => lowerName.endsWith(suffix))) return 'female';

        return 'other';
      };

      const getInverseRelationship = (relationship) => {
        const rel = relationshipTypes.find(r => r.value[language] === relationship);
        return rel ? rel.inverse[language] : relationship;
      };

      const saveApiKeyToStorage = () => {
        if (tempApiKey.trim()) {
          localStorage.setItem('anthropic_api_key', tempApiKey.trim());
          setApiKey(tempApiKey.trim());
          setShowApiKeyPrompt(false);
          setTempApiKey('');
        }
      };

      const buildPrompt = () => {
        const characterDescriptions = characters.map(char => {
          const isMain = mainCharacters.includes(char.id) ? ' (MAIN CHARACTER)' : '';
          let desc = `${char.name}${isMain} (${char.gender}, ${char.age} years old)`;

          // Only add fields that have values (exclude physical features - only personality traits)
          const details = [];
          if (char.strengths && char.strengths.length > 0) {
            details.push(`${t.strengths}: ${char.strengths.join(', ')}`);
          }
          if (char.weaknesses && char.weaknesses.length > 0) {
            details.push(`${t.weaknesses}: ${char.weaknesses.join(', ')}`);
          }
          if (char.fears && char.fears.length > 0) {
            details.push(`${t.fears}: ${char.fears.join(', ')}`);
          }
          // Do NOT include hairColor, otherFeatures, height, build in story prompt
          if (char.specialDetails) {
            details.push(`${t.specialDetails}: ${char.specialDetails}`);
          }

          if (details.length > 0) {
            desc += `: ${details.join(', ')}`;
          }

          return desc;
        }).join('\n');

        const relationshipDescriptions = Object.entries(relationships)
          .filter(([key, type]) => {
            const [char1Id, _] = key.split('-').map(Number);
            const char1Index = characters.findIndex(c => c.id === char1Id);
            const char2Index = characters.findIndex(c => c.id === parseInt(key.split('-')[1]));
            // Use helper to check all languages (not just English)
            return !isNotKnownRelationship(type) && char1Index < char2Index;
          })
          .map(([key, type]) => {
            const [char1Id, char2Id] = key.split('-').map(Number);
            const char1 = characters.find(c => c.id === char1Id);
            const char2 = characters.find(c => c.id === char2Id);
            const relationshipText = relationshipTexts[key] || ''; // Get custom text if exists
            const baseRelationship = `${char1?.name} ${t.is} ${type} ${char2?.name}`;
            return relationshipText ? `${baseRelationship}. ${relationshipText}` : baseRelationship;
          }).join('\n');

        const languageInstructions = {
          'en': {
            '1st-grade': 'Use very simple words and short sentences suitable for 1st graders who are just learning to read.',
            'standard': 'Use age-appropriate vocabulary and sentence structure for elementary school children.',
            'advanced': 'Use more complex vocabulary and varied sentence structure for advanced readers.'
          },
          'de': {
            '1st-grade': 'Verwende sehr einfache WÃ¶rter und kurze SÃ¤tze, die fÃ¼r ErstklÃ¤ssler geeignet sind, die gerade lesen lernen.',
            'standard': 'Verwende altersgerechtes Vokabular und Satzstruktur fÃ¼r Grundschulkinder.',
            'advanced': 'Verwende komplexeres Vokabular und abwechslungsreiche Satzstruktur fÃ¼r fortgeschrittene Leser.'
          },
          'fr': {
            '1st-grade': 'Utilisez des mots trÃ¨s simples et des phrases courtes adaptÃ©es aux Ã©lÃ¨ves de 1Ã¨re annÃ©e qui apprennent Ã  lire.',
            'standard': 'Utilisez un vocabulaire et une structure de phrase adaptÃ©s Ã  l\'Ã¢ge pour les enfants de l\'Ã©cole primaire.',
            'advanced': 'Utilisez un vocabulaire plus complexe et une structure de phrase variÃ©e pour les lecteurs avancÃ©s.'
          }
        };

        const storyTypeName = allStoryTypes.find(t => t.id === storyType)?.name[language] || 'adventure';

        let prompt = `Create a ${pages}-page children's story about a ${storyTypeName} in ${language === 'de' ? 'German (use Ã¤, Ã¶, Ã¼ normally. Do not use ÃŸ, use ss instead)' : language === 'fr' ? 'French' : 'English'}.\n\n`;

        if (storyDetails) {
          prompt += `Additional Story Requirements:\n${storyDetails}\n\n`;
        }

        prompt += `Characters:\n${characterDescriptions}\n\n`;

        if (relationshipDescriptions && relationshipDescriptions.length > 0) {
          prompt += `Relationships:\n${relationshipDescriptions}\n\n`;
        }

        prompt += `Language Level: ${languageInstructions[language][languageLevel]}\n\n`;
        prompt += `IMPORTANT INSTRUCTIONS:\n`;
        prompt += `- Only use the character names provided above. Do NOT invent any new names.\n`;
        prompt += `- You may create additional characters (like grandfather, shopkeeper, teacher, etc.) but they must remain UNNAMED.\n`;
        prompt += `- Refer to additional characters only by their role or relationship (e.g., "the grandfather", "the shopkeeper", "her teacher") - NEVER give them names like "Grandfather Steve" or "Shopkeeper Paul".\n`;
        prompt += `- Use the characters' ages and traits to inform their personality and behavior, but DO NOT explicitly state their age or characteristics in the story.\n`;
        prompt += `- SHOW the characteristics through actions and dialogue instead of stating them. For example, instead of "Sophie was brave", show Sophie doing something brave. Instead of "Max, who was 8 years old", just use "Max" and let his behavior reflect his age.\n\n`;
        prompt += `Please write an engaging, age-appropriate story that incorporates all the characters, their traits, and relationships. Focus especially on the main character(s). Structure it with clear page breaks (use "--- Page X ---" markers). Make it exciting, positive, and include a meaningful lesson or resolution. Each page should be a distinct scene or moment in the story. Write the complete story without truncation. The story should be written entirely in ${language === 'de' ? 'German (use Ã¤, Ã¶, Ã¼ normally. Do not use ÃŸ, use ss instead)' : language === 'fr' ? 'French' : 'English'}.`;

        return prompt;
      };

      // Build the full outline prompt with Role/Context and structured sections
      const buildOutlinePrompt = () => {
        const basePrompt = buildPrompt();

        return `# Role and Context

You are an expert children's book writer with deep understanding of age-appropriate storytelling, narrative structure, and visual storytelling for illustrated books. Your expertise includes:

- Creating engaging, age-appropriate narratives that captivate young readers
- Crafting clear story arcs with proper setup, conflict, and resolution
- Writing vivid scene descriptions that translate beautifully to illustrations
- Balancing text and visual elements for maximum impact
- Understanding pacing and page turns in illustrated books
- Creating memorable characters and meaningful moments

Your task is to create a compelling, well-structured story outline that will guide both the narrative text and visual illustrations.

${basePrompt}

# Part 1: Story Title

Create an engaging, age-appropriate title for this story. The title should:
- Capture the essence of the story
- Be appealing to the target age group
- Be memorable and creative
- Reflect the main theme or adventure

Format:
Title: [Your creative title here]

# Part 2: Story Outline

Create a detailed outline for this ${pages}-page story. Include:
- Brief summary of each page (what happens on that page)
- Key events and character moments
- Story arc and progression (clear beginning, middle, and end)
- How the story builds tension and resolves satisfyingly

For EACH of the ${pages} story pages, provide a SHORT SCENE DESCRIPTION (1-2 sentences) that describes the visual scene - what the characters are doing, where they are, and the setting. This will be used for illustration purposes.

# Part 3: Cover Scene Descriptions

In addition to the ${pages} story pages, provide scene descriptions for these 3 cover elements:

**Title Page Scene**: A captivating cover illustration that features the main characters and sets the tone for the story. This should be visually striking and focus on the protagonist(s) in a way that draws readers in.

**Initial Page Scene**: A dedication/introduction page illustration that creates a warm, inviting entry into the story world. This sets the mood and welcomes readers.

**Back Cover Scene**: A satisfying concluding illustration that provides closure and leaves readers with a positive feeling. This should feel like a natural ending to the visual journey.

# Format Your Response

Title: [Story title]

Page 1: [Summary]
Scene: [Short visual description]

Page 2: [Summary]
Scene: [Short visual description]

...and so on for all ${pages} pages.

Title Page: [Summary of title page concept]
Scene: [Visual description focusing on main characters]

Initial Page: [Summary of dedication/intro concept]
Scene: [Visual description for welcoming scene]

Back Cover: [Summary of back cover concept]
Scene: [Visual description for concluding scene]

Be specific and creative. Each scene description should paint a clear picture for the illustrator.`;
      };

      // API URL Configuration
      // Smart detection: use relative URLs when on same domain (faster, no CORS preflight)
      const API_URL = window.location.hostname === 'localhost'
        ? 'http://localhost:3000'  // Local development
        : window.location.hostname.includes('railway.app')
          ? ''  // Same domain (Railway) - use relative URLs (no CORS preflight)
          : 'https://magicalstory-production.up.railway.app';  // Cross-origin (IONOS frontend)

      // Authentication functions
      const handleLogin = async (e) => {
        e?.preventDefault();
        setAuthError('');

        try {
          const response = await fetch(`${API_URL}/api/auth/login`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              username: authForm.username,
              password: authForm.password
            })
          });

          const data = await response.json();

          if (!response.ok) {
            throw new Error(data.error || 'Login failed');
          }

          // Save token and user info
          localStorage.setItem('auth_token', data.token);
          localStorage.setItem('current_user', JSON.stringify(data.user));

          setAuthToken(data.token);
          setCurrentUser(data.user);
          setIsAuthenticated(true);
          setShowAuthModal(false);
          setAuthForm({ username: '', password: '', email: '' });
          setStep(1); // Go to first step after login
        } catch (err) {
          setAuthError(err.message);
        }
      };

      const handleRegister = async (e) => {
        e?.preventDefault();
        setAuthError('');

        try {
          const response = await fetch(`${API_URL}/api/auth/register`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              username: authForm.username,
              password: authForm.password,
              email: authForm.email
            })
          });

          const data = await response.json();

          if (!response.ok) {
            throw new Error(data.error || 'Registration failed');
          }

          // Save token and user info
          localStorage.setItem('auth_token', data.token);
          localStorage.setItem('current_user', JSON.stringify(data.user));

          setAuthToken(data.token);
          setCurrentUser(data.user);
          setIsAuthenticated(true);
          setShowAuthModal(false);
          setAuthForm({ username: '', password: '', email: '' });
          setStep(1); // Go to first step after login
        } catch (err) {
          setAuthError(err.message);
        }
      };

      const handleLogout = () => {
        localStorage.removeItem('auth_token');
        localStorage.removeItem('current_user');
        // Also sign out from Firebase if signed in
        if (firebaseAuth.currentUser) {
          firebaseAuth.signOut();
        }
        setAuthToken(null);
        setCurrentUser(null);
        setUserQuota(null);
        setIsAuthenticated(false);
        setShowAuthModal(true);
      };

      // Detect if running on mobile device (especially iOS Safari where popups don't work well)
      const isMobileDevice = () => {
        return /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
      };

      // Firebase Auth: Handle social login result from backend
      const handleFirebaseAuth = async (firebaseUser) => {
        try {
          // Get Firebase ID token
          const idToken = await firebaseUser.getIdToken();

          // Send to backend for verification and user creation/login
          const response = await fetch(`${API_URL}/api/auth/firebase`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ idToken })
          });

          const data = await response.json();

          if (!response.ok) {
            throw new Error(data.error || 'Firebase authentication failed');
          }

          // Save token and user info (same as regular login)
          localStorage.setItem('auth_token', data.token);
          localStorage.setItem('current_user', JSON.stringify(data.user));

          setAuthToken(data.token);
          setCurrentUser(data.user);
          setIsAuthenticated(true);
          setShowAuthModal(false);
          setAuthForm({ username: '', password: '', email: '' });
          setStep(1);
        } catch (err) {
          setAuthError(err.message);
        }
      };

      // Handle redirect result on page load (for mobile sign-in)
      React.useEffect(() => {
        const handleRedirectResult = async (retryCount = 0) => {
          try {
            const result = await firebaseAuth.getRedirectResult();
            if (result && result.user) {
              console.log('ðŸ“± Redirect auth successful');
              await handleFirebaseAuth(result.user);
            }
          } catch (err) {
            // Retry on IndexedDB errors (common on iOS Safari)
            if (err.message?.includes('IndexedDB') || err.message?.includes('Indexed Database')) {
              if (retryCount < 3) {
                console.warn(`ðŸ“± Redirect auth IndexedDB error, retrying (${retryCount + 1}/3)...`);
                setTimeout(() => handleRedirectResult(retryCount + 1), 1000);
                return;
              }
              console.error('ðŸ“± Redirect auth failed after retries - IndexedDB issues');
              setAuthError('Login failed due to browser storage issues. Please try again or use a different browser.');
              return;
            }
            if (err.code !== 'auth/popup-closed-by-user') {
              console.error('Redirect auth error:', err);
              setAuthError(err.message);
            }
          }
        };
        // Small delay to let IndexedDB initialize on iOS
        setTimeout(() => handleRedirectResult(), 500);
      }, []);

      // Firebase Auth State Listener - catches sign-in even if getRedirectResult fails
      // This is the recommended approach for signInWithRedirect
      React.useEffect(() => {
        const unsubscribe = firebaseAuth.onAuthStateChanged(async (firebaseUser) => {
          // Only process if we have a Firebase user but NOT already authenticated in our app
          if (firebaseUser && !isAuthenticated && !authToken) {
            console.log('ðŸ“± Firebase onAuthStateChanged: User detected, completing login...');
            try {
              await handleFirebaseAuth(firebaseUser);
            } catch (err) {
              console.error('ðŸ“± onAuthStateChanged auth error:', err);
            }
          }
        });

        // Cleanup listener on unmount
        return () => unsubscribe();
      }, [isAuthenticated, authToken]);

      // Google Sign-In
      // NOTE: signInWithRedirect does NOT work on Safari 16.1+ due to third-party storage blocking
      // Use signInWithPopup for all browsers - it works better on modern iOS Safari
      const handleGoogleSignIn = async () => {
        setAuthError('');
        try {
          const provider = new firebase.auth.GoogleAuthProvider();
          // Always use popup - redirect is broken on Safari/iOS due to cross-origin storage blocking
          // See: https://firebase.google.com/docs/auth/web/redirect-best-practices
          const result = await firebaseAuth.signInWithPopup(provider);
          await handleFirebaseAuth(result.user);
        } catch (err) {
          console.error('ðŸ“± Google Sign-In error:', err.code, err.message);
          if (err.code === 'auth/popup-blocked') {
            setAuthError('Popup was blocked. Please allow popups for this site and try again.');
          } else if (err.code === 'auth/popup-closed-by-user') {
            // User closed popup, not an error to show
          } else if (err.code === 'auth/cancelled-popup-request') {
            // Multiple popup requests, ignore
          } else {
            setAuthError(err.message);
          }
        }
      };

      // Apple Sign-In
      const handleAppleSignIn = async () => {
        setAuthError('');
        try {
          const provider = new firebase.auth.OAuthProvider('apple.com');
          provider.addScope('email');
          provider.addScope('name');
          // Always use popup - redirect is broken on Safari/iOS
          const result = await firebaseAuth.signInWithPopup(provider);
          await handleFirebaseAuth(result.user);
        } catch (err) {
          console.error('ðŸ“± Apple Sign-In error:', err.code, err.message);
          if (err.code === 'auth/popup-blocked') {
            setAuthError('Popup was blocked. Please allow popups for this site and try again.');
          } else if (err.code === 'auth/popup-closed-by-user') {
            // User closed popup, not an error to show
          } else if (err.code === 'auth/cancelled-popup-request') {
            // Multiple popup requests, ignore
          } else {
            setAuthError(err.message);
          }
        }
      };

      // Password Reset
      const handlePasswordReset = async (e) => {
        e?.preventDefault();
        setAuthError('');

        if (!authForm.username) {
          setAuthError('Please enter your email address');
          return;
        }

        try {
          await firebaseAuth.sendPasswordResetEmail(authForm.username);
          setAuthError('');
          setAuthMode('resetSent');
        } catch (err) {
          if (err.code === 'auth/user-not-found') {
            setAuthError('No account found with this email');
          } else {
            setAuthError(err.message);
          }
        }
      };

      const fetchUserQuota = async () => {
        if (!authToken) return;

        try {
          const response = await fetch(`${API_URL}/api/user/quota`, {
            headers: {
              'Authorization': `Bearer ${authToken}`
            }
          });

          if (response.ok) {
            const data = await response.json();
            setUserQuota(data);
          }
        } catch (err) {
          console.error('Error fetching quota:', err);
        }
      };

      const fetchAllUsers = async () => {
        if (!authToken || !currentUser || currentUser.role !== 'admin') {
          setAdminUsers([]);
          return;
        }

        try {
          const response = await fetch(`${API_URL}/api/admin/users`, {
            headers: {
              'Authorization': `Bearer ${authToken}`
            }
          });

          if (response.ok) {
            const users = await response.json();
            setAdminUsers(users || []);
          } else {
            console.error('Failed to fetch users:', response.status);
            setAdminUsers([]);
          }
        } catch (err) {
          console.error('Error fetching users:', err);
          setAdminUsers([]);
        }
      };

      const updateUserQuota = async (userId, newQuota) => {
        if (!authToken || !currentUser || currentUser.role !== 'admin') return;

        try {
          const response = await fetch(`${API_URL}/api/admin/users/${userId}/quota`, {
            method: 'PATCH',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${authToken}`
            },
            body: JSON.stringify({ storyQuota: newQuota })
          });

          if (response.ok) {
            // Refresh user list
            await fetchAllUsers();
            return true;
          }
          return false;
        } catch (err) {
          console.error('Error updating user quota:', err);
          return false;
        }
      };

      // Delete user and all their data (admin only)
      const deleteUser = async (userId, username) => {
        if (!authToken || !currentUser || currentUser.role !== 'admin') return;

        try {
          const response = await fetch(`${API_URL}/api/admin/users/${userId}`, {
            method: 'DELETE',
            headers: {
              'Authorization': `Bearer ${authToken}`
            }
          });

          if (response.ok) {
            const result = await response.json();
            alert(language === 'de'
              ? `Benutzer ${username} und alle Daten wurden gelÃ¶scht.\n\nGelÃ¶scht: ${result.deletedCounts.stories} Geschichten, ${result.deletedCounts.characters} Charaktere, ${result.deletedCounts.storyJobs} Jobs`
              : language === 'fr'
              ? `Utilisateur ${username} et toutes les donnÃ©es ont Ã©tÃ© supprimÃ©s.\n\nSupprimÃ©s: ${result.deletedCounts.stories} histoires, ${result.deletedCounts.characters} personnages, ${result.deletedCounts.storyJobs} jobs`
              : `User ${username} and all data deleted successfully.\n\nDeleted: ${result.deletedCounts.stories} stories, ${result.deletedCounts.characters} characters, ${result.deletedCounts.storyJobs} jobs`);
            await fetchAllUsers();
            return true;
          } else {
            const error = await response.json();
            alert(language === 'de'
              ? `Fehler beim LÃ¶schen: ${error.error}`
              : language === 'fr'
              ? `Erreur lors de la suppression: ${error.error}`
              : `Error deleting user: ${error.error}`);
            return false;
          }
        } catch (err) {
          console.error('Error deleting user:', err);
          alert(language === 'de'
            ? 'Fehler beim LÃ¶schen des Benutzers'
            : language === 'fr'
            ? 'Erreur lors de la suppression de l\'utilisateur'
            : 'Error deleting user');
          return false;
        }
      };

      // Fetch failed orders (admin only)
      const fetchFailedOrders = async () => {
        if (!authToken || !currentUser || currentUser.role !== 'admin') return;

        setIsLoadingOrders(true);
        try {
          const response = await fetch(`${API_URL}/api/admin/orders`, {
            headers: { 'Authorization': `Bearer ${authToken}` }
          });

          if (response.ok) {
            const data = await response.json();
            // Filter only failed orders (paid but no print order ID)
            const failed = data.orders.filter(o => o.has_issue);
            setFailedOrders(failed);
            console.log(`ðŸ“¦ [ADMIN] Loaded ${failed.length} failed orders`);
          } else {
            console.error('Failed to fetch orders');
            setFailedOrders([]);
          }
        } catch (err) {
          console.error('Error fetching orders:', err);
          setFailedOrders([]);
        } finally {
          setIsLoadingOrders(false);
        }
      };

      // Retry sending order to print provider (admin only)
      const retryPrintOrder = async (orderId) => {
        if (!authToken || !currentUser || currentUser.role !== 'admin') return;

        setRetryingOrderId(orderId);
        try {
          const response = await fetch(`${API_URL}/api/admin/orders/${orderId}/retry-print-order`, {
            method: 'POST',
            headers: { 'Authorization': `Bearer ${authToken}` }
          });

          const result = await response.json();

          if (response.ok) {
            alert(language === 'de'
              ? `Druckauftrag erfolgreich erstellt!\nPrint Order ID: ${result.printOrderId}`
              : language === 'fr'
              ? `Commande d'impression crÃ©Ã©e avec succÃ¨s!\nPrint Order ID: ${result.printOrderId}`
              : `Print order created successfully!\nPrint Order ID: ${result.printOrderId}`);
            // Refresh failed orders list
            await fetchFailedOrders();
          } else {
            alert(language === 'de'
              ? `Fehler: ${result.error}\n${result.details || ''}`
              : language === 'fr'
              ? `Erreur: ${result.error}\n${result.details || ''}`
              : `Error: ${result.error}\n${result.details || ''}`);
          }
        } catch (err) {
          console.error('Error retrying print order:', err);
          alert(language === 'de'
            ? 'Fehler beim Senden an Druckdienstleister'
            : language === 'fr'
            ? 'Erreur lors de l\'envoi au fournisseur d\'impression'
            : 'Error sending to print provider');
        } finally {
          setRetryingOrderId(null);
        }
      };

      // Orphaned Data Management Functions
      const checkOrphanedData = async () => {
        if (!authToken || !currentUser || currentUser.role !== 'admin') return;

        setIsCheckingOrphaned(true);
        try {
          const response = await fetch(`${API_URL}/api/admin/cleanup-orphaned-data`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${authToken}`
            },
            body: JSON.stringify({ action: 'check' })
          });

          if (response.ok) {
            const data = await response.json();
            setOrphanedData(data.found);
          } else {
            console.error('Failed to check orphaned data');
            setOrphanedData(null);
          }
        } catch (err) {
          console.error('Error checking orphaned data:', err);
          setOrphanedData(null);
        } finally {
          setIsCheckingOrphaned(false);
        }
      };

      const deleteOrphanedData = async () => {
        if (!authToken || !currentUser || currentUser.role !== 'admin') return;

        const confirmMsg = language === 'de'
          ? 'MÃ¶chten Sie wirklich alle verwaisten Charaktere und Geschichten lÃ¶schen?'
          : language === 'fr'
          ? 'Voulez-vous vraiment supprimer tous les personnages et histoires orphelins ?'
          : 'Are you sure you want to delete all orphaned characters and stories?';

        if (!confirm(confirmMsg)) return;

        setIsCheckingOrphaned(true);
        try {
          const response = await fetch(`${API_URL}/api/admin/cleanup-orphaned-data`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${authToken}`
            },
            body: JSON.stringify({ action: 'delete' })
          });

          if (response.ok) {
            const data = await response.json();
            alert(language === 'de'
              ? `GelÃ¶scht: ${data.deleted.characters} Charaktere, ${data.deleted.stories} Geschichten`
              : language === 'fr'
              ? `SupprimÃ©: ${data.deleted.characters} personnages, ${data.deleted.stories} histoires`
              : `Deleted: ${data.deleted.characters} characters, ${data.deleted.stories} stories`);
            // Re-check after deletion
            await checkOrphanedData();
          } else {
            alert('Failed to delete orphaned data');
          }
        } catch (err) {
          console.error('Error deleting orphaned data:', err);
          alert('Error deleting orphaned data');
        } finally {
          setIsCheckingOrphaned(false);
        }
      };

      // Orphaned story_jobs functions
      const checkOrphanedJobs = async () => {
        if (!authToken || !currentUser || currentUser.role !== 'admin') return;

        setIsCheckingOrphanedJobs(true);
        try {
          const response = await fetch(`${API_URL}/api/admin/cleanup-orphaned-jobs`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${authToken}`
            },
            body: JSON.stringify({ action: 'check' })
          });

          if (response.ok) {
            const data = await response.json();
            setOrphanedJobs(data);
          } else {
            console.error('Failed to check orphaned jobs');
            setOrphanedJobs(null);
          }
        } catch (err) {
          console.error('Error checking orphaned jobs:', err);
          setOrphanedJobs(null);
        } finally {
          setIsCheckingOrphanedJobs(false);
        }
      };

      const deleteOrphanedJobs = async () => {
        if (!authToken || !currentUser || currentUser.role !== 'admin') return;

        const confirmMsg = language === 'de'
          ? 'MÃ¶chten Sie wirklich alle verwaisten Jobs lÃ¶schen?'
          : language === 'fr'
          ? 'Voulez-vous vraiment supprimer tous les jobs orphelins ?'
          : 'Are you sure you want to delete all orphaned jobs?';

        if (!confirm(confirmMsg)) return;

        setIsCheckingOrphanedJobs(true);
        try {
          const response = await fetch(`${API_URL}/api/admin/cleanup-orphaned-jobs`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${authToken}`
            },
            body: JSON.stringify({ action: 'delete' })
          });

          if (response.ok) {
            const data = await response.json();
            alert(language === 'de'
              ? `${data.deleted} verwaiste Jobs gelÃ¶scht`
              : language === 'fr'
              ? `${data.deleted} jobs orphelins supprimÃ©s`
              : `Deleted ${data.deleted} orphaned jobs`);
            await checkOrphanedJobs();
          } else {
            alert('Failed to delete orphaned jobs');
          }
        } catch (err) {
          console.error('Error deleting orphaned jobs:', err);
          alert('Error deleting orphaned jobs');
        } finally {
          setIsCheckingOrphanedJobs(false);
        }
      };

      // Print Products Management Functions
      const fetchPrintProducts = async () => {
        if (!authToken || !currentUser || currentUser.role !== 'admin') return;

        try {
          const response = await fetch(`${API_URL}/api/admin/print-products`, {
            headers: { 'Authorization': `Bearer ${authToken}` }
          });

          if (response.ok) {
            const data = await response.json();
            setPrintProducts(data.products || []);
          }
        } catch (err) {
          console.error('Error fetching print products:', err);
        }
      };

      const fetchProviderApiProducts = async () => {
        if (!authToken || !currentUser || currentUser.role !== 'admin') return;

        const confirmMsg = language === 'de'
          ? 'MÃ¶chten Sie verfÃ¼gbare Produkte vom Druckdienstleister abrufen? Dies kann einen Moment dauern.'
          : language === 'fr'
          ? 'Voulez-vous rÃ©cupÃ©rer les produits disponibles depuis le fournisseur d\'impression ? Cela peut prendre un moment.'
          : 'Fetch available products from print provider API? This may take a moment.';

        if (!confirm(confirmMsg)) return;

        try {
          setGenerationProgress({ current: 0, total: 1, message: 'Fetching products from print provider...' });

          const response = await fetch(`${API_URL}/api/admin/print-provider/fetch-products`, {
            headers: { 'Authorization': `Bearer ${authToken}` }
          });

          setGenerationProgress({ current: 0, total: 0, message: '' });

          if (response.ok) {
            const data = await response.json();

            if (data.products && data.products.length > 0) {
              // Show products in a selection dialog
              const msg = language === 'de'
                ? `${data.count} Fotobuch-Produkte gefunden. MÃ¶chten Sie diese zur Datenbank hinzufÃ¼gen?`
                : language === 'fr'
                ? `${data.count} produits de livre photo trouvÃ©s. Voulez-vous les ajouter Ã  la base de donnÃ©es ?`
                : `Found ${data.count} photobook products. Would you like to add them to the database?`;

              if (confirm(msg)) {
                // Add products to database
                let added = 0;
                for (const product of data.products) {
                  try {
                    const addResponse = await fetch(`${API_URL}/api/admin/print-products`, {
                      method: 'POST',
                      headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`
                      },
                      body: JSON.stringify({
                        product_uid: product.productUid,
                        product_name: product.name || product.productUid,
                        description: product.description || 'Imported from print provider API',
                        size: product.size || '',
                        cover_type: product.coverType || '',
                        min_pages: product.minPages || 24,
                        max_pages: product.maxPages || 24,
                        available_page_counts: JSON.stringify(product.availablePageCounts || [24]),
                        is_active: false // Set inactive by default for review
                      })
                    });

                    if (addResponse.ok) added++;
                  } catch (err) {
                    console.error('Error adding product:', err);
                  }
                }

                await fetchPrintProducts();
                const successMsg = language === 'de'
                  ? `${added} Produkte erfolgreich hinzugefÃ¼gt!`
                  : language === 'fr'
                  ? `${added} produits ajoutÃ©s avec succÃ¨s !`
                  : `Successfully added ${added} products!`;
                alert(successMsg);
              }
            } else {
              const noProductsMsg = language === 'de'
                ? 'Keine Fotobuch-Produkte gefunden'
                : language === 'fr'
                ? 'Aucun produit de livre photo trouvÃ©'
                : 'No photobook products found';
              alert(noProductsMsg);
            }
          } else {
            const error = await response.json();
            alert(`Error: ${error.error || 'Failed to fetch from print provider API'}`);
          }
        } catch (err) {
          setGenerationProgress({ current: 0, total: 0, message: '' });
          console.error('Error fetching from print provider API:', err);
          alert('Error fetching from print provider API. Please check your API key.');
        }
      };

      const savePrintProduct = async () => {
        if (!authToken || !currentUser || currentUser.role !== 'admin') return;

        try {
          const url = editingProduct
            ? `${API_URL}/api/admin/print-products/${editingProduct.id}`
            : `${API_URL}/api/admin/print-products`;

          const response = await fetch(url, {
            method: editingProduct ? 'PUT' : 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${authToken}`
            },
            body: JSON.stringify(productForm)
          });

          if (response.ok) {
            await fetchPrintProducts();
            setShowProductForm(false);
            setEditingProduct(null);
            setProductForm({
              product_uid: '',
              product_name: '',
              description: '',
              size: '',
              cover_type: '',
              min_pages: 24,
              max_pages: 24,
              available_page_counts: '[24]',
              is_active: true
            });
            alert('Product saved successfully!');
          } else {
            const error = await response.json();
            alert(`Failed to save product: ${error.error || 'Unknown error'}`);
          }
        } catch (err) {
          console.error('Error saving product:', err);
          alert('Error saving product');
        }
      };

      const deletePrintProduct = async (productId) => {
        if (!authToken || !currentUser || currentUser.role !== 'admin') return;
        if (!confirm('Delete this product?')) return;

        try {
          const response = await fetch(`${API_URL}/api/admin/print-products/${productId}`, {
            method: 'DELETE',
            headers: { 'Authorization': `Bearer ${authToken}` }
          });

          if (response.ok) {
            await fetchPrintProducts();
            alert('Product deleted successfully!');
          } else {
            alert('Failed to delete product');
          }
        } catch (err) {
          console.error('Error deleting product:', err);
          alert('Error deleting product');
        }
      };

      const toggleProductActive = async (productId, currentStatus) => {
        if (!authToken || !currentUser || currentUser.role !== 'admin') return;

        try {
          const response = await fetch(`${API_URL}/api/admin/print-products/${productId}`, {
            method: 'PUT',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${authToken}`
            },
            body: JSON.stringify({ is_active: !currentStatus })
          });

          if (response.ok) {
            await fetchPrintProducts();
          }
        } catch (err) {
          console.error('Error toggling product status:', err);
        }
      };

      const makeApiCall = async (prompt, maxTokens = 4096) => {
        if (!authToken) {
          throw new Error('Authentication required');
        }

        const response = await fetchWithTimeout(`${API_URL}/api/claude`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${authToken}`
          },
          body: JSON.stringify({
            prompt: prompt,
            max_tokens: maxTokens
          })
        }, 120000); // 120 second timeout for Claude API calls

        if (!response.ok) {
          let errorMessage = 'Unknown error';
          const errorText = await response.text();
          console.error('API Error Response:', errorText);

          try {
            const errorData = JSON.parse(errorText);
            // Handle both error formats: {error: "msg"} and {error: {message: "msg"}}
            if (typeof errorData.error === 'string') {
              errorMessage = errorData.error;
            } else {
              errorMessage = errorData.error?.message || errorData.message || 'Unknown error';
            }
          } catch (parseError) {
            if (errorText.includes('524') || errorText.includes('timeout')) {
              errorMessage = 'Request timeout - try reducing the number of pages or characters';
            } else {
              errorMessage = errorText || 'Server error';
            }
          }
          throw new Error(`API Error: ${errorMessage}`);
        }

        const data = await response.json();

        if (!data.content || data.content.length === 0) {
          throw new Error('No content received from API');
        }

        // Log token usage
        if (data.usage) {
          console.log('ðŸ“Š Token Usage:');
          console.log(`  Input tokens:  ${data.usage.input_tokens.toLocaleString()}`);
          console.log(`  Output tokens: ${data.usage.output_tokens.toLocaleString()}`);
          console.log(`  Total tokens:  ${(data.usage.input_tokens + data.usage.output_tokens).toLocaleString()}`);
          console.log(`  Max requested: ${maxTokens.toLocaleString()}`);

          // Warn if output limit was reached
          if (data.stop_reason === 'max_tokens') {
            console.warn('âš ï¸  WARNING: Output was truncated - max_tokens limit reached!');
            console.warn(`  You requested ${maxTokens.toLocaleString()} tokens but the response was cut off.`);
          }
        }

        const text = data.content
          .filter(block => block.type === 'text')
          .map(block => block.text)
          .join('\n');

        if (!text) {
          throw new Error('Response text is empty');
        }

        return text;
      };

      // Character persistence functions
      const saveCharacters = async (dataToSave) => {
        if (!authToken) return;

        try {
          const response = await fetch(`${API_URL}/api/characters`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${authToken}`
            },
            body: JSON.stringify({
              characters: dataToSave.characters,
              relationships: dataToSave.relationships,
              relationshipTexts: dataToSave.relationshipTexts,
              customRelationships: dataToSave.customRelationships,
              customStrengths: dataToSave.customStrengths,
              customWeaknesses: dataToSave.customWeaknesses,
              customFears: dataToSave.customFears
            })
          });

          if (!response.ok) {
            console.error('Failed to save characters');
          }
        } catch (err) {
          console.error('Error saving characters:', err);
        }
      };

      // Auto-select main characters based on age
      const autoSelectMainCharacters = (charactersList) => {
        if (charactersList.length === 0) return;

        // Find characters aged 1-10
        const youngCharacters = charactersList.filter(char => {
          const age = parseInt(char.age);
          return age >= 1 && age <= 10;
        });

        if (youngCharacters.length > 0) {
          // Select all characters aged 1-10 as main characters
          const mainCharIds = youngCharacters.map(char => char.id);
          setMainCharacters(mainCharIds);
          console.log(`âœ¨ Auto-selected ${youngCharacters.length} main character(s) aged 1-10`);
        } else {
          // No characters aged 1-10, select the youngest one
          const youngest = charactersList.reduce((min, char) => {
            const age = parseInt(char.age);
            const minAge = parseInt(min.age);
            return age < minAge ? char : min;
          });
          setMainCharacters([youngest.id]);
          console.log(`âœ¨ Auto-selected youngest character as main: ${youngest.name} (age ${youngest.age})`);
        }
      };

      const loadCharacters = async () => {
        if (!authToken) return;

        // Set loading flag to prevent auto-save from overwriting data during load
        setIsLoadingCharacters(true);
        console.log('ðŸ‘¥ [LOAD] Starting character load (auto-save disabled)...');

        try {
          const response = await fetch(`${API_URL}/api/characters`, {
            headers: {
              'Authorization': `Bearer ${authToken}`
            }
          });

          if (response.ok) {
            const data = await response.json();
            console.log('ðŸ‘¥ Characters API response:', data);
            console.log('ðŸ‘¥ [LOAD] Relationships from server:', data.relationships);

            // Normalize characters - ensure all fields exist with defaults
            const normalizeCharacter = (char) => ({
              ...char,
              specialDetails: char.specialDetails || '',
              strengths: char.strengths || [],
              weaknesses: char.weaknesses || [],
              fears: char.fears || [],
              photoUrl: char.photoUrl || null,
              thumbnailUrl: char.thumbnailUrl || null
            });

            let loadedCharacters = [];

            // Handle both old format (array) and new format (object with characters and relationships)
            if (Array.isArray(data)) {
              console.log('ðŸ‘¥ Setting characters (array format):', data.length, data);
              loadedCharacters = data.map(normalizeCharacter);
              setCharacters(loadedCharacters);
            } else if (data && typeof data === 'object') {
              console.log('ðŸ‘¥ Setting characters (object format):', data.characters?.length, data.characters);
              console.log('ðŸ‘¥ First character details:', data.characters?.[0]);

              // Ensure data.characters is an array before mapping
              const charactersArray = Array.isArray(data.characters) ? data.characters : [];
              loadedCharacters = charactersArray.map(normalizeCharacter);
              setCharacters(loadedCharacters);

              if (data.relationships && typeof data.relationships === 'object') {
                console.log('ðŸ‘¥ [LOAD] Setting relationships:', Object.keys(data.relationships).length, 'relationships');
                setRelationships(data.relationships);
              }
              if (data.relationshipTexts && typeof data.relationshipTexts === 'object' && !Array.isArray(data.relationshipTexts)) {
                setRelationshipTexts(data.relationshipTexts);
              }
              if (Array.isArray(data.customRelationships)) {
                setCustomRelationships(data.customRelationships);
              }
              if (Array.isArray(data.customStrengths)) {
                setCustomStrengths(data.customStrengths);
              }
              if (Array.isArray(data.customWeaknesses)) {
                setCustomWeaknesses(data.customWeaknesses);
              }
              if (Array.isArray(data.customFears)) {
                setCustomFears(data.customFears);
              }
            } else {
              console.warn('ðŸ‘¥ Unexpected data format, initializing with empty array');
              setCharacters([]);
            }

            // Auto-select main characters based on age (only if we have characters)
            if (Array.isArray(loadedCharacters) && loadedCharacters.length > 0) {
              autoSelectMainCharacters(loadedCharacters);
            }
          }
        } catch (err) {
          console.error('Error loading characters:', err);
        } finally {
          // Re-enable auto-save after load completes
          // Use a small delay to ensure all state updates have settled
          setTimeout(() => {
            setIsLoadingCharacters(false);
            console.log('ðŸ‘¥ [LOAD] Character load complete (auto-save re-enabled)');
          }, 500);
        }
      };

      // Helper function for backward compatibility with cover images
      // Old stories have cover images as strings, new ones have objects with imageData, qualityScore, qualityReasoning
      const getCoverImageData = (img) => typeof img === 'string' ? img : img?.imageData;

      // Story draft persistence functions - saves step 1 & 4 settings before generation
      const [isLoadingDraft, setIsLoadingDraft] = useState(false);

      const saveStoryDraft = async (draftData) => {
        if (!authToken) return;

        try {
          await fetch(`${API_URL}/api/story-draft`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${authToken}`
            },
            body: JSON.stringify(draftData)
          });
          console.log('ðŸ“ [DRAFT] Story draft saved');
        } catch (err) {
          console.error('Error saving story draft:', err);
        }
      };

      const loadStoryDraft = async () => {
        if (!authToken) return;

        setIsLoadingDraft(true);
        try {
          const response = await fetch(`${API_URL}/api/story-draft`, {
            headers: {
              'Authorization': `Bearer ${authToken}`
            }
          });

          if (response.ok) {
            const data = await response.json();
            console.log('ðŸ“ [DRAFT] Loaded story draft:', data);

            // Only restore if there's actual data (not just defaults)
            if (data.storyType) setStoryType(data.storyType);
            if (data.artStyle) setArtStyle(data.artStyle);
            if (data.storyDetails) setStoryDetails(data.storyDetails);
            if (data.dedication) setDedication(data.dedication);
            if (data.pages) setPages(data.pages);
            if (data.languageLevel) setLanguageLevel(data.languageLevel);
            if (data.mainCharacters && data.mainCharacters.length > 0) {
              setMainCharacters(data.mainCharacters);
            }
          }
        } catch (err) {
          console.error('Error loading story draft:', err);
        } finally {
          setTimeout(() => {
            setIsLoadingDraft(false);
            console.log('ðŸ“ [DRAFT] Draft load complete');
          }, 300);
        }
      };

      const clearStoryDraft = async () => {
        if (!authToken) return;

        try {
          await fetch(`${API_URL}/api/story-draft`, {
            method: 'DELETE',
            headers: {
              'Authorization': `Bearer ${authToken}`
            }
          });
          console.log('ðŸ—‘ï¸ [DRAFT] Story draft cleared');
        } catch (err) {
          console.error('Error clearing story draft:', err);
        }
      };

      // Story persistence functions
      const saveStory = async (storyData) => {
        if (!authToken) return;

        try {
          const response = await fetch(`${API_URL}/api/stories`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${authToken}`
            },
            body: JSON.stringify({ story: storyData })
          });

          // Handle 413 Payload Too Large error
          if (response.status === 413) {
            throw new Error('Story is too large to save. Try reducing the number of pages or image quality.');
          }

          // Check if response is JSON or HTML error page
          const contentType = response.headers.get('content-type');
          if (!contentType || !contentType.includes('application/json')) {
            const text = await response.text();
            console.error('Non-JSON response:', text.substring(0, 200));
            throw new Error(`Server error (${response.status}): The story may be too large. Try reducing pages.`);
          }

          const result = await response.json();

          if (!response.ok) {
            if (response.status === 403 && result.error === 'Story quota exceeded') {
              // Refresh quota to show updated numbers
              await fetchUserQuota();
              throw new Error(`Story quota exceeded! You have used all ${result.quota} of your free stories. Contact admin for more credits.`);
            }
            throw new Error(result.error || 'Failed to save story');
          }

          // Refresh quota after successful story save
          await fetchUserQuota();
          return result.id;
        } catch (err) {
          console.error('Error saving story:', err);
          throw err; // Re-throw so caller can handle it
        }
      };

      // Helper function to fetch with progress tracking
      const fetchWithProgress = (url, options = {}) => {
        return new Promise((resolve, reject) => {
          const xhr = new XMLHttpRequest();
          xhr.open(options.method || 'GET', url);

          // Set headers
          if (options.headers) {
            Object.keys(options.headers).forEach(key => {
              xhr.setRequestHeader(key, options.headers[key]);
            });
          }

          // Track download progress
          xhr.onprogress = (event) => {
            if (event.lengthComputable) {
              const percentComplete = (event.loaded / event.total) * 100;
              setLoadingProgress(Math.round(percentComplete));
              setLoadingBytes(event.loaded);
              setLoadingTotalBytes(event.total);
            }
          };

          xhr.onload = () => {
            if (xhr.status >= 200 && xhr.status < 300) {
              try {
                const data = JSON.parse(xhr.responseText);
                resolve(data);
              } catch (err) {
                reject(new Error('Failed to parse JSON response'));
              }
            } else {
              reject(new Error(`HTTP ${xhr.status}: ${xhr.statusText}`));
            }
          };

          xhr.onerror = () => reject(new Error('Network error'));
          xhr.ontimeout = () => reject(new Error('Request timeout'));

          xhr.send(options.body);
        });
      };

      const loadStories = async () => {
        console.log('ðŸ“š loadStories() called', { hasAuthToken: !!authToken, apiUrl: API_URL });

        if (!authToken) {
          console.warn('âš ï¸  No auth token - cannot load stories');
          return [];
        }

        try {
          console.log('ðŸ“š Fetching stories from:', `${API_URL}/api/stories`);
          const response = await fetch(`${API_URL}/api/stories`, {
            headers: {
              'Authorization': `Bearer ${authToken}`
            }
          });

          console.log('ðŸ“š Stories response:', { ok: response.ok, status: response.status, statusText: response.statusText });

          if (response.ok) {
            console.log('ðŸ“š About to parse JSON...');
            try {
              const stories = await response.json();
              console.log('ðŸ“š JSON parsed successfully');
              console.log('ðŸ“š Stories loaded successfully:', { count: stories.length, stories: stories });
              console.log('ðŸ“š Returning stories:', stories);
              return stories;
            } catch (jsonErr) {
              console.error('âŒ Failed to parse JSON:', jsonErr);
              console.error('This usually means the server returned invalid JSON or the connection failed');
              return [];
            }
          } else {
            const errorText = await response.text();
            console.error('âŒ Stories API error:', { status: response.status, error: errorText });
            return [];
          }
        } catch (err) {
          console.error('âŒ Error loading stories:', err);
          console.error('Error details:', { message: err.message, stack: err.stack });
          return [];
        }
      };

      const generateOutline = async () => {
        // Backend now handles API key - no need to check locally
        // if (!apiKey) {
        //   setShowApiKeyPrompt(true);
        //   return;
        // }

        setIsGeneratingOutline(true);

        try {
          // Get list of non-main characters (secondary characters)
          const secondaryCharacters = characters.filter(c => !mainCharacters.includes(c.id));

          // Character manifest removed - will be generated during scene generation phase

          // If user edited the prompt in preview, use it directly
          // Otherwise, build the full outline prompt with structure
          let outlinePrompt;
          if (editablePrompt) {
            // User edited the preview - use their edited version directly
            outlinePrompt = editablePrompt;
          } else {
            // No edits - build the full structured prompt
            const basePrompt = buildPrompt();
            outlinePrompt = `# Role and Context

You are an expert children's book writer with deep understanding of age-appropriate storytelling, narrative structure, and visual storytelling for illustrated books. Your expertise includes:

- Creating engaging, age-appropriate narratives that captivate young readers
- Crafting clear story arcs with proper setup, conflict, and resolution
- Writing vivid scene descriptions that translate beautifully to illustrations
- Balancing text and visual elements for maximum impact
- Understanding pacing and page turns in illustrated books
- Creating memorable characters and meaningful moments

Your task is to create a compelling, well-structured story outline that will guide both the narrative text and visual illustrations.

${basePrompt}

# Part 1: Story Title

Create an engaging, age-appropriate title for this story. The title should:
- Capture the essence of the story
- Be appealing to the target age group
- Be memorable and creative
- Reflect the main theme or adventure

Format:
Title: [Your creative title here]

# Part 2: Story Outline

Create a detailed outline for this ${pages}-page story. Include:
- Brief summary of each page (what happens on that page)
- Key events and character moments
- Story arc and progression (clear beginning, middle, and end)
- How the story builds tension and resolves satisfyingly

For EACH of the ${pages} story pages, provide a SHORT SCENE DESCRIPTION (1-2 sentences) that describes the visual scene - what the characters are doing, where they are, and the setting. This will be used for illustration purposes.

# Part 3: Cover Scene Descriptions

In addition to the ${pages} story pages, provide scene descriptions for these 3 cover elements:

**Title Page Scene**: A captivating cover illustration that features the main characters and sets the tone for the story. This should be visually striking and focus on the protagonist(s) in a way that draws readers in.

**Initial Page Scene**: A dedication/introduction page illustration that creates a warm, inviting entry into the story world. This sets the mood and welcomes readers.

**Back Cover Scene**: A satisfying concluding illustration that provides closure and leaves readers with a positive feeling. This should feel like a natural ending to the visual journey.

# Format Your Response

Title: [Story title]

Page 1: [Summary]
Scene: [Short visual description]

Page 2: [Summary]
Scene: [Short visual description]

...and so on for all ${pages} pages.

Title Page: [Summary of title page concept]
Scene: [Visual description focusing on main characters]

Initial Page: [Summary of dedication/intro concept]
Scene: [Visual description for welcoming scene]

Back Cover: [Summary of back cover concept]
Scene: [Visual description for concluding scene]

Be specific and creative. Each scene description should paint a clear picture for the illustrator.`;
          }

          // Store the prompt for debugging/display
          setGeneratedPrompt(outlinePrompt);

          const response = await makeApiCall(outlinePrompt, 8192);  // Max for Sonnet 4.5

          // Store outline prompt and API call for debugging
          setStoryOutlinePrompt(outlinePrompt);
          setStoryOutlineApiCall({
            type: 'text',
            model: 'claude-sonnet-4-5-20250929',
            prompt: outlinePrompt,
            maxTokens: 8192,
            timestamp: new Date().toISOString()
          });

          // Parse the response to extract title, cover scenes, and page scenes
          let outline = response;

          // Extract title
          const titleMatch = response.match(/Title:\s*(.+)/i);
          if (titleMatch) {
            const extractedTitle = titleMatch[1].trim();
            setStoryTitle(extractedTitle);
            console.log('Extracted title:', extractedTitle);
          }

          setStoryOutline(outline);
          setEditableOutline(outline);

          // Parse outline to extract scene descriptions
          if (currentUser?.role === 'admin') {
            console.log('ðŸ“‹ Outline generated successfully');
            console.log('Full outline (first 1000 chars):\n', outline.substring(0, 1000));
            console.log('\n=== END OUTLINE PREVIEW ===\n');
          }

          const sceneDescMap = {};
          const coverScenes = {
            titlePage: '',
            initialPage: '',
            backCover: ''
          };

          const lines = outline.split('\n');
          let currentPage = null;
          let currentCoverType = null;
          let collectingScene = false;
          let sceneBuffer = '';

          for (let i = 0; i < lines.length; i++) {
            const line = lines[i].trim();

            // Look for "Page X:" pattern (story pages) - handles **Page X:** too
            const pageMatch = line.match(/^(?:\*\*)?Page\s+(\d+)(?:\*\*)?[\s:]/i);
            if (pageMatch) {
              // Save any buffered scene before switching context
              if (collectingScene && sceneBuffer && (currentPage !== null || currentCoverType)) {
                if (currentPage !== null) {
                  sceneDescMap[currentPage] = sceneBuffer.trim();
                  console.log(`Stored scene for page ${currentPage}:`, sceneBuffer.substring(0, 50) + '...');
                } else if (currentCoverType) {
                  coverScenes[currentCoverType] = sceneBuffer.trim();
                  console.log(`Stored ${currentCoverType} scene:`, sceneBuffer.substring(0, 50) + '...');
                }
              }

              currentPage = parseInt(pageMatch[1]);
              currentCoverType = null;
              collectingScene = false;
              sceneBuffer = '';
            }

            // Look for cover page patterns - more flexible matching
            // Matches: "Title Page:", "**Title Page:**", "Title Page Scene:", etc.
            const titlePageMatch = line.match(/(?:\*\*)?Title\s+Page(?:\s+Scene)?(?:\*\*)?:\s*(.+)/i);
            if (titlePageMatch) {
              // Save any buffered scene before switching context
              if (collectingScene && sceneBuffer && (currentPage !== null || currentCoverType)) {
                if (currentPage !== null) {
                  sceneDescMap[currentPage] = sceneBuffer.trim();
                } else if (currentCoverType) {
                  coverScenes[currentCoverType] = sceneBuffer.trim();
                }
              }

              currentCoverType = 'titlePage';
              currentPage = null;
              collectingScene = true;
              sceneBuffer = titlePageMatch[1].trim();
              console.log('Found Title Page scene:', sceneBuffer.substring(0, 50) + '...');
            }

            // Match both "Initial Page" and legacy "Page 0" for backward compatibility
            const initialPageMatch = line.match(/(?:\*\*)?(?:Initial\s+Page|Page\s+0)(?:\s+Scene)?(?:\*\*)?:\s*(.+)/i);
            if (initialPageMatch) {
              // Save any buffered scene before switching context
              if (collectingScene && sceneBuffer && (currentPage !== null || currentCoverType)) {
                if (currentPage !== null) {
                  sceneDescMap[currentPage] = sceneBuffer.trim();
                } else if (currentCoverType) {
                  coverScenes[currentCoverType] = sceneBuffer.trim();
                }
              }

              currentCoverType = 'initialPage';
              currentPage = null;
              collectingScene = true;
              sceneBuffer = initialPageMatch[1].trim();
              console.log('Found Initial Page scene:', sceneBuffer.substring(0, 50) + '...');
            }

            const backCoverMatch = line.match(/(?:\*\*)?Back\s+Cover(?:\s+Scene)?(?:\*\*)?:\s*(.+)/i);
            if (backCoverMatch) {
              // Save any buffered scene before switching context
              if (collectingScene && sceneBuffer && (currentPage !== null || currentCoverType)) {
                if (currentPage !== null) {
                  sceneDescMap[currentPage] = sceneBuffer.trim();
                } else if (currentCoverType) {
                  coverScenes[currentCoverType] = sceneBuffer.trim();
                }
              }

              currentCoverType = 'backCover';
              currentPage = null;
              collectingScene = true;
              sceneBuffer = backCoverMatch[1].trim();
              console.log('Found Back Cover scene:', sceneBuffer.substring(0, 50) + '...');
            }

            // Look for "Scene:" pattern - start collecting scene description (handles **Scene:** too)
            const sceneMatch = line.match(/^(?:\*\*)?Scene(?:\*\*)?:\s*(.+)/i);
            if (sceneMatch) {
              collectingScene = true;
              sceneBuffer = sceneMatch[1].trim();
            } else if (collectingScene && line.length > 0 && !line.match(/^(Page|Title|Back\s+Cover)/i)) {
              // Continue collecting multi-line scene descriptions
              sceneBuffer += ' ' + line;
            } else if (collectingScene && line.length === 0) {
              // Empty line ends scene collection
              if (sceneBuffer && (currentPage !== null || currentCoverType)) {
                if (currentPage !== null) {
                  sceneDescMap[currentPage] = sceneBuffer.trim();
                  console.log(`Stored scene for page ${currentPage}:`, sceneBuffer.substring(0, 50) + '...');
                } else if (currentCoverType) {
                  coverScenes[currentCoverType] = sceneBuffer.trim();
                  console.log(`Stored ${currentCoverType} scene:`, sceneBuffer.substring(0, 50) + '...');
                }
              }
              collectingScene = false;
              sceneBuffer = '';
            }
          }

          // Save any remaining buffered scene at the end
          if (collectingScene && sceneBuffer && (currentPage !== null || currentCoverType)) {
            if (currentPage !== null) {
              sceneDescMap[currentPage] = sceneBuffer.trim();
              console.log(`Stored scene for page ${currentPage}:`, sceneBuffer.substring(0, 50) + '...');
            } else if (currentCoverType) {
              coverScenes[currentCoverType] = sceneBuffer.trim();
              console.log(`Stored ${currentCoverType} scene:`, sceneBuffer.substring(0, 50) + '...');
            }
          }

          setShortSceneDescriptions(sceneDescMap);
          setCoverSceneDescriptions(coverScenes);
          if (currentUser?.role === 'admin') {
            console.log('âœ… Parsing complete -', Object.keys(sceneDescMap).length, 'scenes');
          }

          // Warning if cover scenes are empty
          if (!coverScenes.titlePage || !coverScenes.initialPage || !coverScenes.backCover) {
            console.warn('âš ï¸ WARNING: Some cover scene descriptions are empty!');
            console.warn('Missing:', {
              titlePage: !coverScenes.titlePage,
              initialPage: !coverScenes.initialPage,
              backCover: !coverScenes.backCover
            });
          }
        } catch (error) {
          console.error('Error generating outline:', error);
          alert(`Error generating outline: ${error.message}\n\nPlease check your API key and try again!`);
        } finally {
          setIsGeneratingOutline(false);
        }
      };

      // Character Consistency System Functions

      /**
       * Generate detailed text description from character for consistency
       * This avoids Gemini's child safety blocks by not sending images
       */
      // Generate PHYSICAL description for image generation (no psychological traits)
      const generateCharacterDescription = (character) => {
        const age = parseInt(character.age) || 10;
        const gender = character.gender || 'neutral';

        // Build physical description only - psychological traits are for story text, not images
        let description = `${character.name} is a ${age}-year-old ${gender === 'male' ? 'boy' : gender === 'female' ? 'girl' : 'child'}`;

        // Add physical attributes if available
        if (character.height) {
          description += `, ${character.height} cm tall`;
        }
        if (character.build) {
          description += `, ${character.build} build`;
        }
        if (character.hairColor) {
          description += `, with ${character.hairColor} hair`;
        }
        if (character.otherFeatures) {
          description += `, ${character.otherFeatures}`;
        }
        // Add clothing extracted from avatar image
        if (character.clothing) {
          description += `. Wearing: ${character.clothing}`;
        }

        return description;
      };

      /**
       * Generate cartoon illustration from character photo (for display only)
       * Returns base64 image data
       * NOTE: This cartoon is for DISPLAY purposes only, NOT used as API reference
       * Uses backend /api/gemini endpoint with Railway-stored API keys
       */
      const generateCharacterCartoon = async (character) => {
        if (!character.photoUrl) {
          throw new Error(`Character ${character.name} has no photo to convert`);
        }

        const cartoonPrompt = `CHILDREN'S BOOK CHARACTER ILLUSTRATION - Safe, family-friendly content.

Create a VERTICAL PORTRAIT-ORIENTED colorful cartoon illustration of this child named ${character.name} for a children's storybook. The illustration should be in 3:4 aspect ratio (portrait orientation). Make it friendly and cheerful with bright, vibrant colors and a simple background. Focus on capturing their distinctive features. No text or words on the image.

This is for a children's book illustration - wholesome, innocent, and appropriate for all ages.`;

        // Extract base64 data from photoUrl
        const base64Data = character.photoUrl.replace(/^data:image\/\w+;base64,/, '');
        const mimeType = character.photoUrl.match(/^data:(image\/\w+);base64,/) ?
          character.photoUrl.match(/^data:(image\/\w+);base64,/)[1] : 'image/png';

        // Call backend API endpoint which has the Gemini API key
        const response = await fetchWithTimeout(`${API_URL}/api/gemini`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${localStorage.getItem('auth_token')}`
          },
          body: JSON.stringify({
            model: 'gemini-2.5-flash-image',
            contents: [{
              parts: [
                { text: cartoonPrompt },
                {
                  inlineData: {
                    mimeType: mimeType,
                    data: base64Data
                  }
                }
              ]
            }],
            safetySettings: [
              { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_NONE" },
              { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_NONE" },
              { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_NONE" },
              { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_NONE" }
            ]
          })
        });

        if (!response.ok) {
          const errorData = await response.json();
          throw new Error(errorData.error || `API Error: ${response.status}`);
        }

        const data = await response.json();

        if (!data.candidates || data.candidates.length === 0) {
          throw new Error('No response from Gemini for cartoon generation');
        }

        const candidate = data.candidates[0];
        if (candidate.finishReason && candidate.finishReason !== 'STOP') {
          throw new Error(`Cartoon generation blocked: ${candidate.finishReason}`);
        }

        const responseParts = candidate.content.parts;
        for (const part of responseParts) {
          if (part.inlineData && part.inlineData.data) {
            return `data:image/png;base64,${part.inlineData.data}`;
          }
        }

        throw new Error('No image data in cartoon generation response');
      };

      /**
       * Generate cartoon illustrations for main characters
       */
      const generateMainCharacterCartoons = async () => {
        if (mainCharacters.length === 0) {
          return {};
        }

        setIsGeneratingCartoons(true);
        const cartoons = {};

        try {
          for (const charId of mainCharacters) {
            const character = characters.find(c => c.id === charId);
            if (character && character.photoUrl) {
              console.log(`Generating cartoon for ${character.name}...`);
              const cartoonImage = await generateCharacterCartoon(character);
              cartoons[charId] = cartoonImage;
            }
          }
        } finally {
          setIsGeneratingCartoons(false);
        }

        return cartoons;
      };

      /**
       * Build character consistency guide from manifest
       * Converts structured manifest into readable text guide for prompts
       */
      const buildCharacterConsistencyGuide = (manifest) => {
        if (!manifest || !manifest.characters || manifest.characters.length === 0) {
          return '';
        }

        let guide = '\n\n=== CHARACTER CONSISTENCY GUIDE ===\nUse these EXACT descriptions for secondary characters:\n\n';

        manifest.characters.forEach((char, idx) => {
          const app = char.appearance;
          guide += `[${char.name.toUpperCase()}] (${char.role})\n`;
          if (app.ageDescription) guide += `â€¢ Age: ${app.ageDescription}\n`;
          if (app.hairDescription) guide += `â€¢ Hair: ${app.hairDescription}\n`;
          if (app.faceDescription) guide += `â€¢ Face: ${app.faceDescription}\n`;
          if (app.buildDescription) guide += `â€¢ Build: ${app.buildDescription}\n`;
          if (app.clothingDescription) guide += `â€¢ Clothing: ${app.clothingDescription}\n`;
          if (app.accessoriesDescription) guide += `â€¢ Accessories: ${app.accessoriesDescription}\n`;
          if (app.distinctiveFeatures) guide += `â€¢ Distinctive: ${app.distinctiveFeatures}\n`;
          guide += '\n';
        });

        guide += 'CRITICAL: These characters MUST look IDENTICAL on every page. Do not change their appearance.\n';
        guide += '=== END CHARACTER GUIDE ===\n';

        return guide;
      };

      // Generate storybook (picture book) with combined text + scenes in one call
      const generateStorybookCombined = async () => {
        setIsGenerating(true);
        setIsGeneratingScenes(true);

        try {
          // Build character descriptions
          const characterDescriptions = characters.map(char => {
            const isMain = mainCharacters.includes(char.id) ? ' (MAIN CHARACTER)' : '';
            let desc = `${char.name}${isMain} (${char.gender}, ${char.age} years old)`;
            const details = [];
            if (char.strengths && char.strengths.length > 0) {
              details.push(`Strengths: ${char.strengths.join(', ')}`);
            }
            if (char.weaknesses && char.weaknesses.length > 0) {
              details.push(`Weaknesses: ${char.weaknesses.join(', ')}`);
            }
            if (char.specialDetails) {
              details.push(`Details: ${char.specialDetails}`);
            }
            if (details.length > 0) {
              desc += `: ${details.join(', ')}`;
            }
            return desc;
          }).join('\n');

          // Build relationship descriptions
          const relationshipDescriptions = Object.entries(relationships)
            .filter(([key, type]) => type !== 'Not Known to' && type !== 'kennt nicht' && type !== 'ne connaÃ®t pas')
            .map(([key, type]) => {
              const [char1Id, char2Id] = key.split('-').map(Number);
              const char1 = characters.find(c => c.id === char1Id);
              const char2 = characters.find(c => c.id === char2Id);
              return `${char1?.name} is ${type} ${char2?.name}`;
            }).join('\n');

          const storyTypeName = allStoryTypes.find(t => t.id === storyType)?.name[language] || 'adventure';
          const middlePage = Math.ceil(pages / 2);

          // Build the storybook combined prompt
          const storybookPrompt = `You are an expert children's picture book author. Create a simple, heartwarming story with SHORT text and vivid scene descriptions for illustrations.

# Story Parameters

- **Title**: ${storyTypeName}
- **Target Age**: ${ageFrom}-${ageTo} years (early readers)
- **Length**: ${pages} pages
- **Language**: ${language === 'de' ? 'German (use Ã¤, Ã¶, Ã¼ normally. Do not use ÃŸ, use ss instead)' : language === 'fr' ? 'French' : 'English'}
- **Story Type**: ${storyTypeName}
${storyDetails ? `- **Story Details**: ${storyDetails}` : ''}
${dedication ? `- **Dedication**: ${dedication}` : ''}
- **Characters**:
${characterDescriptions}
${relationshipDescriptions ? `- **Relationships**: \n${relationshipDescriptions}` : ''}

# CRITICAL TEXT LENGTH RULES

This is a PICTURE BOOK. Each page has a large illustration with only a SMALL amount of text.

**TEXT LIMITS PER PAGE:**
- Maximum 3-4 SHORT sentences per page
- Maximum 30-40 words total per page
- Use simple vocabulary for early readers
- Short, punchy sentences that complement the illustration

**GOOD EXAMPLE (Page text):**
"Leo loved to explore new places.
He jumped over rocks with happy faces.
His trusty brown backpack held all he needs!"

**BAD EXAMPLE (Too long):**
"Leo the Lion was a curious young cub who lived in a cozy cave at the edge of the Whispering Woods. Every morning, he would wake up with the sunrise, stretch his little paws, and dream about all the adventures waiting for him..."

# Story Structure

Create a simple story arc:
1. **Beginning** (Pages 1-2): Introduce the main character and setting
2. **Middle** (Pages 3-${middlePage}): A small challenge or adventure
3. **End** (Pages ${middlePage + 1}-${pages}): Happy resolution with a gentle lesson

# Output Format

For EACH page, provide BOTH the story text AND the scene description in this exact format:

---PAGE 1---
TEXT:
[Short story text - 3-4 sentences max, 30-40 words]

SCENE:
Setting: [Location, time of day, atmosphere]
Characters: [Who is in this scene]
Action: [What is happening - the key visual moment]
Mood: [Emotional tone - happy, curious, excited, etc.]

---PAGE 2---
TEXT:
[Short story text]

SCENE:
Setting: [Description]
Characters: [Who is present]
Action: [Key visual moment]
Mood: [Emotional tone]

... continue for all ${pages} pages ...

Also provide a TITLE at the very beginning:
TITLE: [Creative story title]

# Character Guidelines

- Show character traits through simple actions, not descriptions
- Keep interactions simple and positive
- Focus on 1-2 characters per page for clear illustrations

# Important

- Write the COMPLETE story for ALL ${pages} pages
- Keep text SHORT and suitable for picture book format
- Scene descriptions should be detailed enough for an illustrator
- The story should feel complete with a satisfying ending
- Write entirely in ${language === 'de' ? 'German' : language === 'fr' ? 'French' : 'English'}`;

          setGeneratedPrompt(storybookPrompt);
          setGenerationProgress({ current: 1, total: 2, message: 'Generating picture book story and scenes...' });

          const response = await makeApiCall(storybookPrompt, 16000);

          // Extract title
          const titleMatch = response.match(/TITLE:\s*(.+)/i);
          if (titleMatch) {
            setStoryTitle(titleMatch[1].trim());
          }

          // Parse the response to extract text and scenes
          const pageBlocks = response.split(/---PAGE\s+\d+---/i).filter(block => block.trim());

          let fullStoryText = '';
          const scenes = [];

          for (let i = 0; i < pageBlocks.length && i < pages; i++) {
            const block = pageBlocks[i];
            const pageNum = i + 1;

            // Extract TEXT section
            const textMatch = block.match(/TEXT:\s*([\s\S]*?)(?=SCENE:|$)/i);
            const pageText = textMatch ? textMatch[1].trim() : '';

            // Extract SCENE section
            const sceneMatch = block.match(/SCENE:\s*([\s\S]*?)$/i);
            const sceneDesc = sceneMatch ? sceneMatch[1].trim() : '';

            // Build story text with page markers
            fullStoryText += `--- Page ${pageNum} ---\n${pageText}\n\n`;

            // Build scene description
            scenes.push({
              pageNumber: pageNum,
              description: sceneDesc
            });
          }

          setGeneratedStory(fullStoryText);
          setSceneDescriptions(scenes);
          setGenerationProgress({ current: 2, total: 2, message: 'Picture book complete!' });
          setStep(5);

        } catch (error) {
          console.error('Error generating storybook:', error);
          setGeneratedStory(`Sorry, there was an error generating your picture book: ${error.message}`);
          setStep(5);
        } finally {
          setIsGenerating(false);
          setIsGeneratingScenes(false);
          setTimeout(() => setGenerationProgress({ current: 0, total: 0, message: '' }), 2000);
        }
      };

      const generateStoryMultiPart = async () => {
        // Backend now handles API key - no need to check locally
        // if (!apiKey) {
        //   setShowApiKeyPrompt(true);
        //   return;
        // }

        setIsGenerating(true);

        // Extract and set story title
        const title = storyTypes.find(t => t.id === storyType)?.name[language] || 'My Story';
        setStoryTitle(title);

        const basePrompt = editablePrompt || buildPrompt();
        setGeneratedPrompt(basePrompt);

        try {
          // Determine chunk size (5 pages per chunk to avoid timeouts)
          const pagesPerChunk = 5;
          const totalChunks = Math.ceil(pages / pagesPerChunk);

          // Use the edited outline if available
          const outline = editableOutline || storyOutline;

          if (!outline) {
            throw new Error('No outline available. Please generate an outline first.');
          }

          // Generate story in chunks
          let fullStory = '';

          for (let i = 0; i < totalChunks; i++) {
            const startPage = i * pagesPerChunk + 1;
            const endPage = Math.min((i + 1) * pagesPerChunk, pages);

            setGenerationProgress({
              current: i + 1,
              total: totalChunks,
              message: `Generating pages ${startPage}-${endPage}...`
            });

            const chunkPrompt = `${basePrompt}\n\nHere is the story outline:\n${outline}\n\nIMPORTANT: Now write ONLY pages ${startPage} to ${endPage} of the story. Follow the outline above. Use "--- Page X ---" markers for each page. Write the complete content for these pages.\n\nFORMATTING: Format dialogues inline within paragraphs. Do not add extra line breaks between dialogue lines. Keep conversations flowing in continuous prose like a traditional novel.${i > 0 ? `\n\nPrevious story context:\n${fullStory.slice(-500)}` : ''}`;

            const chunk = await makeApiCall(chunkPrompt, 3072);
            fullStory += (i > 0 ? '\n\n' : '') + chunk;
          }

          setGeneratedStory(fullStory);
          setGenerationProgress({ current: totalChunks, total: totalChunks, message: 'Story complete!' });
          setStep(5);
        } catch (error) {
          console.error('Error generating story:', error);
          setGeneratedStory(`Sorry, there was an error generating your story: ${error.message}\n\nPlease check your API key and try again!`);
          setStep(5);
        } finally {
          setIsGenerating(false);
          setTimeout(() => setGenerationProgress({ current: 0, total: 0, message: '' }), 2000);
        }
      };

      const generateStory = async () => {
        // Backend now handles API key - no need to check locally
        // if (!apiKey) {
        //   setShowApiKeyPrompt(true);
        //   return;
        // }

        // Generate full story in one shot (no chunking)
        setIsGenerating(true);

        // Extract and set story title
        const title = storyTypes.find(t => t.id === storyType)?.name[language] || 'My Story';
        setStoryTitle(title);

        // Use the editable prompt if it exists, otherwise build a new one
        const basePrompt = editablePrompt || buildPrompt();

        // Save the prompt for display/download
        setGeneratedPrompt(basePrompt);

        try {
          // Include the outline in the story generation prompt
          const outline = editableOutline || storyOutline;
          const fullPrompt = outline
            ? `${basePrompt}\n\nHere is the story outline:\n${outline}\n\nIMPORTANT: Now write the complete story following the outline above. You MUST write exactly ${pages} pages (Pages 1 through ${pages}). Do NOT stop until all ${pages} pages are complete. Use "--- Page X ---" markers for each page. Write engaging, age-appropriate content for each page.\n\nFORMATTING: Format dialogues inline within paragraphs. Do not add extra line breaks between dialogue lines. Keep conversations flowing in continuous prose like a traditional novel.`
            : basePrompt;

          const storyText = await makeApiCall(fullPrompt, 64000);

          // Store story text prompt and API call for debugging
          setStoryTextPrompt(fullPrompt);
          setStoryTextApiCall({
            type: 'text',
            model: 'claude-sonnet-4-5-20250929',
            prompt: fullPrompt,
            maxTokens: 64000,
            timestamp: new Date().toISOString()
          });

          setGeneratedStory(storyText);
          setStep(5);
        } catch (error) {
          console.error('Error generating story:', error);
          setGeneratedStory(`Sorry, there was an error generating your story: ${error.message}\n\nPlease check your API key and try again!`);
          setStep(5);
        } finally {
          setIsGenerating(false);
        }
      };

      const generateScenes = async () => {
        // Backend now handles API key - no need to check locally
        // if (!apiKey) {
        //   setShowApiKeyPrompt(true);
        //   return;
        // }

        if (!generatedStory) {
          alert(language === 'de' ? 'Bitte erstellen Sie zuerst eine Geschichte!' : language === 'fr' ? 'Veuillez d\'abord gÃ©nÃ©rer une histoire!' : 'Please generate a story first!');
          return;
        }

        setIsGeneratingScenes(true);
        setGenerationProgress({ current: 0, total: pages, message: 'Analyzing story pages...' });

        try {
          // Split story into pages - handle both formats:
          // - Markdown format: ## Seite 1 or ## Page 1
          // - Old format: --- Page 1 --- or --- Seite 1 ---
          const pageMatches = generatedStory.split(/(?:---\s*(?:Page|Seite)\s+\d+\s*---|##\s*(?:Page|Seite)\s+\d+)/i);
          // Remove first element if it's just intro/empty text before page marker
          // Don't filter out empty pages - we need to maintain the page count
          const storyPages = pageMatches.slice(1);

          // Log warning if page count doesn't match
          if (storyPages.length < pages) {
            console.warn(`âš ï¸  Story has only ${storyPages.length} pages, expected ${pages} pages`);
          }

          const scenes = [];
          const prompts = {};

          // Generate scene description for each page (always generate for all requested pages)
          for (let i = 0; i < pages; i++) {
            setGenerationProgress({
              current: i + 1,
              total: pages,
              message: `Creating scene description for page ${i + 1}...`
            });

            const pageContent = (storyPages[i] || '').trim().replace(/^-+|-+$/g, '').trim();
            const pageNumber = i + 1;

            // Warn if page content is missing
            if (!pageContent || pageContent.trim().length === 0) {
              console.warn(`âš ï¸  Page ${pageNumber}: No story text found, generating scene from outline only`);
            }

            // Get character names for reference
            const characterNames = characters.map(c => c.name).join(', ');

            // Get short scene description from outline if available
            const shortSceneDesc = shortSceneDescriptions[pageNumber];

            const scenePrompt = `**ROLE:**
You are an expert Art Director creating an illustration brief for a children's book.

**SCENE CONTEXT:**
${shortSceneDesc ? `Scene Summary: ${shortSceneDesc}\n\n` : ''}Story Text (Page ${pageNumber}):
${pageContent}

**AVAILABLE CHARACTERS & VISUAL REFERENCES:**
${characters.map(c => {
  const details = [];
  if (c.age) details.push(`Age ${c.age}`);
  if (c.gender) details.push(c.gender === 'male' ? 'Male' : c.gender === 'female' ? 'Female' : 'Non-binary');
  if (c.hairColor) details.push(c.hairColor);
  if (c.clothing) details.push(c.clothing);
  if (c.otherFeatures) details.push(c.otherFeatures);
  return `* **${c.name}:** ${details.join(', ')}`;
}).join('\n')}

**TASK:**
Create a detailed visual description of ONE key moment from the scene context provided.

Focus on essential characters only (1-2 maximum unless the story specifically requires more). Choose the most impactful visual moment that captures the essence of the scene.

**OUTPUT FORMAT:**
1. **Setting & Atmosphere:** Describe the background, time of day, lighting, and mood.
2. **Composition:** Describe the camera angle (e.g., low angle, wide shot) and framing.
3. **Characters:**
   * **[Character Name]:** Exact action, body language, facial expression, and location in the frame.
   (Repeat for each character present in this specific scene)

**CONSTRAINTS:**
- Do not include dialogue or speech
- Focus purely on visual elements
- Use simple, clear language
- Only include characters essential to this scene`;

            // Store the prompt for this specific scene
            prompts[pageNumber] = scenePrompt;

            const sceneDescription = await makeApiCall(scenePrompt, 768);

            scenes.push({
              pageNumber: pageNumber,
              description: sceneDescription
            });
          }

          setSceneDescriptions(scenes);
          setSceneDescriptionPrompts(prompts);

          // Validate that we have scenes for all pages
          if (scenes.length < pages) {
            console.warn(`Warning: Only ${scenes.length} scenes generated for ${pages} pages. Story may be incomplete.`);
            console.log('Generated page numbers:', scenes.map(s => s.pageNumber));
          }

          setGenerationProgress({ current: pages, total: pages, message: 'All scenes created!' });
        } catch (error) {
          console.error('Error generating scenes:', error);
          alert(`Error generating scenes: ${error.message}\n\nPlease try again!`);
        } finally {
          setIsGeneratingScenes(false);
          setTimeout(() => setGenerationProgress({ current: 0, total: 0, message: '' }), 2000);
        }
      };

      const downloadScenes = () => {
        if (!Array.isArray(sceneDescriptions) || sceneDescriptions.length === 0) {
          alert(language === 'de' ? 'Keine Szenen zum Herunterladen. Bitte erstellen Sie zuerst Szenen!' : language === 'fr' ? 'Aucune scÃ¨ne Ã  tÃ©lÃ©charger. Veuillez d\'abord crÃ©er des scÃ¨nes!' : 'No scenes to download. Please create scenes first!');
          return;
        }

        try {
          let content = `# Scene Descriptions\n`;
          content += `# ${allStoryTypes.find(t => t.id === storyType)?.name[language] || 'Story'}\n\n`;
          content += `Generated: ${new Date().toLocaleString()}\n\n`;
          content += `---\n\n`;

          sceneDescriptions.forEach(scene => {
            content += `## Page ${scene.pageNumber}\n\n`;
            content += `${scene.description}\n\n`;
            content += `---\n\n`;
          });

          const blob = new Blob([content], { type: 'text/markdown;charset=utf-8' });
          const url = URL.createObjectURL(blob);
          const link = document.createElement('a');
          link.href = url;
          link.download = `scene-descriptions-${Date.now()}.md`;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          URL.revokeObjectURL(url);
        } catch (error) {
          console.error('Download error:', error);
          alert('Download error: ' + error.message);
        }
      };

      const uploadStory = (e) => {
        const file = e.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = (event) => {
            try {
              const content = event.target.result;
              setGeneratedStory(content);

              // Extract page count from uploaded story
              const pageMatches = content.match(/---\s*Page\s+\d+\s*---/gi);
              if (pageMatches && pageMatches.length > 0) {
                setPages(pageMatches.length);
              }

              // Clear scene descriptions when uploading new story
              setSceneDescriptions([]);

              // Navigate to story view
              setStep(5);

              alert('Story uploaded successfully! You can now generate scene descriptions.');
            } catch (error) {
              console.error('Upload error:', error);
              alert('Error uploading story: ' + error.message);
            }
          };
          reader.readAsText(file);
        }
      };

      const saveGeminiApiKey = () => {
        if (tempGeminiApiKey.trim()) {
          localStorage.setItem('gemini_api_key', tempGeminiApiKey);
          setGeminiApiKey(tempGeminiApiKey);
          setShowGeminiApiKeyPrompt(false);
          setTempGeminiApiKey('');
        }
      };

      // ========================================
      // AUTO-RUN WITH BACKGROUND JOB PROCESSING
      // ========================================

      // Background job auto-run mode: Submit job to server and poll for completion
      const runAutoModeBackground = async (skipImages = false) => {
        if (!authToken) {
          alert(language === 'de' ? 'Bitte melden Sie sich an, um den Auto-Modus zu verwenden' : language === 'fr' ? 'Veuillez vous connecter pour utiliser le mode automatique' : 'Please log in to use Auto-Run mode');
          return;
        }

        // Prevent starting multiple jobs
        if (isGenerating) {
          console.log('âš ï¸ Job already in progress, ignoring duplicate request');
          return;
        }

        try {
          setIsGenerating(true); // Lock to prevent multiple jobs

          // Collect all input data
          const inputData = {
            title: storyTitle,
            storyType,
            storyDetails,
            pages,
            language,
            languageLevel,
            characters,
            mainCharacters,
            relationships,
            relationshipTexts,
            dedication,
            artStyle,
            skipImages, // Add flag to skip image generation
            imageGenMode: imageGenMode || undefined // Send user's choice (parallel/sequential)
          };

          // Create the background job
          const response = await fetchWithTimeout(`${API_URL}/api/jobs/create-story`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${authToken}`
            },
            body: JSON.stringify(inputData)
          }, 30000);

          if (!response.ok) {
            const error = await response.json();
            throw new Error(error.error || 'Failed to create story job');
          }

          const { jobId, message } = await response.json();

          console.log(`âœ… Story job created: ${jobId}`);

          // Show informational message (no cancel - generation already started)
          const infoMessage = skipImages
            ? (language === 'de'
              ? 'Ihre Geschichte wird jetzt erstellt!\n\n' +
                'Die Texterstellung dauert ca. 2-3 Minuten.\n\n' +
                'Es werden keine Bilder generiert (Entwicklermodus).'
              : language === 'fr'
              ? 'Votre histoire est en cours de crÃ©ation!\n\n' +
                'La crÃ©ation du texte prendra environ 2-3 minutes.\n\n' +
                'Aucune image ne sera gÃ©nÃ©rÃ©e (mode dÃ©veloppeur).'
              : 'Your story is now being created!\n\n' +
                'Text creation will take approximately 2-3 minutes.\n\n' +
                'No images will be generated (developer mode).')
            : (language === 'de'
              ? 'Ihre Geschichte wird jetzt erstellt!\n\n' +
                'Die Erstellung dauert ca. 10 Minuten.\n\n' +
                'Die Geschichte wird im Hintergrund auf unseren Servern generiert.\n\n' +
                'Sie kÃ¶nnen diese Seite schliessen und spÃ¤ter zurÃ¼ckkommen.'
              : language === 'fr'
              ? 'Votre histoire est en cours de crÃ©ation!\n\n' +
                'La crÃ©ation prendra environ 10 minutes.\n\n' +
                'L\'histoire est gÃ©nÃ©rÃ©e en arriÃ¨re-plan sur nos serveurs.\n\n' +
                'Vous pouvez fermer cette page et revenir plus tard.'
              : 'Your story is now being created!\n\n' +
                'Creation will take approximately 10 minutes.\n\n' +
                'The story is being generated in the background on our servers.\n\n' +
                'You can close this page and come back later.');

          alert(infoMessage);

          // Start polling for job status
          pollJobStatus(jobId);

        } catch (error) {
          console.error('Error starting background job:', error);
          setIsGenerating(false); // Unlock so user can try again
          alert(`Failed to start background generation: ${error.message}\n\nPlease try again or use manual mode.`);
        }
      };

      // Poll job status and update UI
      const pollJobStatus = async (jobId) => {
        let pollInterval = null;
        let completedAlertShown = false; // Prevent duplicate completion alerts

        const checkStatus = async () => {
          try {
            const response = await fetch(`${API_URL}/api/jobs/${jobId}/status`, {
              headers: {
                'Authorization': `Bearer ${authToken}`
              }
            });

            if (!response.ok) {
              throw new Error('Failed to fetch job status');
            }

            const job = await response.json();

            // Update progress UI
            setGenerationProgress({
              current: job.progress || 0,
              total: 100,
              message: job.progressMessage || 'Processing...'
            });

            // Navigate to step 5 early to show progress (when job starts processing)
            if (job.status === 'processing' && job.progress >= 10 && step !== 5) {
              console.log(`ðŸ“– [PROGRESS] Job is processing (${job.progress}%), navigating to results view`);
              setStep(5);
            }

            // PROGRESSIVE DISPLAY: Show partial results as pages complete
            if (job.partialPages && job.partialPages.length > 0 && job.status === 'processing') {
              console.log(`ðŸ“– [PARTIAL] Received ${job.partialPages.length} completed pages`);

              // Build partial story text from completed pages
              const partialStoryText = job.partialPages
                .sort((a, b) => a.pageNumber - b.pageNumber)
                .map(page => `--- Page ${page.pageNumber} ---\n${page.text}`)
                .join('\n\n');

              // Build partial scene images array
              const partialImages = job.partialPages
                .sort((a, b) => a.pageNumber - b.pageNumber)
                .map(page => ({
                  pageNumber: page.pageNumber,
                  imageData: page.imageData,
                  description: page.description,
                  qualityScore: page.qualityScore
                }));

              // Build partial scene descriptions
              const partialDescriptions = job.partialPages
                .sort((a, b) => a.pageNumber - b.pageNumber)
                .map(page => ({
                  pageNumber: page.pageNumber,
                  description: page.description
                }));

              // Update state with partial results
              if (partialStoryText) {
                setGeneratedStory(partialStoryText);
              }
              if (partialImages.length > 0) {
                setSceneImages(partialImages);
                setSceneDescriptions(partialDescriptions);
              }
            }

            if (job.status === 'completed' && !completedAlertShown) {
              // Job completed successfully - mark alert as shown first to prevent duplicates
              completedAlertShown = true;
              clearInterval(pollInterval);
              setGenerationProgress({ current: 100, total: 100, message: 'Complete!' });

              // Parse and display the result
              const result = job.resultData;
              console.log('ðŸ“– [PIPELINE RESULT] Full result keys:', Object.keys(result || {}));
              console.log('ðŸ“– [PIPELINE RESULT] storyText exists?', !!result?.storyText);
              console.log('ðŸ“– [PIPELINE RESULT] storyText length:', result?.storyText?.length || 0);
              console.log('ðŸ“– [PIPELINE RESULT] storyText preview:', result?.storyText?.substring(0, 200));

              if (result) {
                // Extract title from storyText if result.title is empty (fallback for markdown format)
                let finalTitle = result.title || storyTitle;
                if ((!finalTitle || finalTitle === 'My Story') && result.storyText) {
                  const titleMatch = result.storyText.match(/^#\s+(.+?)$/m);
                  if (titleMatch) {
                    finalTitle = titleMatch[1].trim();
                    console.log('ðŸ“– [TITLE EXTRACTION] Extracted title from storyText:', finalTitle);
                  }
                }
                setStoryTitle(finalTitle);
                setStoryOutline(result.outline || ''); // Load story outline
                setGeneratedStory(result.storyText || '');
                console.log('ðŸ“– [SETTING STATE] generatedStory set to:', (result.storyText || '').substring(0, 200));
                setSceneDescriptions(result.sceneDescriptions || []);
                setSceneImages(result.images || []);
                setCoverImages(result.coverImages || { frontCover: null, initialPage: null, backCover: null });
                setImagePrompts(result.imagePrompts || {}); // Load image prompts
                setCoverImagePrompts(result.coverPrompts || {}); // Load cover image prompts for dev mode
                setRawAIResponse(result.rawAIResponse || ''); // Store raw AI response for developer mode
              }

              setIsGenerating(false); // Unlock generation
              alert(language === 'de' ? 'Geschichte erfolgreich erstellt! Ihre Geschichte ist bereit.' : language === 'fr' ? 'GÃ©nÃ©ration terminÃ©e! Votre histoire est prÃªte.' : 'Story generation complete! Your story is ready.');

              // Auto-navigate to page 5 to view the story
              setStep(5);

              // Auto-save the story
              if (result) {
                const storyToSave = {
                  id: jobId, // Use jobId as story ID to prevent duplicates
                  title: result.title || storyTitle,
                  storyType: result.storyType || storyType,
                  storyDetails: result.storyDetails || storyDetails,
                  pages: result.pages || pages,
                  language: result.language || language,
                  languageLevel: result.languageLevel || languageLevel,
                  characters: result.characters || characters,
                  mainCharacters: result.mainCharacters || mainCharacters,
                  relationships: result.relationships || relationships,
                  relationshipTexts: result.relationshipTexts || relationshipTexts,
                  dedication: result.dedication || dedication,
                  artStyle: result.artStyle || artStyle,
                  outline: result.outline,
                  story: result.storyText,
                  sceneDescriptions: result.sceneDescriptions,
                  sceneImages: result.images,
                  imagePrompts: result.imagePrompts || {}, // Save image prompts for developer features
                  coverImagePrompts: result.coverPrompts || {}, // Save cover image prompts for developer features
                  coverImages: result.coverImages || { frontCover: null, initialPage: null, backCover: null },
                  thumbnail: (result.coverImages?.frontCover?.imageData || result.coverImages?.frontCover || null),
                  rawAIResponse: result.rawAIResponse || '', // Save raw AI response for developer features
                  createdAt: new Date().toISOString()
                };

                const savedId = await saveStory(storyToSave);
                if (savedId) {
                  setCurrentStoryId(savedId);
                  // Clear draft after successful story save
                  clearStoryDraft();
                }
              }

            } else if (job.status === 'failed') {
              // Job failed
              clearInterval(pollInterval);
              setIsGenerating(false); // Unlock so user can try again
              setGenerationProgress({ current: 0, total: 0, message: '' });
              alert(`Story generation failed: ${job.errorMessage || 'Unknown error'}\n\nPlease try again.`);

            } else {
              // Still processing (pending or processing status)
              console.log(`Job ${jobId} status: ${job.status}, progress: ${job.progress}%`);
            }

          } catch (error) {
            console.error('Error polling job status:', error);
            // Don't stop polling on transient errors, just log them
          }
        };

        // Check immediately, then every 3 seconds (faster for progressive display)
        await checkStatus();
        pollInterval = setInterval(checkStatus, 3000); // Poll every 3 seconds for live updates
      };

      // Auto-Run Mode: Execute all steps automatically (CLIENT-SIDE - LEGACY)
      // This is the old client-side version, kept as fallback
      const runAutoModeClientSide = async () => {
        // Backend now handles API key - no need to check locally
        // if (!apiKey) {
        //   setShowApiKeyPrompt(true);
        //   return;
        // }

        try {
          // Step 1: Generate Outline
          setGenerationProgress({ current: 1, total: 4, message: 'Step 1/4: Generating story outline...' });
          setIsGeneratingOutline(true);

          // Build base prompt for later use in story generation
          const basePrompt = buildPrompt();

          // If user edited the prompt in preview, use it directly
          // Otherwise, build the full outline prompt with structure
          let outlinePrompt;
          if (editablePrompt) {
            // User edited the preview - use their edited version directly
            outlinePrompt = editablePrompt;
          } else {
            // No edits - build the full structured prompt
            outlinePrompt = `# Role and Context

You are an expert children's book writer with deep understanding of age-appropriate storytelling, narrative structure, and visual storytelling for illustrated books. Your expertise includes:

- Creating engaging, age-appropriate narratives that captivate young readers
- Crafting clear story arcs with proper setup, conflict, and resolution
- Writing vivid scene descriptions that translate beautifully to illustrations
- Balancing text and visual elements for maximum impact
- Understanding pacing and page turns in illustrated books
- Creating memorable characters and meaningful moments

Your task is to create a compelling, well-structured story outline that will guide both the narrative text and visual illustrations.

${basePrompt}

# Part 1: Story Title

Create an engaging, age-appropriate title for this story. The title should:
- Capture the essence of the story
- Be appealing to the target age group
- Be memorable and creative
- Reflect the main theme or adventure

Format:
Title: [Your creative title here]

# Part 2: Story Outline

Create a detailed outline for this ${pages}-page story. Include:
- Brief summary of each page (what happens on that page)
- Key events and character moments
- Story arc and progression (clear beginning, middle, and end)
- How the story builds tension and resolves satisfyingly

For EACH of the ${pages} story pages, provide a SHORT SCENE DESCRIPTION (1-2 sentences) that describes the visual scene - what the characters are doing, where they are, and the setting. This will be used for illustration purposes.

# Part 3: Cover Scene Descriptions

In addition to the ${pages} story pages, provide scene descriptions for these 3 cover elements:

**Title Page Scene**: A captivating cover illustration that features the main characters and sets the tone for the story. This should be visually striking and focus on the protagonist(s) in a way that draws readers in.

**Initial Page Scene**: A dedication/introduction page illustration that creates a warm, inviting entry into the story world. This sets the mood and welcomes readers.

**Back Cover Scene**: A satisfying concluding illustration that provides closure and leaves readers with a positive feeling. This should feel like a natural ending to the visual journey.

# Format Your Response

Title: [Story title]

Page 1: [Summary]
Scene: [Short visual description]

Page 2: [Summary]
Scene: [Short visual description]

...and so on for all ${pages} pages.

Title Page: [Summary of title page concept]
Scene: [Visual description focusing on main characters]

Initial Page: [Summary of dedication/intro concept]
Scene: [Visual description for welcoming scene]

Back Cover: [Summary of back cover concept]
Scene: [Visual description for concluding scene]

Be specific and creative. Each scene description should paint a clear picture for the illustrator.`;
          }

          // Store the prompt for debugging/display
          setGeneratedPrompt(outlinePrompt);

          const outline = await makeApiCall(outlinePrompt, 8192);  // Max for Sonnet 4.5

          // Store outline prompt and API call for debugging
          setStoryOutlinePrompt(outlinePrompt);
          setStoryOutlineApiCall({
            type: 'text',
            model: 'claude-sonnet-4-5-20250929',
            prompt: outlinePrompt,
            maxTokens: 8192,
            timestamp: new Date().toISOString()
          });

          // Extract title
          const titleMatch = outline.match(/Title:\s*(.+)/i);
          if (titleMatch) {
            const extractedTitle = titleMatch[1].trim();
            setStoryTitle(extractedTitle);
            console.log('Extracted title:', extractedTitle);
          }

          setStoryOutline(outline);
          setEditableOutline(outline);

          // Parse outline to extract scene descriptions
          if (currentUser?.role === 'admin') {
            console.log('ðŸ“‹ Outline generated successfully');
            console.log('Full outline (first 1000 chars):\n', outline.substring(0, 1000));
            console.log('\n=== END OUTLINE PREVIEW ===\n');
          }

          const sceneDescMap = {};
          const coverScenes = {
            titlePage: '',
            initialPage: '',
            backCover: ''
          };

          const lines = outline.split('\n');
          let currentPage = null;
          let currentCoverType = null;
          let collectingScene = false;
          let sceneBuffer = '';

          for (let i = 0; i < lines.length; i++) {
            const line = lines[i].trim();

            // Look for "Page X:" pattern (story pages) - handles **Page X:** too
            const pageMatch = line.match(/^(?:\*\*)?Page\s+(\d+)(?:\*\*)?[\s:]/i);
            if (pageMatch) {
              // Save any buffered scene before switching context
              if (collectingScene && sceneBuffer && (currentPage !== null || currentCoverType)) {
                if (currentPage !== null) {
                  sceneDescMap[currentPage] = sceneBuffer.trim();
                  console.log(`Stored scene for page ${currentPage}:`, sceneBuffer.substring(0, 50) + '...');
                } else if (currentCoverType) {
                  coverScenes[currentCoverType] = sceneBuffer.trim();
                  console.log(`Stored ${currentCoverType} scene:`, sceneBuffer.substring(0, 50) + '...');
                }
              }

              currentPage = parseInt(pageMatch[1]);
              currentCoverType = null;
              collectingScene = false;
              sceneBuffer = '';
            }

            // Look for cover page patterns - more flexible matching
            // Matches: "Title Page:", "**Title Page:**", "Title Page Scene:", etc.
            const titlePageMatch = line.match(/(?:\*\*)?Title\s+Page(?:\s+Scene)?(?:\*\*)?:\s*(.+)/i);
            if (titlePageMatch) {
              // Save any buffered scene before switching context
              if (collectingScene && sceneBuffer && (currentPage !== null || currentCoverType)) {
                if (currentPage !== null) {
                  sceneDescMap[currentPage] = sceneBuffer.trim();
                } else if (currentCoverType) {
                  coverScenes[currentCoverType] = sceneBuffer.trim();
                }
              }

              currentCoverType = 'titlePage';
              currentPage = null;
              collectingScene = true;
              sceneBuffer = titlePageMatch[1].trim();
              console.log('Found Title Page scene:', sceneBuffer.substring(0, 50) + '...');
            }

            // Match both "Initial Page" and legacy "Page 0" for backward compatibility
            const initialPageMatch = line.match(/(?:\*\*)?(?:Initial\s+Page|Page\s+0)(?:\s+Scene)?(?:\*\*)?:\s*(.+)/i);
            if (initialPageMatch) {
              // Save any buffered scene before switching context
              if (collectingScene && sceneBuffer && (currentPage !== null || currentCoverType)) {
                if (currentPage !== null) {
                  sceneDescMap[currentPage] = sceneBuffer.trim();
                } else if (currentCoverType) {
                  coverScenes[currentCoverType] = sceneBuffer.trim();
                }
              }

              currentCoverType = 'initialPage';
              currentPage = null;
              collectingScene = true;
              sceneBuffer = initialPageMatch[1].trim();
              console.log('Found Initial Page scene:', sceneBuffer.substring(0, 50) + '...');
            }

            const backCoverMatch = line.match(/(?:\*\*)?Back\s+Cover(?:\s+Scene)?(?:\*\*)?:\s*(.+)/i);
            if (backCoverMatch) {
              // Save any buffered scene before switching context
              if (collectingScene && sceneBuffer && (currentPage !== null || currentCoverType)) {
                if (currentPage !== null) {
                  sceneDescMap[currentPage] = sceneBuffer.trim();
                } else if (currentCoverType) {
                  coverScenes[currentCoverType] = sceneBuffer.trim();
                }
              }

              currentCoverType = 'backCover';
              currentPage = null;
              collectingScene = true;
              sceneBuffer = backCoverMatch[1].trim();
              console.log('Found Back Cover scene:', sceneBuffer.substring(0, 50) + '...');
            }

            // Look for "Scene:" pattern - start collecting scene description (handles **Scene:** too)
            const sceneMatch = line.match(/^(?:\*\*)?Scene(?:\*\*)?:\s*(.+)/i);
            if (sceneMatch) {
              collectingScene = true;
              sceneBuffer = sceneMatch[1].trim();
            } else if (collectingScene && line.length > 0 && !line.match(/^(Page|Title|Back\s+Cover)/i)) {
              // Continue collecting multi-line scene descriptions
              sceneBuffer += ' ' + line;
            } else if (collectingScene && line.length === 0) {
              // Empty line ends scene collection
              if (sceneBuffer && (currentPage !== null || currentCoverType)) {
                if (currentPage !== null) {
                  sceneDescMap[currentPage] = sceneBuffer.trim();
                  console.log(`Stored scene for page ${currentPage}:`, sceneBuffer.substring(0, 50) + '...');
                } else if (currentCoverType) {
                  coverScenes[currentCoverType] = sceneBuffer.trim();
                  console.log(`Stored ${currentCoverType} scene:`, sceneBuffer.substring(0, 50) + '...');
                }
              }
              collectingScene = false;
              sceneBuffer = '';
            }
          }

          // Save any remaining buffered scene at the end
          if (collectingScene && sceneBuffer && (currentPage !== null || currentCoverType)) {
            if (currentPage !== null) {
              sceneDescMap[currentPage] = sceneBuffer.trim();
              console.log(`Stored scene for page ${currentPage}:`, sceneBuffer.substring(0, 50) + '...');
            } else if (currentCoverType) {
              coverScenes[currentCoverType] = sceneBuffer.trim();
              console.log(`Stored ${currentCoverType} scene:`, sceneBuffer.substring(0, 50) + '...');
            }
          }

          setShortSceneDescriptions(sceneDescMap);
          setCoverSceneDescriptions(coverScenes);
          if (currentUser?.role === 'admin') {
            console.log('âœ… Parsing complete -', Object.keys(sceneDescMap).length, 'scenes');
          }

          // Warning if cover scenes are empty
          if (!coverScenes.titlePage || !coverScenes.initialPage || !coverScenes.backCover) {
            console.warn('âš ï¸ WARNING: Some cover scene descriptions are empty!');
            console.warn('Missing:', {
              titlePage: !coverScenes.titlePage,
              initialPage: !coverScenes.initialPage,
              backCover: !coverScenes.backCover
            });
          }

          setIsGeneratingOutline(false);
          await new Promise(resolve => setTimeout(resolve, 500));

          // Step 2: Generate Story
          setGenerationProgress({ current: 2, total: 4, message: 'Step 2/4: Generating full story...' });
          setIsGenerating(true);

          // Generate full story in one shot with Claude Sonnet 4.5's 64K output limit
          const fullPrompt = `${basePrompt}\n\nHere is the story outline:\n${outline}\n\nIMPORTANT: Now write the complete story following the outline above. You MUST write exactly ${pages} pages (Pages 1 through ${pages}). Do NOT stop until all ${pages} pages are complete. Use "--- Page X ---" markers for each page. Write engaging, age-appropriate content for each page.\n\nFORMATTING: Format dialogues inline within paragraphs. Do not add extra line breaks between dialogue lines. Keep conversations flowing in continuous prose like a traditional novel.`;
          const storyText = await makeApiCall(fullPrompt, 64000);

          setGeneratedStory(storyText);
          setStep(5);
          setIsGenerating(false);
          await new Promise(resolve => setTimeout(resolve, 500));

          // Step 3: Generate Scene Descriptions (IN PARALLEL - much faster!)
          setGenerationProgress({ current: 3, total: 4, message: 'Step 3/4: Creating scene descriptions in parallel...' });
          setIsGeneratingScenes(true);

          const pageMatches = storyText.split(/---\s*Page\s+\d+\s*---/i);
          // Remove first element if it's just intro/empty text before "--- Page 1 ---"
          const storyPages = pageMatches.slice(1).filter(p => p.trim().length > 0);
          const scenePrompts = {};

          // Create all scene generation promises at once
          const scenePromises = Array.from({ length: Math.min(pages, storyPages.length) }, async (_, i) => {
            const pageContent = (storyPages[i] || '').trim().replace(/^-+|-+$/g, '').trim();
            const pageNumber = i + 1;
            const characterNames = characters.map(c => c.name).join(', ');

            // Get short scene description from outline if available
            const shortSceneDesc = sceneDescMap[pageNumber];

            const scenePrompt = `**ROLE:**
You are an expert Art Director creating an illustration brief for a children's book.

**SCENE CONTEXT:**
${shortSceneDesc ? `Scene Summary: ${shortSceneDesc}\n\n` : ''}Story Text (Page ${pageNumber}):
${pageContent}

**AVAILABLE CHARACTERS & VISUAL REFERENCES:**
${characters.map(c => {
  const details = [];
  if (c.age) details.push(`Age ${c.age}`);
  if (c.gender) details.push(c.gender === 'male' ? 'Male' : c.gender === 'female' ? 'Female' : 'Non-binary');
  if (c.hairColor) details.push(c.hairColor);
  if (c.clothing) details.push(c.clothing);
  if (c.otherFeatures) details.push(c.otherFeatures);
  return `* **${c.name}:** ${details.join(', ')}`;
}).join('\n')}

**TASK:**
Create a detailed visual description of ONE key moment from the scene context provided.

Focus on essential characters only (1-2 maximum unless the story specifically requires more). Choose the most impactful visual moment that captures the essence of the scene.

**OUTPUT FORMAT:**
1. **Setting & Atmosphere:** Describe the background, time of day, lighting, and mood.
2. **Composition:** Describe the camera angle (e.g., low angle, wide shot) and framing.
3. **Characters:**
   * **[Character Name]:** Exact action, body language, facial expression, and location in the frame.
   (Repeat for each character present in this specific scene)

**CONSTRAINTS:**
- Do not include dialogue or speech
- Focus purely on visual elements
- Use simple, clear language
- Only include characters essential to this scene`;

            // Store the prompt for this specific scene
            scenePrompts[pageNumber] = scenePrompt;

            const sceneDescription = await makeApiCall(scenePrompt, 768);
            return { pageNumber: pageNumber, description: sceneDescription };
          });

          // Wait for all scene descriptions to complete in parallel
          const scenes = await Promise.all(scenePromises);

          setSceneDescriptions(scenes);
          setSceneDescriptionPrompts(scenePrompts);

          // Validate that we have scenes for all pages
          if (scenes.length < pages) {
            console.warn(`Auto-mode: Only ${scenes.length} scenes generated for ${pages} pages. Story may be incomplete.`);
            console.log('Auto-mode: Generated page numbers:', scenes.map(s => s.pageNumber));
            console.log('Auto-mode: Story pages array length:', storyPages.length);
          }

          setIsGeneratingScenes(false);
          await new Promise(resolve => setTimeout(resolve, 500));

          // Step 4: Generate Scene Images (IN PARALLEL - much faster!)
          setGenerationProgress({ current: 4, total: 4, message: 'Step 4/4: Generating scene images in parallel...' });
          setIsGeneratingImages(true);

          const prompts = {};
          const characterClothing = {};

          // Ensure we have scenes for all pages
          const scenesToGenerate = scenes.slice(0, pages);
          console.log(`Auto-mode: Generating images for ${scenesToGenerate.length} scenes in parallel (pages: ${pages}, total scenes: ${scenes.length})`);

          // Create all image generation promises at once
          const imagePromises = scenesToGenerate.map(async (scene) => {
            console.log(`Auto-mode: Generating image for page ${scene.pageNumber}`);

            const charactersInScene = characters.filter(char =>
              scene.description.toLowerCase().includes(char.name.toLowerCase())
            );

            const sceneText = scene.description.toLowerCase();
            const isOutdoor = sceneText.includes('outside') || sceneText.includes('outdoor') ||
                            sceneText.includes('forest') || sceneText.includes('park') ||
                            sceneText.includes('garden') || sceneText.includes('street') ||
                            sceneText.includes('playground');
            const isIndoor = sceneText.includes('inside') || sceneText.includes('indoor') ||
                           sceneText.includes('room') || sceneText.includes('house') ||
                           sceneText.includes('kitchen') || sceneText.includes('bedroom');

            let characterPrompts = '';
            const characterImages = [];
            const characterImageMap = []; // Track which image belongs to which character

            if (charactersInScene.length > 0) {
              characterPrompts = '\n\nThe scene MUST feature the following characters with strict adherence to their physical description (Age, Height, Build):\n';

              charactersInScene.forEach((char, idx) => {
                const age = parseInt(char.age) || 10;

                // Use clothing from avatar analysis if available, otherwise use default
                if (!characterClothing[char.name]) {
                  if (char.clothing) {
                    // Use clothing extracted from avatar
                    characterClothing[char.name] = char.clothing;
                    characterClothing[char.name + '_base'] = char.clothing;
                  } else {
                    // Fallback to default clothing
                    if (isOutdoor) {
                      characterClothing[char.name] = age < 13 ? 'blue jacket, jeans, red sneakers' : 'gray jacket, dark pants, brown shoes';
                    } else {
                      characterClothing[char.name] = age < 13 ? 'casual outdoor clothes' : 'casual indoor clothes';
                    }
                    characterClothing[char.name + '_base'] = characterClothing[char.name];
                  }
                } else {
                  // Adjust clothing for indoor/outdoor if needed
                  const baseClothing = characterClothing[char.name + '_base'] || characterClothing[char.name];
                  if (isOutdoor && baseClothing && !characterClothing[char.name].includes('jacket')) {
                    characterClothing[char.name] = `jacket over ${baseClothing}`;
                  } else if (isIndoor && characterClothing[char.name].includes('jacket')) {
                    characterClothing[char.name] = baseClothing;
                  }
                }

                // Build comprehensive physical description
                let physicalDesc = '';
                if (char.height) physicalDesc += `Height: ${char.height} cm, `;
                if (char.build) physicalDesc += `Build: ${char.build}, `;
                if (char.otherFeatures) physicalDesc += char.otherFeatures;
                if (!physicalDesc) physicalDesc = '3D character';

                // Track if this character has a reference image
                // Use same priority as server: bodyNoBgUrl > bodyPhotoUrl > photoUrl
                const charPhoto = char.bodyNoBgUrl || char.bodyPhotoUrl || char.photoUrl;
                const hasImage = charPhoto ? true : false;
                const imageRef = hasImage ? ` [Reference Image ${characterImages.length + 1}]` : '';

                characterPrompts += `Character ${idx + 1} (${char.name})${imageRef}: Age ${char.age}, ${physicalDesc.trim()}. Wearing: ${characterClothing[char.name]}. Eyes must be correctly aligned, not cross-eyed, with a natural gaze.\n`;

                // Use avatar for better character consistency
                if (charPhoto) {
                  characterImages.push(charPhoto);
                  characterImageMap.push({ name: char.name, imageIndex: characterImages.length });
                }
              });

              // Add image reference explanation if we have character images
              if (characterImageMap.length > 0) {
                characterPrompts += '\n**CHARACTER REFERENCE IMAGES:**\n';
                characterImageMap.forEach((mapping) => {
                  characterPrompts += `- Image ${mapping.imageIndex}: ${mapping.name}'s portrait (use for facial features, appearance consistency)\n`;
                });
              }

              characterPrompts += '\nMaintain their visual identity, relative heights, and ages as described.';
            }

            const shortSceneDesc = sceneDescMap[scene.pageNumber];

            // Get the selected art style's prompt
            const selectedStyle = artStyles.find(s => s.id === artStyle) || artStyles[0];
            const styleDescription = selectedStyle.prompt;

            const imagePrompt = `Create a cinematic scene in ${styleDescription}.\n\nScene Description: ${scene.description}\n${characterPrompts}\n\nImportant:\n- Show only the emotions visible on faces (happy, sad, surprised, worried, excited)\n- Keep clothing exactly as described\n- Maintain consistent character appearance\n- Clean, clear composition`;

            prompts[scene.pageNumber] = imagePrompt;

            try {
              let imageData;
              if (characterImages.length > 0) {
                // Call backend API endpoint which has the Gemini API key
                const parts = [{ text: imagePrompt }];

                characterImages.forEach(charImage => {
                  const base64Data = charImage.replace(/^data:image\/\w+;base64,/, '');
                  const mimeType = charImage.match(/^data:(image\/\w+);base64,/) ?
                    charImage.match(/^data:(image\/\w+);base64,/)[1] : 'image/png';

                  parts.push({
                    inlineData: {
                      mimeType: mimeType,
                      data: base64Data
                    }
                  });
                });

                const apiPayload = {
                  model: 'gemini-2.5-flash-image',
                  contents: [{ parts }],
                  safetySettings: [
                    { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_ONLY_HIGH" },
                    { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_ONLY_HIGH" },
                    { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_ONLY_HIGH" },
                    { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_ONLY_HIGH" }
                  ]
                };

                // Log full API call for admin debugging
                const apiCallLog = {
                  endpoint: `${API_URL}/api/gemini`,
                  method: 'POST',
                  payload: JSON.parse(JSON.stringify(apiPayload)), // Deep copy without image data
                  timestamp: new Date().toISOString()
                };
                // Remove base64 image data from log to keep it readable
                if (apiCallLog.payload.contents && apiCallLog.payload.contents[0].parts) {
                  apiCallLog.payload.contents[0].parts = apiCallLog.payload.contents[0].parts.map(part => {
                    if (part.inlineData) {
                      return { inlineData: { mimeType: part.inlineData.mimeType, data: '[base64 image data]' } };
                    }
                    return part;
                  });
                }
                setApiCalls(prev => ({ ...prev, [scene.pageNumber]: apiCallLog }));

                const response = await fetchWithTimeout(`${API_URL}/api/gemini`, {
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${localStorage.getItem('auth_token')}`
                  },
                  body: JSON.stringify(apiPayload)
                });

                if (!response.ok) throw new Error(`API Error: ${response.status}`);

                const data = await response.json();
                if (!data.candidates || data.candidates.length === 0) {
                  throw new Error("No response from Gemini.");
                }

                const candidate = data.candidates[0];
                if (candidate.finishReason && candidate.finishReason !== 'STOP') {
                  throw new Error(`Content blocked: ${candidate.finishReason}.`);
                }

                if (!candidate.content || !candidate.content.parts) {
                  throw new Error("Invalid response from Gemini.");
                }

                const responseParts = candidate.content.parts;
                for (const part of responseParts) {
                  if (part.inlineData && part.inlineData.data) {
                    imageData = `data:image/png;base64,${part.inlineData.data}`;
                    break;
                  }
                }

                if (!imageData) throw new Error("No image data found in response.");
              } else {
                imageData = await callGeminiAPI(imagePrompt);
              }

              return { pageNumber: scene.pageNumber, imageData: imageData };
            } catch (error) {
              console.error(`Error generating image for page ${scene.pageNumber}:`, error);
              return {
                pageNumber: scene.pageNumber,
                imageData: null,
                error: error.message
              };
            }
          });

          // Wait for all images to complete in parallel
          const images = await Promise.all(imagePromises);

          setSceneImages(images);
          setImagePrompts(prompts);

          // Generate cover images in parallel
          console.log('Generating 3 cover images...');
          const selectedStyle = artStyles.find(s => s.id === artStyle) || artStyles[0];
          const styleDescription = selectedStyle.prompt;

          // Build character information for cover images with main character emphasis
          const coverCharacterImages = [];
          const coverCharacterImageMap = [];
          let characterInfo = '';

          if (characters.length > 0) {
            // Separate main characters from supporting characters
            const mainChars = characters.filter(c => mainCharacters.includes(c.id));
            const supportingChars = characters.filter(c => !mainCharacters.includes(c.id));

            characterInfo = '\n\n**MAIN CHARACTER(S) - Must be prominently featured in the CENTER of the image:**\n';

            // List main characters first with emphasis
            // Use same priority as server: bodyNoBgUrl > bodyPhotoUrl > photoUrl
            mainChars.forEach((char) => {
              const charPhoto = char.bodyNoBgUrl || char.bodyPhotoUrl || char.photoUrl;
              const imageRef = charPhoto ? ` [Reference Image ${coverCharacterImages.length + 1}]` : '';
              const physicalDesc = generateCharacterDescription(char);
              characterInfo += `â­ MAIN: ${physicalDesc}${imageRef}\n`;

              if (charPhoto) {
                coverCharacterImages.push(charPhoto);
                coverCharacterImageMap.push({ name: char.name, imageIndex: coverCharacterImages.length, isMain: true });
              }
            });

            // Then list supporting characters
            if (supportingChars.length > 0) {
              characterInfo += '\n**Supporting characters (can appear in background or sides):**\n';
              supportingChars.forEach((char) => {
                const charPhoto = char.bodyNoBgUrl || char.bodyPhotoUrl || char.photoUrl;
                const imageRef = charPhoto ? ` [Reference Image ${coverCharacterImages.length + 1}]` : '';
                const physicalDesc = generateCharacterDescription(char);
                characterInfo += `Supporting: ${physicalDesc}${imageRef}\n`;

                if (charPhoto) {
                  coverCharacterImages.push(charPhoto);
                  coverCharacterImageMap.push({ name: char.name, imageIndex: coverCharacterImages.length, isMain: false });
                }
              });
            }

            // Add image reference explanation if we have character images
            if (coverCharacterImageMap.length > 0) {
              characterInfo += '\n**CHARACTER REFERENCE IMAGES:**\n';
              coverCharacterImageMap.forEach((mapping) => {
                const mainLabel = mapping.isMain ? ' (MAIN - center of image)' : ' (supporting)';
                characterInfo += `- Image ${mapping.imageIndex}: ${mapping.name}'s portrait${mainLabel}\n`;
              });
            }

            characterInfo += '\n**CRITICAL: Main character(s) must be the LARGEST and most CENTRAL figures in the composition.**\n';
          }

          // Use scene descriptions from outline if available, otherwise use defaults
          const titlePageScene = coverSceneDescriptions.titlePage || `A beautiful, magical title page featuring the main characters. Decorative elements that reflect the story's theme with space for the title text.`;
          const initialPageScene = coverSceneDescriptions.initialPage || `A warm, inviting dedication/introduction page that sets the mood and welcomes readers.`;
          const backCoverScene = coverSceneDescriptions.backCover || `A satisfying, conclusive ending scene that provides closure and leaves readers with a warm feeling.`;

          // Define cover image prompts with scene descriptions from outline
          const frontCoverPrompt = `${titlePageScene}\n\nStyle: ${styleDescription}.${characterInfo}\n\nCreate this as a beautiful title page illustration for the children's book "${storyTitle}".\n\nIMPORTANT: The image should include the story title "${storyTitle}" integrated beautifully into the illustration. Make the title prominent and visually appealing as part of the cover art.`;
          const initialPagePrompt = dedication && dedication.trim()
            ? `${initialPageScene}\n\nStyle: ${styleDescription}.${characterInfo}\n\nCRITICAL: Include ONLY this exact text in the image: "${dedication}"\n\nDo not add any other text. Only "${dedication}" must appear. No additional words allowed.`
            : `${initialPageScene}\n\nStyle: ${styleDescription}.${characterInfo}\n\nCreate this as an introduction page for "${storyTitle}".\n\nIMPORTANT: This image should contain NO TEXT at all - create a purely visual, atmospheric illustration that sets the mood for the story.`;
          const backCoverPrompt = `${backCoverScene}\n\nStyle: ${styleDescription}.${characterInfo}\n\nCRITICAL: Include ONLY this exact text in the image: "magicalstory.ch" in elegant letters in the bottom left corner.\n\nDo not add any other text. Only "magicalstory.ch" must appear. No additional words allowed.`;

          // Define detailed cover scene descriptions for display
          const coverDescriptions = {
            frontCover: `**Title Page / Front Cover**\n\n${titlePageScene}`,
            initialPage: `**Initial Page - Dedication/Introduction**\n\n${initialPageScene}`,
            backCover: `**Back Cover**\n\n${backCoverScene}`
          };

          const generateCoverImage = async (coverType, prompt, charImages = []) => {
            try {
              let imageData = null;

              // If we have character images, use multi-part API call
              if (charImages.length > 0) {
                const parts = [{ text: prompt }];

                charImages.forEach(charImage => {
                  const base64Data = charImage.replace(/^data:image\/\w+;base64,/, '');
                  const mimeType = charImage.match(/^data:(image\/\w+);base64,/) ?
                    charImage.match(/^data:(image\/\w+);base64,/)[1] : 'image/png';

                  parts.push({
                    inlineData: {
                      mimeType: mimeType,
                      data: base64Data
                    }
                  });
                });

                const apiPayload = {
                  model: 'gemini-2.5-flash-image',
                  contents: [{ parts }],
                  safetySettings: [
                    { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_ONLY_HIGH" },
                    { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_ONLY_HIGH" },
                    { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_ONLY_HIGH" },
                    { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_ONLY_HIGH" }
                  ]
                };

                const response = await fetchWithTimeout(`${API_URL}/api/gemini`, {
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${localStorage.getItem('auth_token')}`
                  },
                  body: JSON.stringify(apiPayload)
                });

                if (!response.ok) throw new Error(`API Error: ${response.status}`);

                const data = await response.json();
                if (!data.candidates || data.candidates.length === 0) {
                  throw new Error("No response from Gemini.");
                }

                const candidate = data.candidates[0];
                if (candidate.finishReason && candidate.finishReason !== 'STOP') {
                  throw new Error(`Content blocked: ${candidate.finishReason}.`);
                }

                if (!candidate.content || !candidate.content.parts) {
                  throw new Error("Invalid response from Gemini.");
                }

                const responseParts = candidate.content.parts;
                for (const part of responseParts) {
                  if (part.inlineData && part.inlineData.data) {
                    imageData = `data:image/png;base64,${part.inlineData.data}`;
                    break;
                  }
                }

                if (!imageData) throw new Error("No image data found in response.");
              } else {
                // No character images, use simple text-only API call
                imageData = await callGeminiAPI(prompt);
              }

              // Analyze image quality
              const analysis = await analyzeImageQuality(imageData, prompt, charImages);

              return {
                imageData,
                qualityScore: analysis?.score || null,
                qualityReasoning: analysis?.reasoning || null
              };
            } catch (error) {
              console.error(`Error generating ${coverType} cover:`, error);
              return null;
            }
          };

          const coverPromises = [
            generateCoverImage('frontCover', frontCoverPrompt, coverCharacterImages),
            generateCoverImage('initialPage', initialPagePrompt, coverCharacterImages),
            generateCoverImage('backCover', backCoverPrompt, coverCharacterImages)
          ];

          const [frontCover, initialPage, backCover] = await Promise.all(coverPromises);

          // Store cover image prompts
          setCoverImagePrompts({
            frontCover: frontCoverPrompt,
            initialPage: initialPagePrompt,
            backCover: backCoverPrompt
          });

          // Store cover image API calls for debugging
          setCoverImageApiCalls({
            frontCover: { type: 'image', model: 'gemini-2.0-flash-exp', prompt: frontCoverPrompt },
            initialPage: { type: 'image', model: 'gemini-2.0-flash-exp', prompt: initialPagePrompt },
            backCover: { type: 'image', model: 'gemini-2.0-flash-exp', prompt: backCoverPrompt }
          });

          setCoverImages({
            frontCover,
            initialPage,
            backCover,
            descriptions: coverDescriptions
          });
          console.log('Cover images generated with full scene descriptions and prompts stored');

          setIsGeneratingImages(false);

          // Save the complete story
          const storyToSave = {
            title: storyTitle || `${storyType} Story - ${new Date().toLocaleDateString()}`,
            storyType,
            artStyle,
            pages,
            language,
            languageLevel,
            characters,
            mainCharacters,
            relationships,
            relationshipTexts,
            dedication,
            outline: storyOutline,
            story: storyText,
            sceneDescriptions: scenes,
            sceneImages: images,
            coverImages: coverImages,
            thumbnail: getCoverImageData(coverImages.frontCover), // Use front cover as thumbnail
            createdAt: new Date().toISOString()
          };

          const savedId = await saveStory(storyToSave);
          if (savedId) {
            // Store the current story ID for print orders
            setCurrentStoryId(savedId);
            // Reload saved stories
            const updatedStories = await loadStories();
            setSavedStories(updatedStories);
            // Clear draft after successful story save
            clearStoryDraft();
          }

          setGenerationProgress({ current: 4, total: 4, message: 'Complete! Story and images ready!' });
          setTimeout(() => setGenerationProgress({ current: 0, total: 0, message: '' }), 3000);
        } catch (error) {
          console.error('Auto-run error:', error);
          alert(`Auto-run failed: ${error.message}\n\nYou can continue manually from where it stopped.`);
          setGenerationProgress({ current: 0, total: 0, message: '' });
          setIsGeneratingOutline(false);
          setIsGenerating(false);
          setIsGeneratingScenes(false);
          setIsGeneratingImages(false);
        }
      };

      // Auto-Run Mode: Main entry point
      // Uses background processing by default for better reliability and user experience
      const runAutoMode = async () => {
        // Use background job processing (server-side generation)
        await runAutoModeBackground();
      };

      // Fetch with timeout helper (to prevent iOS Safari "Load failed" errors)
      const fetchWithTimeout = async (url, options = {}, timeoutMs = 120000) => {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), timeoutMs);

        try {
          const response = await fetch(url, {
            ...options,
            signal: controller.signal
          });
          clearTimeout(timeoutId);
          return response;
        } catch (error) {
          clearTimeout(timeoutId);
          if (error.name === 'AbortError') {
            throw new Error(`Request timeout after ${timeoutMs/1000} seconds. Please check your internet connection and try again.`);
          }
          throw error;
        }
      };

      // Gemini API Helper Functions
      const callGeminiAPI = async (prompt, imageData = null) => {
        if (!authToken) {
          throw new Error('Authentication required');
        }

        const parts = [{ text: prompt }];

        if (imageData) {
          // Add image data if provided
          const base64Data = imageData.replace(/^data:image\/\w+;base64,/, '');
          const mimeType = imageData.match(/^data:(image\/\w+);base64,/) ?
            imageData.match(/^data:(image\/\w+);base64,/)[1] : 'image/png';

          parts.push({
            inlineData: {
              mimeType: mimeType,
              data: base64Data
            }
          });
        }

        const apiPayload = {
          model: 'gemini-2.5-flash-image',
          contents: [{ parts: parts }],
          safetySettings: [
            { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_ONLY_HIGH" },
            { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_ONLY_HIGH" },
            { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_ONLY_HIGH" },
            { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_ONLY_HIGH" }
          ]
        };

        const response = await fetchWithTimeout(`${API_URL}/api/gemini`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${authToken}`
          },
          body: JSON.stringify(apiPayload)
        }, 120000); // 120 second timeout for Gemini API calls

        if (!response.ok) {
          const errorText = await response.text();
          throw new Error(`Gemini API Error: ${errorText}`);
        }

        const data = await response.json();

        if (!data.candidates || data.candidates.length === 0) {
          console.error('Gemini API response:', data);
          throw new Error('No response from Gemini API. The content may have been blocked for safety reasons.');
        }

        // Check for safety blocks or other finish reasons
        const candidate = data.candidates[0];
        if (candidate.finishReason && candidate.finishReason !== 'STOP') {
          console.error('Gemini blocked content:', candidate);
          throw new Error(`Content generation blocked: ${candidate.finishReason}. Try adjusting your prompt or image.`);
        }

        if (!candidate.content || !candidate.content.parts) {
          console.error('Invalid response structure:', candidate);
          throw new Error('Invalid response structure from Gemini API. The content may have been filtered.');
        }

        const responseParts = candidate.content.parts;
        for (const part of responseParts) {
          if (part.inlineData && part.inlineData.data) {
            return `data:image/png;base64,${part.inlineData.data}`;
          }
        }

        throw new Error('No image data found in Gemini response');
      };

      // Helper function to analyze image quality with Gemini
      const analyzeImageQuality = async (generatedImageData, originalPrompt, characterImages = []) => {
        if (!authToken) {
          return null; // Skip if not authenticated
        }

        try {
          const parts = [];

          // QA Analyst prompt
          const qaPrompt = `You are a strict QA Visual Analyst.

    Input 1: The GENERATED IMAGE (First image provided).
    Input 2: The USER PROMPT: "${originalPrompt}"
    Input 3+: REFERENCE IMAGES (Remaining images provided).

    Your Task:
    1. Assess prompt adherence and likeness to reference images.
    2. CRITICALLY inspect for visual artifacts and physical logic failures. Look for:
       - Objects floating that should be held.
       - Distorted hands, limbs, or faces.
       - Items blending into the background or each other.
       - Nonsensical physics.

    Scoring Criteria (0-100):
    - Penalize HEAVILY (-20 to -40 points) for physical hallucinations (floating objects, broken anatomy).
    - Penalize for missing key prompt elements.
    - 100 is reserved for pixel-perfect, logical execution.

    Output strictly in the following format:
    Score: [Score]/100

    Reasoning:
    [Concise explanation. Explicitly mention any artifacts, floating objects, or physics failures if found.]`;

          parts.push({ text: qaPrompt });

          // Add generated image first
          const base64Data = generatedImageData.replace(/^data:image\/\w+;base64,/, '');
          const mimeType = generatedImageData.match(/^data:(image\/\w+);base64,/) ?
            generatedImageData.match(/^data:(image\/\w+);base64,/)[1] : 'image/png';

          parts.push({
            inlineData: {
              mimeType: mimeType,
              data: base64Data
            }
          });

          // Add character reference images
          characterImages.forEach(charImage => {
            const charBase64 = charImage.replace(/^data:image\/\w+;base64,/, '');
            const charMimeType = charImage.match(/^data:(image\/\w+);base64,/) ?
              charImage.match(/^data:(image\/\w+);base64,/)[1] : 'image/png';

            parts.push({
              inlineData: {
                mimeType: charMimeType,
                data: charBase64
              }
            });
          });

          const apiPayload = {
            model: 'gemini-2.0-flash-exp',
            contents: [{ parts: parts }],
            safetySettings: [
              { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_NONE" },
              { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_NONE" },
              { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_NONE" },
              { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_NONE" }
            ]
          };

          const response = await fetchWithTimeout(`${API_URL}/api/gemini`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${authToken}`
            },
            body: JSON.stringify(apiPayload)
          }, 60000); // 60 second timeout

          if (!response.ok) {
            console.error('Quality analysis failed');
            return null;
          }

          const data = await response.json();

          if (!data.candidates || data.candidates.length === 0) {
            return null;
          }

          const analysisText = data.candidates[0].content.parts[0].text;

          // Parse score from response
          const scoreMatch = analysisText.match(/Score:\s*(\d+)\/100/i);
          const score = scoreMatch ? parseInt(scoreMatch[1]) : null;

          // Extract reasoning
          const reasoningMatch = analysisText.match(/Reasoning:\s*(.+)/is);
          const reasoning = reasoningMatch ? reasoningMatch[1].trim() : '';

          return {
            score: score,
            reasoning: reasoning,
            fullResponse: analysisText
          };
        } catch (error) {
          console.error('Error analyzing image quality:', error);
          return null;
        }
      };

      // Helper function to call Gemini API with logging
      const callGeminiAPIWithLogging = async (prompt, imageData = null, pageNumber = null) => {
        if (!authToken) {
          throw new Error('Authentication required');
        }

        const parts = [{ text: prompt }];

        if (imageData) {
          const base64Data = imageData.replace(/^data:image\/\w+;base64,/, '');
          const mimeType = imageData.match(/^data:(image\/\w+);base64,/) ?
            imageData.match(/^data:(image\/\w+);base64,/)[1] : 'image/png';

          parts.push({
            inlineData: {
              mimeType: mimeType,
              data: base64Data
            }
          });
        }

        const apiPayload = {
          model: 'gemini-2.5-flash-image',
          contents: [{ parts: parts }],
          safetySettings: [
            { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_ONLY_HIGH" },
            { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_ONLY_HIGH" },
            { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_ONLY_HIGH" },
            { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_ONLY_HIGH" }
          ]
        };

        // Log API call for admin debugging
        if (pageNumber !== null) {
          const apiCallLog = {
            endpoint: `${API_URL}/api/gemini`,
            method: 'POST',
            payload: JSON.parse(JSON.stringify(apiPayload)),
            timestamp: new Date().toISOString()
          };
          // Remove base64 data from log
          if (apiCallLog.payload.contents && apiCallLog.payload.contents[0].parts) {
            apiCallLog.payload.contents[0].parts = apiCallLog.payload.contents[0].parts.map(part => {
              if (part.inlineData) {
                return { inlineData: { mimeType: part.inlineData.mimeType, data: '[base64 image data]' } };
              }
              return part;
            });
          }
          setApiCalls(prev => ({ ...prev, [pageNumber]: apiCallLog }));
        }

        const response = await fetchWithTimeout(`${API_URL}/api/gemini`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${authToken}`
          },
          body: JSON.stringify(apiPayload)
        }, 120000); // 120 second timeout for Gemini API calls

        if (!response.ok) {
          const errorText = await response.text();
          throw new Error(`Gemini API Error: ${errorText}`);
        }

        const data = await response.json();

        if (!data.candidates || data.candidates.length === 0) {
          throw new Error('No response from Gemini API.');
        }

        const candidate = data.candidates[0];
        if (candidate.finishReason && candidate.finishReason !== 'STOP') {
          throw new Error(`Content generation blocked: ${candidate.finishReason}.`);
        }

        if (!candidate.content || !candidate.content.parts) {
          throw new Error('Invalid response structure from Gemini API.');
        }

        const responseParts = candidate.content.parts;
        for (const part of responseParts) {
          if (part.inlineData && part.inlineData.data) {
            return `data:image/png;base64,${part.inlineData.data}`;
          }
        }

        throw new Error('No image data found in Gemini response');
      };

      // Helper function to call Gemini API with multiple images
      const callGeminiAPIWithImages = async (prompt, imageDataArray, pageNumber = null) => {
        if (!authToken) {
          throw new Error('Authentication required');
        }

        const parts = [{ text: prompt }];

        // Add all images
        imageDataArray.forEach(imageData => {
          const base64Data = imageData.replace(/^data:image\/\w+;base64,/, '');
          const mimeType = imageData.match(/^data:(image\/\w+);base64,/) ?
            imageData.match(/^data:(image\/\w+);base64,/)[1] : 'image/png';

          parts.push({
            inlineData: {
              mimeType: mimeType,
              data: base64Data
            }
          });
        });

        const apiPayload = {
          model: 'gemini-2.5-flash-image',
          contents: [{ parts: parts }],
          safetySettings: [
            { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_ONLY_HIGH" },
            { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_ONLY_HIGH" },
            { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_ONLY_HIGH" },
            { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_ONLY_HIGH" }
          ]
        };

        // Log API call for admin debugging
        if (pageNumber !== null) {
          const apiCallLog = {
            endpoint: `${API_URL}/api/gemini`,
            method: 'POST',
            payload: JSON.parse(JSON.stringify(apiPayload)),
            timestamp: new Date().toISOString()
          };
          // Remove base64 data from log
          if (apiCallLog.payload.contents && apiCallLog.payload.contents[0].parts) {
            apiCallLog.payload.contents[0].parts = apiCallLog.payload.contents[0].parts.map(part => {
              if (part.inlineData) {
                return { inlineData: { mimeType: part.inlineData.mimeType, data: '[base64 image data]' } };
              }
              return part;
            });
          }
          setApiCalls(prev => ({ ...prev, [pageNumber]: apiCallLog }));
        }

        const response = await fetchWithTimeout(`${API_URL}/api/gemini`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${authToken}`
          },
          body: JSON.stringify(apiPayload)
        }, 120000); // 120 second timeout for Gemini API calls

        if (!response.ok) {
          const errorText = await response.text();
          throw new Error(`Gemini API Error: ${errorText}`);
        }

        const data = await response.json();

        if (!data.candidates || data.candidates.length === 0) {
          throw new Error('No response from Gemini API.');
        }

        const candidate = data.candidates[0];
        if (candidate.finishReason && candidate.finishReason !== 'STOP') {
          throw new Error(`Content generation blocked: ${candidate.finishReason}.`);
        }

        if (!candidate.content || !candidate.content.parts) {
          throw new Error('Invalid response structure from Gemini API.');
        }

        const responseParts = candidate.content.parts;
        for (const part of responseParts) {
          if (part.inlineData && part.inlineData.data) {
            return `data:image/png;base64,${part.inlineData.data}`;
          }
        }

        throw new Error('No image data found in Gemini response');
      };

      // Helper function to call Gemini API with previous scene image for sequential generation
      const callGeminiAPISequential = async (prompt, previousSceneImage, characterAvatars = [], pageNumber = null) => {
        if (!authToken) {
          throw new Error('Authentication required');
        }

        const parts = [{ text: prompt }];

        // Add PREVIOUS scene image FIRST (most important for continuity)
        if (previousSceneImage) {
          const base64Data = previousSceneImage.replace(/^data:image\/\w+;base64,/, '');
          const mimeType = previousSceneImage.match(/^data:(image\/\w+);base64,/) ?
            previousSceneImage.match(/^data:(image\/\w+);base64,/)[1] : 'image/png';

          parts.push({
            inlineData: {
              mimeType: mimeType,
              data: base64Data
            }
          });
        }

        // Then add character avatars
        characterAvatars.forEach(avatarUrl => {
          const base64Data = avatarUrl.replace(/^data:image\/\w+;base64,/, '');
          const mimeType = avatarUrl.match(/^data:(image\/\w+);base64,/) ?
            avatarUrl.match(/^data:(image\/\w+);base64,/)[1] : 'image/png';

          parts.push({
            inlineData: {
              mimeType: mimeType,
              data: base64Data
            }
          });
        });

        const apiPayload = {
          model: 'gemini-2.5-flash-image',
          contents: [{ parts: parts }],
          safetySettings: [
            { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_ONLY_HIGH" },
            { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_ONLY_HIGH" },
            { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_ONLY_HIGH" },
            { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_ONLY_HIGH" }
          ]
        };

        // Log API call for admin debugging
        if (pageNumber !== null) {
          const apiCallLog = {
            endpoint: `${API_URL}/api/gemini`,
            method: 'POST',
            mode: 'sequential',
            hasPreviousScene: !!previousSceneImage,
            avatarCount: characterAvatars.length,
            timestamp: new Date().toISOString()
          };
          setApiCalls(prev => ({ ...prev, [pageNumber]: apiCallLog }));
        }

        console.log(`ðŸ”— [Sequential] Generating page ${pageNumber} with ${previousSceneImage ? 'previous scene + ' : ''}${characterAvatars.length} avatar(s)`);

        const response = await fetchWithTimeout(`${API_URL}/api/gemini`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${authToken}`
          },
          body: JSON.stringify(apiPayload)
        }, 120000); // 120 second timeout

        if (!response.ok) {
          const errorText = await response.text();
          throw new Error(`Gemini API Error: ${errorText}`);
        }

        const data = await response.json();

        if (!data.candidates || data.candidates.length === 0) {
          throw new Error('No response from Gemini API.');
        }

        const candidate = data.candidates[0];
        if (candidate.finishReason && candidate.finishReason !== 'STOP') {
          throw new Error(`Content generation blocked: ${candidate.finishReason}.`);
        }

        if (!candidate.content || !candidate.content.parts) {
          throw new Error('Invalid response structure from Gemini API.');
        }

        const responseParts = candidate.content.parts;
        for (const part of responseParts) {
          if (part.inlineData && part.inlineData.data) {
            return `data:image/png;base64,${part.inlineData.data}`;
          }
        }

        throw new Error('No image data found in Gemini response');
      };

      // ========================================
      // HELPER FUNCTIONS - Extracted for clarity
      // ========================================

      // Toggle cover image edit mode
      const toggleCoverImageEdit = (coverType) => {
        setEditingCoverImage(editingCoverImage === coverType ? null : coverType);
        setCoverEditInstruction('');
      };

      // Apply cover image edit with new prompt
      const applyCoverImageEdit = async (coverType) => {
        if (!coverEditInstruction.trim()) {
          alert(language === 'de' ? 'Bitte geben Sie einen Prompt ein' :
                language === 'fr' ? 'Veuillez entrer un prompt' :
                'Please enter a prompt');
          return;
        }
        try {
          const newImage = await callGeminiAPI(coverEditInstruction);
          setCoverImages({...coverImages, [coverType]: newImage});
          setCoverImagePrompts({...coverImagePrompts, [coverType]: coverEditInstruction});
          setEditingCoverImage(null);
          setCoverEditInstruction('');
        } catch (error) {
          alert(`Error: ${error.message}`);
        }
      };

      // Regenerate a cover image with existing prompt and character avatars
      const regenerateCoverImage = async (coverType) => {
        const confirmMsg = language === 'de' ? `${coverType} neu generieren?` :
                          language === 'fr' ? `RÃ©gÃ©nÃ©rer ${coverType}?` :
                          `Regenerate ${coverType}?`;
        if (confirm(confirmMsg)) {
          try {
            const prompt = coverImagePrompts[coverType];

            // Collect avatar images from ALL characters with photos (same as original cover generation)
            // Use same priority as server: bodyNoBgUrl > bodyPhotoUrl > photoUrl
            const coverCharacterAvatars = characters
              .map(char => char.bodyNoBgUrl || char.bodyPhotoUrl || char.photoUrl)
              .filter(url => url);

            let newImageData;
            if (coverCharacterAvatars.length > 0) {
              // Send with avatar images for better consistency
              console.log(`Regenerating ${coverType} with ${coverCharacterAvatars.length} avatar(s)...`);
              newImageData = await callGeminiAPIWithImages(prompt, coverCharacterAvatars);
            } else {
              // Text-only if no avatars available
              console.log(`Regenerating ${coverType} with text-only prompt...`);
              newImageData = await callGeminiAPI(prompt);
            }

            // Analyze quality for admin
            let qualityAnalysis = null;
            if (currentUser && currentUser.role === 'admin' && newImageData) {
              qualityAnalysis = await analyzeImageQuality(newImageData, prompt, coverCharacterAvatars);
            }

            setCoverImages({
              ...coverImages,
              [coverType]: {
                imageData: newImageData,
                qualityScore: qualityAnalysis?.score || null,
                qualityReasoning: qualityAnalysis?.reasoning || null
              }
            });
          } catch (error) {
            alert(`Error: ${error.message}`);
          }
        }
      };

      // Toggle scene image edit mode
      const toggleSceneImageEdit = (index) => {
        if (editingImageIndex === index) {
          setEditingImageIndex(null);
          setImageEditInstruction('');
        } else {
          setEditingImageIndex(index);
          setImageEditInstruction('');
        }
      };

      // Smooth scroll to element by ID
      const smoothScrollToElement = (elementId, delay = 100) => {
        setTimeout(() => {
          const element = document.getElementById(elementId);
          if (element) {
            element.scrollIntoView({ behavior: 'smooth', block: 'start' });
          }
        }, delay);
      };

      // Reset all story state for "Create Another Story"
      const resetAllStoryState = () => {
        setStep(1);
        setGeneratedStory('');
        setGeneratedPrompt('');
        setShowPrompt(false);
        // DO NOT clear characters and relationships - they persist across stories
        // setCharacters([]);
        // setRelationships({});
        setStoryType('');
        setMainCharacters([]);
        setSceneDescriptions([]);
        setSceneImages([]);
        setEditableOutline('');
        setStoryOutline('');
        setStoryTitle('');
        setDedication('');
        setCoverImages({ frontCover: null, initialPage: null, backCover: null });
        setCoverImagePrompts({});
        setCurrentStoryId(null);
      };

      // Delete a saved story
      const deleteStory = async (storyId) => {
        const confirmMsg = language === 'de' ? 'Diese Geschichte lÃ¶schen?' :
                          language === 'fr' ? 'Supprimer cette histoire?' :
                          'Delete this story?';
        if (confirm(confirmMsg)) {
          try {
            const response = await fetch(`${API_URL}/api/stories/${storyId}`, {
              method: 'DELETE',
              headers: { 'Authorization': `Bearer ${authToken}` }
            });
            if (response.ok) {
              const updated = await loadStories();
              setSavedStories(updated);
            }
          } catch (err) {
            console.error('Error deleting story:', err);
          }
        }
      };

      // Add a custom story type
      const addCustomStoryType = () => {
        const promptMsg = language === 'de' ? 'Name des Story-Typs eingeben:' :
                         language === 'fr' ? 'Entrez le nom du type d\'histoire:' :
                         'Enter story type name:';
        const name = prompt(promptMsg);
        if (name) {
          const newType = {
            id: `custom-${Date.now()}`,
            name: { en: name, de: name, fr: name },
            emoji: 'âœ¨',
            isCustom: true
          };
          setCustomStoryTypes([...customStoryTypes, newType]);
          setStoryType(newType.id);
          smoothScrollToElement('art-style-section');
        }
      };

      // ========================================
      // END HELPER FUNCTIONS
      // ========================================

      const generateSceneImages = async () => {
        if (!Array.isArray(sceneDescriptions) || sceneDescriptions.length === 0) {
          alert(language === 'de' ? 'Bitte erstellen Sie zuerst Szenenbeschreibungen!' : language === 'fr' ? 'Veuillez d\'abord crÃ©er des descriptions de scÃ¨nes!' : 'Please create scene descriptions first!');
          return;
        }

        setIsGeneratingImages(true);
        setGenerationProgress({ current: 0, total: sceneDescriptions.length + mainCharacters.length, message: 'Generating character cartoons...' });

        try {
          // STEP 1: Generate base character cartoons for main characters (if not already generated)
          let cartoons = baseCharacterImages;
          if (mainCharacters.length > 0 && Object.keys(baseCharacterImages).length === 0) {
            console.log('Generating base character cartoons for main characters...');
            cartoons = await generateMainCharacterCartoons();
            setBaseCharacterImages(cartoons);
          }

          // Determine effective image generation mode
          const effectiveMode = imageGenMode || serverImageGenMode || 'sequential';
          const modeMessage = effectiveMode === 'sequential'
            ? 'Generating images sequentially (for consistency)...'
            : 'Generating images in parallel...';
          setGenerationProgress({ current: mainCharacters.length, total: sceneDescriptions.length + mainCharacters.length, message: modeMessage });

          const prompts = {}; // Store prompts for each image
          const characterClothing = {}; // Track clothing for consistency

          // Only generate images for the current number of pages
          const scenesToGenerate = sceneDescriptions.slice(0, pages);
          console.log(`Generating images for ${scenesToGenerate.length} scenes in ${effectiveMode} mode (pages: ${pages}, total scenes: ${sceneDescriptions.length})`);

          // Helper function to generate a single scene image
          const generateSingleSceneImage = async (scene, previousSceneImage = null, useSequentialMode = false) => {
            console.log(`Generating image for page ${scene.pageNumber}, scene description exists: ${!!scene.description}`);

            // Identify which characters are in THIS scene
            const charactersInScene = characters.filter(char =>
              scene.description.toLowerCase().includes(char.name.toLowerCase())
            );

            // Detect scene setting
            const sceneText = scene.description.toLowerCase();
            const isOutdoor = sceneText.includes('outside') || sceneText.includes('outdoor') ||
                            sceneText.includes('forest') || sceneText.includes('park') ||
                            sceneText.includes('garden') || sceneText.includes('street') ||
                            sceneText.includes('playground');
            const isIndoor = sceneText.includes('inside') || sceneText.includes('indoor') ||
                           sceneText.includes('room') || sceneText.includes('house') ||
                           sceneText.includes('kitchen') || sceneText.includes('bedroom');

            // Build character context - ONLY for characters in this scene
            let characterPrompts = '';

            if (charactersInScene.length > 0) {
              characterPrompts = '\n\nCHARACTER APPEARANCE GUIDE - Maintain EXACT consistency across all pages:\n\n';

              charactersInScene.forEach((char, idx) => {
                const age = parseInt(char.age) || 10;
                const isMainCharacter = mainCharacters.includes(char.id);

                // Initialize or update clothing based on scene setting
                if (!characterClothing[char.name]) {
                  // First appearance - use clothing from avatar if available
                  if (char.clothing) {
                    characterClothing[char.name] = char.clothing;
                    characterClothing[char.name + '_base'] = char.clothing;
                  } else {
                    // Fallback to default clothing
                    if (isOutdoor) {
                      characterClothing[char.name] = age < 13
                        ? 'blue jacket, jeans, red sneakers'
                        : 'gray jacket, dark pants, brown shoes';
                    } else {
                      characterClothing[char.name] = age < 13
                        ? 'casual outdoor clothes'
                        : 'casual indoor clothes';
                    }
                    characterClothing[char.name + '_base'] = characterClothing[char.name];
                  }
                } else {
                  // Character appeared before - check if clothing needs to change
                  const baseClothing = characterClothing[char.name + '_base'] || characterClothing[char.name];

                  if (isOutdoor && !characterClothing[char.name].includes('jacket') && !characterClothing[char.name].includes('coat')) {
                    // Going outside - add jacket/coat
                    characterClothing[char.name] = age < 13
                      ? `jacket over ${baseClothing}`
                      : `warm coat over ${baseClothing}`;
                  } else if (isIndoor && (characterClothing[char.name].includes('jacket') || characterClothing[char.name].includes('coat'))) {
                    // Going inside - remove jacket/coat (back to base)
                    characterClothing[char.name] = baseClothing;
                  }
                }

                // Build comprehensive character description
                const baseDescription = generateCharacterDescription(char);

                // Enhanced description with more detail
                characterPrompts += `[${char.name}] - ${isMainCharacter ? 'MAIN CHARACTER' : 'Supporting Character'}\n`;
                characterPrompts += `  â†’ ${baseDescription}\n`;
                characterPrompts += `  â†’ Wearing: ${characterClothing[char.name]}\n`;
                characterPrompts += `  â†’ This character must look IDENTICAL in every scene\n\n`;
              });

              characterPrompts += `\nCRITICAL: These characters must maintain PERFECT visual consistency across ALL pages. Use the exact same facial features, hair style, body proportions, and identifying characteristics every single time.`;
            }

            // Get the selected art style's prompt
            const selectedStyle = artStyles.find(s => s.id === artStyle) || artStyles[0];
            const styleDescription = selectedStyle.prompt;

            // Build image prompt with character consistency guide
            let imagePrompt = `Create a cinematic scene in ${styleDescription}.

Scene Description: ${scene.description}
${characterPrompts}`;

            // Add character consistency guide if available
            if (characterConsistencyGuide) {
              imagePrompt += characterConsistencyGuide;
            }

            // Add visual continuity instructions for sequential mode
            if (useSequentialMode && previousSceneImage) {
              imagePrompt += `\n\n**VISUAL CONTINUITY - CRITICAL:**
The FIRST attached image shows the PREVIOUS scene from this story. You MUST maintain:
- Exact same character appearances (faces, hair, body proportions, skin tone)
- Same clothing and accessories unless the scene explicitly mentions a change
- Consistent art style, lighting approach, and color palette
- Any recurring objects or background elements should look the same`;
            }

            imagePrompt += `\n\nImportant:
- Show only the emotions visible on faces (happy, sad, surprised, worried, excited)
- Keep clothing exactly as described
- Maintain consistent character appearance across ALL pages
- Clean, clear composition`;

            // Store the prompt for this image
            prompts[scene.pageNumber] = imagePrompt;

            try {
              // Collect avatar images for characters in this scene
              // Use same priority as server: bodyNoBgUrl > bodyPhotoUrl > photoUrl
              const characterAvatars = charactersInScene
                .map(char => char.bodyNoBgUrl || char.bodyPhotoUrl || char.photoUrl)
                .filter(url => url);

              const safePrompt = `CHILDREN'S BOOK ILLUSTRATION - Safe, family-friendly content.

${imagePrompt}

IMPORTANT: This is a wholesome children's storybook illustration. All content is innocent and age-appropriate.`;

              let imageData;

              if (useSequentialMode && previousSceneImage) {
                // Sequential mode - pass previous scene image for consistency
                console.log(`Page ${scene.pageNumber}: Generating with previous scene + ${characterAvatars.length} avatar(s) (SEQUENTIAL)...`);
                imageData = await callGeminiAPISequential(safePrompt, previousSceneImage, characterAvatars, scene.pageNumber);
              } else if (characterAvatars.length > 0) {
                // Parallel mode with avatars
                console.log(`Page ${scene.pageNumber}: Generating with ${characterAvatars.length} avatar(s) for consistency...`);
                imageData = await callGeminiAPIWithImages(safePrompt, characterAvatars, scene.pageNumber);
              } else {
                // Text-only if no avatars available
                console.log(`Page ${scene.pageNumber}: Generating with text-only prompt...`);
                imageData = await callGeminiAPIWithLogging(safePrompt, null, scene.pageNumber);
              }
              console.log(`Page ${scene.pageNumber}: Success!`);

              // Analyze image quality (admin feature)
              let qualityAnalysis = null;
              if (currentUser && currentUser.role === 'admin' && imageData) {
                console.log(`Page ${scene.pageNumber}: Analyzing quality...`);
                qualityAnalysis = await analyzeImageQuality(imageData, imagePrompt, characterAvatars);
                if (qualityAnalysis) {
                  console.log(`Page ${scene.pageNumber}: Quality score: ${qualityAnalysis.score}/100`);
                }
              }

              return {
                pageNumber: scene.pageNumber,
                imageData: imageData,
                description: scene.description,
                qualityScore: qualityAnalysis?.score || null,
                qualityReasoning: qualityAnalysis?.reasoning || null
              };
            } catch (error) {
              console.error(`Error generating image for page ${scene.pageNumber}:`, error);
              return {
                pageNumber: scene.pageNumber,
                imageData: null,
                error: error.message
              };
            }
          };

          // Generate images based on mode
          let images;

          if (effectiveMode === 'sequential') {
            // SEQUENTIAL MODE: Generate one at a time, passing previous image for consistency
            console.log('ðŸ”— Starting SEQUENTIAL image generation for better consistency...');
            images = [];
            let previousImage = null;

            for (let i = 0; i < scenesToGenerate.length; i++) {
              const scene = scenesToGenerate[i];
              setGenerationProgress({
                current: mainCharacters.length + i + 1,
                total: sceneDescriptions.length + mainCharacters.length,
                message: `Generating image ${i + 1} of ${scenesToGenerate.length} (sequential)...`
              });

              const result = await generateSingleSceneImage(scene, previousImage, true);
              images.push(result);

              // Pass successful image to next scene
              if (result.imageData) {
                previousImage = result.imageData;
              }
            }
          } else {
            // PARALLEL MODE: Generate all at once (faster but less consistent)
            console.log('âš¡ Starting PARALLEL image generation for speed...');
            const imagePromises = scenesToGenerate.map(scene => generateSingleSceneImage(scene, null, false));
            images = await Promise.all(imagePromises);
          }

          setSceneImages(images);
          setImagePrompts(prompts); // Save the prompts

          // Generate cover images in parallel
          console.log('Generating 3 cover images...');
          const selectedStyle = artStyles.find(s => s.id === artStyle) || artStyles[0];
          const styleDescription = selectedStyle.prompt;

          // Build character information for cover images with main character emphasis
          const coverCharacterImages = [];
          const coverCharacterImageMap = [];
          let characterInfo = '';

          if (characters.length > 0) {
            // Separate main characters from supporting characters
            const mainChars = characters.filter(c => mainCharacters.includes(c.id));
            const supportingChars = characters.filter(c => !mainCharacters.includes(c.id));

            characterInfo = '\n\n**MAIN CHARACTER(S) - Must be prominently featured in the CENTER of the image:**\n';

            // List main characters first with emphasis
            // Use same priority as server: bodyNoBgUrl > bodyPhotoUrl > photoUrl
            mainChars.forEach((char) => {
              const charPhoto = char.bodyNoBgUrl || char.bodyPhotoUrl || char.photoUrl;
              const imageRef = charPhoto ? ` [Reference Image ${coverCharacterImages.length + 1}]` : '';
              const physicalDesc = generateCharacterDescription(char);
              characterInfo += `â­ MAIN: ${physicalDesc}${imageRef}\n`;

              if (charPhoto) {
                coverCharacterImages.push(charPhoto);
                coverCharacterImageMap.push({ name: char.name, imageIndex: coverCharacterImages.length, isMain: true });
              }
            });

            // Then list supporting characters
            if (supportingChars.length > 0) {
              characterInfo += '\n**Supporting characters (can appear in background or sides):**\n';
              supportingChars.forEach((char) => {
                const charPhoto = char.bodyNoBgUrl || char.bodyPhotoUrl || char.photoUrl;
                const imageRef = charPhoto ? ` [Reference Image ${coverCharacterImages.length + 1}]` : '';
                const physicalDesc = generateCharacterDescription(char);
                characterInfo += `Supporting: ${physicalDesc}${imageRef}\n`;

                if (charPhoto) {
                  coverCharacterImages.push(charPhoto);
                  coverCharacterImageMap.push({ name: char.name, imageIndex: coverCharacterImages.length, isMain: false });
                }
              });
            }

            // Add image reference explanation if we have character images
            if (coverCharacterImageMap.length > 0) {
              characterInfo += '\n**CHARACTER REFERENCE IMAGES:**\n';
              coverCharacterImageMap.forEach((mapping) => {
                const mainLabel = mapping.isMain ? ' (MAIN - center of image)' : ' (supporting)';
                characterInfo += `- Image ${mapping.imageIndex}: ${mapping.name}'s portrait${mainLabel}\n`;
              });
            }

            characterInfo += '\n**CRITICAL: Main character(s) must be the LARGEST and most CENTRAL figures in the composition.**\n';
          }

          // Use scene descriptions from outline if available, otherwise use defaults
          const titlePageScene = coverSceneDescriptions.titlePage || `A beautiful, magical title page featuring the main characters. Decorative elements that reflect the story's theme with space for the title text.`;
          const initialPageScene = coverSceneDescriptions.initialPage || `A warm, inviting dedication/introduction page that sets the mood and welcomes readers.`;
          const backCoverScene = coverSceneDescriptions.backCover || `A satisfying, conclusive ending scene that provides closure and leaves readers with a warm feeling.`;

          // Define cover image prompts with scene descriptions from outline
          const frontCoverPrompt = `${titlePageScene}\n\nStyle: ${styleDescription}.${characterInfo}\n\nCreate this as a beautiful title page illustration for the children's book "${storyTitle}".\n\nIMPORTANT: The image should include the story title "${storyTitle}" integrated beautifully into the illustration. Make the title prominent and visually appealing as part of the cover art.`;
          const initialPagePrompt = dedication && dedication.trim()
            ? `${initialPageScene}\n\nStyle: ${styleDescription}.${characterInfo}\n\nCRITICAL: Include ONLY this exact text in the image: "${dedication}"\n\nDo not add any other text. Only "${dedication}" must appear. No additional words allowed.`
            : `${initialPageScene}\n\nStyle: ${styleDescription}.${characterInfo}\n\nCreate this as an introduction page for "${storyTitle}".\n\nIMPORTANT: This image should contain NO TEXT at all - create a purely visual, atmospheric illustration that sets the mood for the story.`;
          const backCoverPrompt = `${backCoverScene}\n\nStyle: ${styleDescription}.${characterInfo}\n\nCRITICAL: Include ONLY this exact text in the image: "magicalstory.ch" in elegant letters in the bottom left corner.\n\nDo not add any other text. Only "magicalstory.ch" must appear. No additional words allowed.`;

          // Define detailed cover scene descriptions for display
          const coverDescriptions = {
            frontCover: `**Title Page / Front Cover**\n\n${titlePageScene}`,
            initialPage: `**Initial Page - Dedication/Introduction**\n\n${initialPageScene}`,
            backCover: `**Back Cover**\n\n${backCoverScene}`
          };

          const generateCoverImage = async (coverType, prompt, charImages = []) => {
            try {
              let imageData = null;

              // If we have character images, use multi-part API call
              if (charImages.length > 0) {
                const parts = [{ text: prompt }];

                charImages.forEach(charImage => {
                  const base64Data = charImage.replace(/^data:image\/\w+;base64,/, '');
                  const mimeType = charImage.match(/^data:(image\/\w+);base64,/) ?
                    charImage.match(/^data:(image\/\w+);base64,/)[1] : 'image/png';

                  parts.push({
                    inlineData: {
                      mimeType: mimeType,
                      data: base64Data
                    }
                  });
                });

                const apiPayload = {
                  model: 'gemini-2.5-flash-image',
                  contents: [{ parts }],
                  safetySettings: [
                    { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_ONLY_HIGH" },
                    { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_ONLY_HIGH" },
                    { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_ONLY_HIGH" },
                    { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_ONLY_HIGH" }
                  ]
                };

                const response = await fetchWithTimeout(`${API_URL}/api/gemini`, {
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${localStorage.getItem('auth_token')}`
                  },
                  body: JSON.stringify(apiPayload)
                });

                if (!response.ok) throw new Error(`API Error: ${response.status}`);

                const data = await response.json();
                if (!data.candidates || data.candidates.length === 0) {
                  throw new Error("No response from Gemini.");
                }

                const candidate = data.candidates[0];
                if (candidate.finishReason && candidate.finishReason !== 'STOP') {
                  throw new Error(`Content blocked: ${candidate.finishReason}.`);
                }

                if (!candidate.content || !candidate.content.parts) {
                  throw new Error("Invalid response from Gemini.");
                }

                const responseParts = candidate.content.parts;
                for (const part of responseParts) {
                  if (part.inlineData && part.inlineData.data) {
                    imageData = `data:image/png;base64,${part.inlineData.data}`;
                    break;
                  }
                }

                if (!imageData) throw new Error("No image data found in response.");
              } else {
                // No character images, use simple text-only API call
                imageData = await callGeminiAPI(prompt);
              }

              // Analyze image quality
              const analysis = await analyzeImageQuality(imageData, prompt, charImages);

              return {
                imageData,
                qualityScore: analysis?.score || null,
                qualityReasoning: analysis?.reasoning || null
              };
            } catch (error) {
              console.error(`Error generating ${coverType} cover:`, error);
              return null;
            }
          };

          const coverPromises = [
            generateCoverImage('frontCover', frontCoverPrompt, coverCharacterImages),
            generateCoverImage('initialPage', initialPagePrompt, coverCharacterImages),
            generateCoverImage('backCover', backCoverPrompt, coverCharacterImages)
          ];

          const [frontCover, initialPage, backCover] = await Promise.all(coverPromises);

          // Store cover image prompts
          setCoverImagePrompts({
            frontCover: frontCoverPrompt,
            initialPage: initialPagePrompt,
            backCover: backCoverPrompt
          });

          // Store cover image API calls for debugging
          setCoverImageApiCalls({
            frontCover: { type: 'image', model: 'gemini-2.0-flash-exp', prompt: frontCoverPrompt },
            initialPage: { type: 'image', model: 'gemini-2.0-flash-exp', prompt: initialPagePrompt },
            backCover: { type: 'image', model: 'gemini-2.0-flash-exp', prompt: backCoverPrompt }
          });

          setCoverImages({
            frontCover,
            initialPage,
            backCover,
            descriptions: coverDescriptions
          });
          console.log('Cover images generated with full scene descriptions and prompts stored');

          setGenerationProgress({ current: scenesToGenerate.length, total: scenesToGenerate.length, message: 'All images generated!' });
        } catch (error) {
          console.error('Error generating images:', error);
          alert(`Error generating images: ${error.message}\n\nPlease check your Gemini API key and try again!`);
        } finally {
          setIsGeneratingImages(false);
          setTimeout(() => setGenerationProgress({ current: 0, total: 0, message: '' }), 2000);
        }
      };

      // Helper function to generate a single avatar variant
      const generateSingleAvatar = async (referenceImage, prompt) => {
        const base64Data = referenceImage.replace(/^data:image\/\w+;base64,/, '');
        const mimeType = referenceImage.match(/^data:(image\/\w+);base64,/) ?
          referenceImage.match(/^data:(image\/\w+);base64,/)[1] : 'image/png';

        // Call backend API endpoint which has the Gemini API key
        const response = await fetchWithTimeout(`${API_URL}/api/gemini`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${localStorage.getItem('auth_token')}`
          },
          body: JSON.stringify({
            model: 'gemini-2.5-flash-image',
            contents: [{
              parts: [
                { text: prompt },
                { inlineData: { mimeType: mimeType, data: base64Data } }
              ]
            }],
            safetySettings: [
              { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_NONE" },
              { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_NONE" },
              { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_NONE" },
              { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_NONE" }
            ]
          })
        });

        if (!response.ok) {
          const errorText = await response.text();
          throw new Error(`Gemini API Error: ${response.status} - ${errorText}`);
        }

        const data = await response.json();

        if (!data.candidates || data.candidates.length === 0) {
          console.error('Gemini API response:', data);
          throw new Error("No response from Gemini.");
        }

        const candidate = data.candidates[0];
        if (candidate.finishReason && candidate.finishReason !== 'STOP') {
          console.error('Gemini blocked content:', candidate);
          throw new Error(`Content blocked: ${candidate.finishReason}.`);
        }

        if (!candidate.content || !candidate.content.parts) {
          console.error('Invalid response structure:', candidate);
          throw new Error("Invalid response from Gemini.");
        }

        const parts = candidate.content.parts;
        for (const part of parts) {
          if (part.inlineData && part.inlineData.data) {
            return `data:image/png;base64,${part.inlineData.data}`;
          }
        }

        throw new Error("No image data found in response.");
      };

      const generateAvatar = async (referenceImage) => {
        setIsGeneratingAvatar(true);
        setGeneratedAvatar(null);
        setGeneratedAvatars([]);

        try {
          // Get the selected art style's prompt
          const selectedStyle = artStyles.find(s => s.id === artStyle) || artStyles[0];
          const baseStyle = selectedStyle.prompt;

          // Use same prompt for all 3 variants - AI will naturally create variations
          const avatarPromptText = `Create an upper body portrait of this person in ${baseStyle}. Show the person from waist up, including their clothing and upper body, with a friendly, pleasant expression. Maintain their age, gender, distinctive facial features, and clothing style.`;

          // Generate all 3 variants in parallel (much faster!)
          setGenerationProgress({
            current: 1,
            total: 3,
            message: `Generating 3 avatar variants in parallel...`
          });

          // Create 3 promises for parallel generation
          const generationPromises = Array.from({ length: 3 }, async (_, i) => {
            const avatarImage = await generateSingleAvatar(referenceImage, avatarPromptText);
            const traits = await analyzeImageForTraits(avatarImage);

            return {
              type: `Variant ${i + 1}`,
              image: avatarImage,
              traits: traits,
              prompt: avatarPromptText
            };
          });

          // Wait for all 3 to complete
          const generatedVariants = await Promise.all(generationPromises);

          setGeneratedAvatars(generatedVariants);
          setAvatarPrompt(avatarPromptText); // Store prompt for reference
          setGenerationProgress({ current: 3, total: 3, message: 'All avatars generated!' });

        } catch (error) {
          console.error('Avatar Generation Error:', error);
          alert(`Error generating avatar: ${error.message}`);
          setGeneratedAvatars([]);
        } finally {
          setIsGeneratingAvatar(false);
          setTimeout(() => setGenerationProgress({ current: 0, total: 0, message: '' }), 2000);
        }
      };

      const editImage = async (currentImage, editInstruction) => {
        try {
          const base64Data = currentImage.replace(/^data:image\/\w+;base64,/, '');
          const mimeType = currentImage.match(/^data:(image\/\w+);base64,/) ?
            currentImage.match(/^data:(image\/\w+);base64,/)[1] : 'image/png';

          const finalPrompt = `Edit this scene: ${editInstruction}. Maintain the same 3D Pixar/Disney animation style, character appearances, and overall art style.`;

          // Call backend API endpoint which has the Gemini API key
          const response = await fetchWithTimeout(`${API_URL}/api/gemini`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${localStorage.getItem('auth_token')}`
            },
            body: JSON.stringify({
              model: 'gemini-2.5-flash-image',
              contents: [{
                parts: [
                  {
                    text: finalPrompt,
                  },
                  {
                    inlineData: {
                      mimeType: mimeType,
                      data: base64Data,
                    },
                  },
                ],
              }],
              safetySettings: [
                { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_ONLY_HIGH" },
                { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_ONLY_HIGH" },
                { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_ONLY_HIGH" },
                { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_ONLY_HIGH" }
              ]
            })
          });

          if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Image editing failed: ${response.status} - ${errorText}`);
          }

          const data = await response.json();

          if (!data.candidates || data.candidates.length === 0) {
            console.error('Gemini API response:', data);
            throw new Error("No response from Gemini. The content may have been blocked for safety reasons.");
          }

          // Check for safety blocks or other finish reasons
          const candidate = data.candidates[0];
          if (candidate.finishReason && candidate.finishReason !== 'STOP') {
            console.error('Gemini blocked content:', candidate);
            throw new Error(`Content blocked: ${candidate.finishReason}. Try adjusting your edit instruction.`);
          }

          if (!candidate.content || !candidate.content.parts) {
            console.error('Invalid response structure:', candidate);
            throw new Error("Invalid response from Gemini. Content may have been filtered.");
          }

          const parts = candidate.content.parts;
          for (const part of parts) {
            if (part.inlineData && part.inlineData.data) {
              return `data:image/png;base64,${part.inlineData.data}`;
            }
          }

          throw new Error("No image data found in response.");
        } catch (error) {
          console.error('Image Editing Error:', error);
          throw error;
        }
      };

      const analyzeImageForTraits = async (imageData) => {
        try {
          console.log('ðŸ” Analyzing photo with Gemini API...');

          // Use Gemini API directly for feature extraction
          return await analyzeImageForTraitsGemini(imageData);
        } catch (error) {
          console.error('Error analyzing image:', error);
          return null;
        }
      };

      // Gemini-based character photo analysis
      const analyzeImageForTraitsGemini = async (imageData) => {
        try {
          const base64Data = imageData.replace(/^data:image\/\w+;base64,/, '');
          const mimeType = imageData.match(/^data:(image\/\w+);base64,/) ?
            imageData.match(/^data:(image\/\w+);base64,/)[1] : 'image/png';

          // Call backend API endpoint which has the Gemini API key
          const response = await fetchWithTimeout(`${API_URL}/api/gemini`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${localStorage.getItem('auth_token')}`
            },
            body: JSON.stringify({
              model: 'gemini-2.0-flash-exp',
              contents: [{
                parts: [
                  {
                    text: `Analyze this image of a person. Detect bounding boxes for the face and full body, and describe physical attributes.

Return a JSON object with this exact structure:
{
  "attributes": {
    "age": <number>,
    "height_cm": <number>,
    "build": "<slim|average|athletic|chubby|overweight>",
    "hair": "<color and style>",
    "clothing": "<description>",
    "features": "<eye color, glasses, distinctive features>"
  },
  "detections": [
    {"label": "face", "box_2d": [ymin, xmin, ymax, xmax]},
    {"label": "body", "box_2d": [ymin, xmin, ymax, xmax]}
  ]
}

IMPORTANT for box_2d coordinates:
- Use normalized coordinates from 0 to 1000
- 0 = top/left edge, 1000 = bottom/right edge
- Format: [ymin, xmin, ymax, xmax]
- Face box should tightly contain the face (forehead to chin)
- Body box should contain the entire visible person from head to lowest visible point

Return ONLY valid JSON, no markdown or other text.`
                  },
                  {
                    inlineData: {
                      mimeType: mimeType,
                      data: base64Data,
                    },
                  },
                ],
              }]
            })
          });

          if (!response.ok) {
            console.error('Image analysis failed');
            return null;
          }

          const data = await response.json();

          if (data.candidates && data.candidates[0]) {
            const analysisText = data.candidates[0].content.parts[0].text;
            console.log('Image analysis raw:', analysisText);

            // Initialize traits object
            const traits = {
              age: '',
              height: '',
              build: '',
              hairColor: '',
              clothing: '',
              otherFeatures: '',
              faceBox: null,
              bodyBox: null,
              fullText: analysisText
            };

            // Try to parse as JSON (new format)
            try {
              // Remove markdown code blocks if present
              let jsonText = analysisText.trim();
              if (jsonText.startsWith('```json')) {
                jsonText = jsonText.slice(7);
              } else if (jsonText.startsWith('```')) {
                jsonText = jsonText.slice(3);
              }
              if (jsonText.endsWith('```')) {
                jsonText = jsonText.slice(0, -3);
              }
              jsonText = jsonText.trim();

              const parsed = JSON.parse(jsonText);
              console.log('ðŸ“¦ Parsed JSON:', parsed);

              // Extract attributes
              if (parsed.attributes) {
                const attr = parsed.attributes;
                if (attr.age) traits.age = String(attr.age);
                if (attr.height_cm) traits.height = String(attr.height_cm);
                if (attr.build) traits.build = attr.build.toLowerCase();
                if (attr.hair) traits.hairColor = attr.hair;
                if (attr.clothing) traits.clothing = attr.clothing;
                if (attr.features) traits.otherFeatures = attr.features;
              }

              // Extract bounding boxes - format is [ymin, xmin, ymax, xmax] with values 0-1000
              if (parsed.detections && Array.isArray(parsed.detections)) {
                for (const detection of parsed.detections) {
                  if (detection.box_2d && Array.isArray(detection.box_2d) && detection.box_2d.length === 4) {
                    const [ymin, xmin, ymax, xmax] = detection.box_2d;

                    // Convert from [ymin, xmin, ymax, xmax] (0-1000) to {x, y, width, height} (0-100 percentage)
                    const box = {
                      x: xmin / 10,      // Convert 0-1000 to 0-100
                      y: ymin / 10,
                      width: (xmax - xmin) / 10,
                      height: (ymax - ymin) / 10
                    };

                    // Validate
                    if (box.x >= 0 && box.y >= 0 && box.width > 0 && box.height > 0 &&
                        box.x + box.width <= 100 && box.y + box.height <= 100) {
                      if (detection.label === 'face') {
                        traits.faceBox = box;
                        console.log('ðŸ“¦ Face box:', box);
                      } else if (detection.label === 'body') {
                        traits.bodyBox = box;
                        console.log('ðŸ“¦ Body box:', box);
                      }
                    } else {
                      console.warn('âš ï¸ Invalid box coordinates:', detection.label, box);
                    }
                  }
                }
              }
            } catch (jsonError) {
              console.warn('Failed to parse as JSON, trying regex fallback:', jsonError);

              // Fallback to regex parsing for old format
              const ageMatch = analysisText.match(/age["\s:]+(\d+)/i);
              if (ageMatch) traits.age = ageMatch[1];

              const heightMatch = analysisText.match(/height[_\s]*cm["\s:]+(\d+)/i);
              if (heightMatch) traits.height = heightMatch[1];

              const buildMatch = analysisText.match(/build["\s:]+["']?(\w+)/i);
              if (buildMatch) traits.build = buildMatch[1].trim().toLowerCase();
            }

            return traits;
          }

          return null;
        } catch (error) {
          console.error('Error analyzing image:', error);
          return null;
        }
      };

      // Python MediaPipe-based character photo analysis (runs locally, free)
      const analyzeImageWithPython = async (imageData) => {
        try {
          console.log('ðŸ Analyzing photo with Python MediaPipe API...');

          // Use the proxy endpoint through the Node.js server (works on Railway)
          const response = await fetchWithTimeout(`${API_URL}/api/analyze-photo`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${authToken}`
            },
            body: JSON.stringify({
              imageData: imageData
            })
          }, 30000); // 30 second timeout for Python processing

          if (!response.ok) {
            console.error('Python API analysis failed:', response.status);
            return null;
          }

          const data = await response.json();
          console.log('ðŸ Python API response:', data);

          if (data.success) {
            return {
              // Attributes from DeepFace
              age: data.attributes?.age ? String(data.attributes.age) : '',
              gender: data.attributes?.gender || '',
              height: data.attributes?.height ? String(data.attributes.height) : '',
              build: data.attributes?.build || '',
              // Bounding boxes from MediaPipe (already in 0-100% format)
              faceBox: data.face_box || null,
              bodyBox: data.body_box || null,
              // Pre-cropped images
              faceThumbnail: data.face_thumbnail || null,
              bodyCrop: data.body_crop || null,
              bodyNoBg: data.body_no_bg || null,  // Body with background removed (for image generation)
              // Source identifier
              source: 'python-mediapipe',
              // Raw response for debugging
              rawResponse: data
            };
          }

          return null;
        } catch (error) {
          console.error('Error with Python API:', error);
          return null;
        }
      };

      // Analyze image with both APIs in parallel (for dev mode comparison)
      const analyzeImageWithBothAPIs = async (imageData) => {
        console.log('ðŸ”„ Running both Gemini and Python analysis in parallel...');

        const [geminiResult, pythonResult] = await Promise.allSettled([
          analyzeImageForTraitsGemini(imageData),
          analyzeImageWithPython(imageData)
        ]);

        return {
          gemini: geminiResult.status === 'fulfilled' ? geminiResult.value : null,
          python: pythonResult.status === 'fulfilled' ? pythonResult.value : null
        };
      };

      const downloadImage = (imageData, pageNumber) => {
        try {
          const link = document.createElement('a');
          link.href = imageData;
          link.download = `scene-page-${pageNumber}-${Date.now()}.png`;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
        } catch (error) {
          console.error('Download error:', error);
          alert('Download error: ' + error.message);
        }
      };

      const downloadPrompt = () => {
        try {
          const promptTitle = `Prompt - ${storyTypes.find(t => t.id === storyType)?.name[language] || 'Story'} - ${new Date().toLocaleDateString()}`;
          const blob = new Blob([generatedPrompt], { type: 'text/plain;charset=utf-8' });
          const url = URL.createObjectURL(blob);
          const link = document.createElement('a');
          link.href = url;
          link.download = `${promptTitle}.txt`;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          URL.revokeObjectURL(url);
        } catch (error) {
          console.error('Download error:', error);
          alert('Download error: ' + error.message);
        }
      };

      const downloadStory = (format) => {
        try {
          const storyTitle = `${storyTypes.find(t => t.id === storyType)?.name[language] || 'Story'} - ${new Date().toLocaleDateString()}`;

          if (format === 'txt') {
            const blob = new Blob([generatedStory], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `${storyTitle}.txt`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
          } else if (format === 'pdf') {
            const printWindow = window.open('', '_blank', 'width=800,height=600');
            if (printWindow) {
              const htmlContent = `<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>${storyTitle}</title>
    <style>
      body { font-family: Arial, sans-serif; padding: 40px; line-height: 1.6; }
      h1 { color: #7c3aed; margin-bottom: 20px; }
      p { margin-bottom: 10px; white-space: pre-wrap; }
    </style>
  </head>
  <body>
    <h1>${storyTitle}</h1>
    <p>${generatedStory.replace(/\n/g, '<br>')}</p>
  </body>
</html>`;
              printWindow.document.write(htmlContent);
              printWindow.document.close();
              setTimeout(() => {
                printWindow.print();
              }, 500);
            } else {
              alert(language === 'de' ? 'Popup blockiert. Bitte erlauben Sie Popups.' : language === 'fr' ? 'Popup bloquÃ©. Veuillez autoriser les popups.' : 'Popup blocked. Please allow popups.');
            }
          }
        } catch (error) {
          console.error('Download error:', error);
          alert('Download error: ' + error.message);
        }
      };

      const downloadPrintablePDF = async () => {
        try {
          const storyTitle = `${storyTypes.find(t => t.id === storyType)?.name[language] || 'Story'}`;
          // Parse story pages - handle both formats:
          // - Markdown format: ## Seite 1 or ## Page 1
          // - Old format: --- Page 1 --- or --- Seite 1 ---
          const pageMatches = generatedStory ? generatedStory.split(/(?:---\s*(?:Page|Seite)\s+\d+\s*---|##\s*(?:Page|Seite)\s+\d+)/i) : [];
          const storyPages = pageMatches.slice(1).filter(p => p.trim().length > 0);

          // Check if this is a Picture Book (1st-grade level)
          const isPictureBook = languageLevel === '1st-grade';

          // Create a temporary container for PDF generation
          const tempContainer = document.createElement('div');
          tempContainer.style.position = 'absolute';
          tempContainer.style.left = '-9999px';
          tempContainer.style.top = '0';
          document.body.appendChild(tempContainer);

          // Build HTML content for PDF
          let htmlContent = `
            <div style="font-family: 'Georgia', 'Times New Roman', serif; font-size: 14pt; line-height: 1.6;">
          `;

          if (isPictureBook) {
            // Picture Book Layout: Image on top, text below - both on same page
            storyPages.forEach((pageText, index) => {
              const pageNumber = index + 1;
              const image = sceneImages.find(img => img.pageNumber === pageNumber);

              htmlContent += `
                <div style="width: 210mm; height: 297mm; display: flex; flex-direction: column; background: white; page-break-after: always; padding: 8mm; box-sizing: border-box;">
                  <!-- Image takes ~90% of page height -->
                  <div style="flex: 9; display: flex; justify-content: center; align-items: center; padding: 3mm;">
                    ${image && image.imageData
                      ? `<img src="${image.imageData}" style="max-width: 100%; max-height: 100%; object-fit: contain; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15);" />`
                      : `<div style="width: 100%; height: 100%; background: #f3f4f6; border-radius: 8px; display: flex; align-items: center; justify-content: center; color: #9ca3af;">No image</div>`
                    }
                  </div>
                  <!-- Text takes ~10% of page height -->
                  <div style="flex: 1; display: flex; justify-content: center; align-items: center; padding: 5mm 10mm; background: #eef2ff; border-radius: 8px; margin-top: 3mm;">
                    <div style="text-align: center; white-space: pre-wrap; max-width: 100%; font-size: 14pt; line-height: 1.5; color: #333;">
                      ${pageText.trim()}
                    </div>
                  </div>
                </div>
              `;
            });
          } else {
            // Standard Layout: Alternate between text and image pages (text left, image right when printed as book)
            storyPages.forEach((pageText, index) => {
              const pageNumber = index + 1;
              const image = sceneImages.find(img => img.pageNumber === pageNumber);

              // Text page
              htmlContent += `
                <div style="width: 210mm; height: 210mm; display: flex; justify-content: center; align-items: center; padding: 8mm 20mm; background: #fffef8; page-break-after: always;">
                  <div style="text-align: center; white-space: pre-wrap; max-width: 100%; font-size: 14pt; line-height: 1.8; color: #333;">
                    ${pageText.trim()}
                  </div>
                </div>
              `;

              // Image page
              if (image && image.imageData) {
                htmlContent += `
                  <div style="width: 210mm; height: 210mm; display: flex; justify-content: center; align-items: center; background: white; page-break-after: always; padding: 10mm;">
                    <img src="${image.imageData}" style="width: 100%; height: 100%; object-fit: contain; border-radius: 8px;" />
                  </div>
                `;
              }
            });
          }

          htmlContent += '</div>';
          tempContainer.innerHTML = htmlContent;

          // Configure PDF options - A4 for Picture Book, square for standard
          const opt = {
            margin: 0,
            filename: `${storyTitle}.pdf`,
            image: { type: 'jpeg', quality: 0.98 },
            html2canvas: { scale: 2, useCORS: true },
            jsPDF: {
              unit: 'mm',
              format: isPictureBook ? 'a4' : [210, 210],
              orientation: 'portrait'
            }
          };

          // Generate and download PDF
          await html2pdf().set(opt).from(tempContainer).save();

          // Clean up - Add delay to ensure html2pdf finishes all async operations (Safari compatibility)
          setTimeout(() => {
            try {
              if (tempContainer && tempContainer.parentNode) {
                document.body.removeChild(tempContainer);
              }
            } catch (e) {
              console.warn('PDF cleanup warning:', e);
            }
          }, 100);
        } catch (error) {
          console.error('PDF export error:', error);
          alert('PDF export error: ' + error.message);
        }
      };

      const orderPrintedBook = async () => {
        try {
          // Check if story has all required content
          if (!generatedStory || sceneImages.length === 0) {
            alert(language === 'de'
              ? 'Bitte generieren Sie zuerst die Geschichte und Bilder'
              : language === 'fr'
              ? 'Veuillez d\'abord gÃ©nÃ©rer l\'histoire et les images'
              : 'Please generate the story and images first');
            return;
          }

          // Check minimum page count for printing
          // Minimum 28 print pages (covers NOT counted by print provider)
          const minimumPrintPages = 28;
          const isPictureBook = languageLevel === '1st-grade';
          // For Picture Book: pages = print pages (1 scene per page)
          // For Standard: pages = print pages (already includes text + image pages)
          const printPages = pages;

          if (printPages < minimumPrintPages) {
            alert(language === 'de'
              ? `Gedruckte BÃ¼cher benÃ¶tigen mindestens ${minimumPrintPages} Seiten. Ihre Geschichte hat ${printPages} Seiten.\n\nBitte erstellen Sie eine neue Geschichte mit mindestens ${minimumPrintPages} Seiten oder laden Sie die Geschichte als PDF herunter.`
              : language === 'fr'
              ? `Les livres imprimÃ©s nÃ©cessitent au moins ${minimumPrintPages} pages. Votre histoire a ${printPages} pages.\n\nVeuillez crÃ©er une nouvelle histoire avec au moins ${minimumPrintPages} pages ou tÃ©lÃ©charger l'histoire en PDF.`
              : `Printed books require at least ${minimumPrintPages} pages. Your story has ${printPages} pages.\n\nPlease create a new story with at least ${minimumPrintPages} pages or download the story as PDF.`);
            return;
          }

          // Load saved shipping info from database
          try {
            const response = await fetch(`${API_URL}/api/user/shipping-address`, {
              headers: { 'Authorization': `Bearer ${authToken}` }
            });

            if (response.ok) {
              const savedShipping = await response.json();
              if (savedShipping) {
                setShippingForm({
                  firstName: savedShipping.firstName || '',
                  lastName: savedShipping.lastName || '',
                  addressLine1: savedShipping.addressLine1 || '',
                  city: savedShipping.city || '',
                  postCode: savedShipping.postCode || '',
                  country: 'CH', // Always use Switzerland
                  email: savedShipping.email || currentUser?.username || ''
                });
              } else {
                // No saved shipping info, just pre-fill email
                setShippingForm(prev => ({
                  ...prev,
                  email: currentUser?.username || currentUser?.email || ''
                }));
              }
            } else {
              // Error loading, just pre-fill email
              setShippingForm(prev => ({
                ...prev,
                email: currentUser?.username || currentUser?.email || ''
              }));
            }
          } catch (err) {
            console.error('Error loading shipping address:', err);
            // Just pre-fill email on error
            setShippingForm(prev => ({
              ...prev,
              email: currentUser?.username || currentUser?.email || ''
            }));
          }

          setEmailChanged(false);
          setShowShippingModal(true);
        } catch (error) {
          console.error('Print book error:', error);
          alert(language === 'de'
            ? 'Fehler beim Erstellen der Druckbestellung'
            : language === 'fr'
            ? 'Erreur lors de la crÃ©ation de la commande d\'impression'
            : 'Error creating print order');
        }
      };

      const submitPrintOrder = async () => {
        try {
          const shippingAddress = {
            firstName: shippingForm.firstName,
            lastName: shippingForm.lastName,
            addressLine1: shippingForm.addressLine1,
            city: shippingForm.city,
            postCode: shippingForm.postCode,
            country: 'CH', // Hardcoded to Switzerland only
            email: shippingForm.email
          };

          // Save shipping address to database for future orders
          try {
            const saveResponse = await fetch(`${API_URL}/api/user/shipping-address`, {
              method: 'PUT',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${authToken}`
              },
              body: JSON.stringify(shippingAddress)
            });

            if (!saveResponse.ok) {
              const errorData = await saveResponse.json();
              throw new Error(errorData.error || 'Failed to save shipping address');
            }
          } catch (err) {
            console.error('Error saving shipping address:', err);
            // Show validation error to user and stop the process
            alert(language === 'de'
              ? 'Versandadresse-Validierungsfehler: ' + err.message
              : language === 'fr'
              ? 'Erreur de validation de l\'adresse d\'expÃ©dition: ' + err.message
              : 'Shipping address validation error: ' + err.message
            );
            throw err; // Stop the print order process
          }

          // If email changed, update user account
          if (emailChanged && shippingForm.email !== currentUser?.username) {
            const updateResponse = await fetch(`${API_URL}/api/user/update-email`, {
              method: 'PUT',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${authToken}`
              },
              body: JSON.stringify({ newEmail: shippingForm.email })
            });

            if (updateResponse.ok) {
              const updatedUser = await updateResponse.json();
              setCurrentUser(prev => ({ ...prev, username: updatedUser.username }));
              alert(language === 'de'
                ? `E-Mail-Adresse auf ${shippingForm.email} aktualisiert`
                : language === 'fr'
                ? `Adresse e-mail mise Ã  jour en ${shippingForm.email}`
                : `Email address updated to ${shippingForm.email}`);
            } else {
              const errorData = await updateResponse.json();
              console.error('Failed to update email:', errorData);
              // Continue with order even if email update fails
            }
          }

          setShowShippingModal(false);

          // Step 1: Generate PDF on server
          alert(language === 'de'
            ? 'PDF wird generiert, bitte warten...'
            : language === 'fr'
            ? 'GÃ©nÃ©ration du PDF, veuillez patienter...'
            : 'Generating PDF, please wait...'
          );

          // Parse story pages from generatedStory - handle both formats:
          // - Markdown format: ## Seite 1 or ## Page 1
          // - Old format: --- Page 1 --- or --- Seite 1 ---
          const pageMatches = generatedStory.split(/(?:---\s*(?:Page|Seite)\s+\d+\s*---|##\s*(?:Page|Seite)\s+\d+)/i);
          const storyPages = pageMatches.slice(1).filter(p => p.trim().length > 0).map((text, index) => ({
            pageNumber: index + 1,
            text: text.trim()
          }));

          const storyTitle = storyTypes.find(t => t.id === storyType)?.name[language] || 'Story';

          const pdfResponse = await fetch('/api/generate-pdf', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${authToken}`
            },
            body: JSON.stringify({
              storyId: currentStoryId || `story-${Date.now()}`,
              storyTitle: storyTitle,
              storyPages: storyPages,
              sceneImages: sceneImages,
              coverImages: coverImages,
              languageLevel: languageLevel  // For layout: '1st-grade' = combined, others = separate pages
            })
          });

          const pdfData = await pdfResponse.json();

          if (!pdfResponse.ok) {
            throw new Error(pdfData.error || 'Failed to generate PDF');
          }

          console.log('PDF generated:', pdfData);

          // Step 2: Get product UID from backend (with fallback to default)
          // IMPORTANT: Print provider only counts story content pages (not covers)
          // - pages now represents actual print pages directly
          // - Covers (back, front, initial page) are NOT counted by print provider
          const actualPdfPages = pages;  // Print page count (story content only)
          let productUid;

          try {
            const productsResponse = await fetch(`${API_URL}/api/print-provider/products`, {
              headers: { 'Authorization': `Bearer ${authToken}` }
            });

            if (productsResponse.ok) {
              const productsData = await productsResponse.json();
              const products = productsData.products || [];
              console.log('ðŸ“¦ Fetched print products:', products.length, products);
              console.log('ðŸ“„ Story scenes:', pages, '(PDF pages:', actualPdfPages, ')');

              if (products.length > 0) {
                // Find product matching the ACTUAL PDF page count (scenes * 2)
                const matchingProduct = products.find(p => {
                  console.log(`ðŸ” Checking product: ${p.product_name}, min: ${p.min_pages}, max: ${p.max_pages}, available: ${p.available_page_counts}`);
                  // Check if available_page_counts array includes our page count
                  if (p.available_page_counts) {
                    const availableCounts = JSON.parse(p.available_page_counts || '[]');
                    console.log(`  Available counts:`, availableCounts, `Looking for: ${actualPdfPages}`, `Match: ${availableCounts.includes(actualPdfPages)}`);
                    return availableCounts.includes(actualPdfPages);
                  }
                  // Fallback: check min/max range
                  const inRange = actualPdfPages >= (p.min_pages || 0) && actualPdfPages <= (p.max_pages || 999);
                  console.log(`  Range check: ${inRange}`);
                  return inRange;
                });

                productUid = matchingProduct?.product_uid;
                console.log('âœ… Selected product:', matchingProduct?.product_name, 'UID:', productUid);
                if (!matchingProduct) {
                  console.error('âŒ No product matches PDF page count:', actualPdfPages);
                }
              } else {
                console.error('âŒ No products in database!');
              }
            }
          } catch (err) {
            console.warn('Failed to fetch products, will use default:', err.message);
          }

          // Fallback to default print product UID from environment
          if (!productUid) {
            // Get default product UID from backend
            try {
              const configResponse = await fetch(`${API_URL}/api/config/print-product-uid`, {
                headers: { 'Authorization': `Bearer ${authToken}` }
              });

              if (configResponse.ok) {
                const configData = await configResponse.json();
                productUid = configData.productUid;
                console.log('Using default product UID from config:', productUid);
              }
            } catch (err) {
              console.error('Failed to get default product UID:', err);
            }
          }

          // Final check - error if still no product UID
          if (!productUid) {
            throw new Error(language === 'de'
              ? `Kein Druckprodukt konfiguriert. Bitte kontaktieren Sie den Support.`
              : language === 'fr'
              ? `Aucun produit d'impression configurÃ©. Veuillez contacter le support.`
              : `No print product configured. Please contact support.`);
          }

          // Step 3: Create print order with PDF URL
          const printOrderResponse = await fetch('/api/print-provider/order', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${authToken}`
            },
            body: JSON.stringify({
              pdfUrl: pdfData.fileUrl,
              shippingAddress: shippingAddress,
              orderReference: `story-${Date.now()}`,
              productUid: productUid,
              pageCount: actualPdfPages  // Use actual PDF pages (scenes * 2)
            })
          });

          const printOrderData = await printOrderResponse.json();

          if (printOrderResponse.ok) {
            // Show custom modal instead of alert
            setOrderData({
              orderId: printOrderData.orderId,
              dashboardUrl: printOrderData.dashboardUrl,
              pdfUrl: pdfData.fileUrl,
              pdfFilename: pdfData.filename,
              isDraft: printOrderData.isDraft,
              previewUrls: printOrderData.previewUrls || [],
              email: shippingAddress.email
            });
            setShowOrderModal(true);
          } else {
            // PDF was generated but print order failed
            if (printOrderData.setupUrl) {
              alert(language === 'de'
                ? `PDF wurde erstellt, aber der Druckdienstleister ist nicht konfiguriert.\n\nPDF-Link: ${pdfData.fileUrl}\n\nBitte konfigurieren Sie den Druckdienstleister unter: ${printOrderData.setupUrl}`
                : language === 'fr'
                ? `PDF crÃ©Ã©, mais le fournisseur d'impression n'est pas configurÃ©.\n\nLien PDF: ${pdfData.fileUrl}\n\nVeuillez configurer le fournisseur d'impression sur: ${printOrderData.setupUrl}`
                : `PDF generated, but print provider is not configured.\n\nPDF URL: ${pdfData.fileUrl}\n\nPlease configure print provider at: ${printOrderData.setupUrl}`
              );
            } else {
              throw new Error(printOrderData.error || 'Failed to create print order');
            }
          }

        } catch (error) {
          console.error('Print book error:', error);
          alert(language === 'de'
            ? 'Fehler beim Erstellen der Druckbestellung: ' + error.message
            : language === 'fr'
            ? 'Erreur lors de la crÃ©ation de la commande d\'impression: ' + error.message
            : 'Error creating print order: ' + error.message
          );
        }
      };

      const exportStoryInfoAsMarkdown = () => {
        try {
          const storyTypeName = allStoryTypes.find(t => t.id === storyType);
          const storyTypeLabel = storyTypeName ? storyTypeName.name[language] : 'Unknown';
          const storyEmoji = storyTypeName ? storyTypeName.emoji : '';

          let markdown = `# Story Configuration\n\n`;
          markdown += `## Story Type\n`;
          markdown += `- **Type**: ${storyEmoji} ${storyTypeLabel}\n\n`;

          if (storyDetails) {
            markdown += `## Additional Story Details\n\n`;
            markdown += `${storyDetails}\n\n`;
          }

          markdown += `## Characters\n\n`;
          characters.forEach((char, index) => {
            const isMain = mainCharacters.includes(char.id);
            markdown += `### ${index + 1}. ${char.name}${isMain ? ' â­ (Main Character)' : ''}\n\n`;
            markdown += `- **Gender**: ${char.gender === 'male' ? t.male : char.gender === 'female' ? t.female : t.other}\n`;
            markdown += `- **Age**: ${char.age} ${language === 'de' ? 'Jahre' : language === 'fr' ? 'ans' : 'years'}\n`;
            if (char.hairColor) {
              markdown += `- **Hair Color**: ${char.hairColor}\n`;
            }
            if (char.otherFeatures) {
              markdown += `- **Other Features**: ${char.otherFeatures}\n`;
            }
            markdown += `- **Strengths**: ${char.strengths.join(', ')}\n`;
            markdown += `- **Weaknesses**: ${char.weaknesses.join(', ')}\n`;
            if (char.fears && char.fears.length > 0) {
              markdown += `- **Fears**: ${char.fears.join(', ')}\n`;
            }
            if (char.specialDetails) {
              markdown += `- **Special Details**: ${char.specialDetails}\n`;
            }
            markdown += `\n`;
          });

          if (Object.keys(relationships).length > 0) {
            markdown += `## Relationships\n\n`;
            const processedPairs = new Set();
            Object.entries(relationships).forEach(([key, type]) => {
              const [char1Id, char2Id] = key.split('-').map(Number);
              const pairKey = [char1Id, char2Id].sort().join('-');

              if (!processedPairs.has(pairKey) && type !== 'Not Known to') {
                const char1 = characters.find(c => c.id === char1Id);
                const char2 = characters.find(c => c.id === char2Id);
                if (char1 && char2) {
                  markdown += `- **${char1.name}** ${t.is} **${type}** **${char2.name}**\n`;
                  processedPairs.add(pairKey);
                }
              }
            });
            markdown += `\n`;
          }

          markdown += `## Story Settings\n\n`;
          markdown += `- **Number of Pages**: ${pages}\n`;
          markdown += `- **Reading Level**: ${languageLevel === '1st-grade' ? t.firstGrade : languageLevel === 'standard' ? t.standard : t.advanced}\n`;
          markdown += `- **Language**: ${language === 'de' ? 'German (Deutsch)' : language === 'fr' ? 'French (FranÃ§ais)' : 'English'}\n`;

          const blob = new Blob([markdown], { type: 'text/markdown;charset=utf-8' });
          const url = URL.createObjectURL(blob);
          const link = document.createElement('a');
          link.href = url;
          link.download = `story-info-${storyTypeLabel.replace(/\s+/g, '-')}-${Date.now()}.md`;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          URL.revokeObjectURL(url);
        } catch (error) {
          console.error('Export markdown error:', error);
          alert('Export markdown error: ' + error.message);
        }
      };

      const exportConfiguration = () => {
        try {
          const config = {
            version: '1.0',
            language,
            storyType,
            storyDetails,
            characters: characters.map(char => ({
              id: char.id,
              name: char.name,
              photoUrl: char.photoUrl || null,
              thumbnailUrl: char.thumbnailUrl || null,
              gender: char.gender,
              age: char.age,
              hairColor: char.hairColor || '',
              otherFeatures: char.otherFeatures || '',
              strengths: char.strengths,
              weaknesses: char.weaknesses,
              specialDetails: char.specialDetails || '',
              fears: char.fears
            })),
            customStrengths,
            customWeaknesses,
            customFears,
            customRelationships,
            customStoryTypes,
            relationships,
            pages,
            languageLevel,
            mainCharacters
          };

          const jsonString = JSON.stringify(config, null, 2);
          const blob = new Blob([jsonString], { type: 'application/json' });
          const url = URL.createObjectURL(blob);
          const link = document.createElement('a');
          link.href = url;
          link.download = `story-config-${Date.now()}.json`;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          URL.revokeObjectURL(url);
        } catch (error) {
          console.error('Export error:', error);
          alert('Export error: ' + error.message);
        }
      };

      const parseMarkdownConfig = (mdContent) => {
        const config = {
          language: 'en',
          storyType: '',
          storyDetails: '',
          characters: [],
          relationships: {},
          pages: 5,
          languageLevel: 'standard',
          mainCharacters: []
        };

        // Parse language
        if (mdContent.includes('German (Deutsch)')) config.language = 'de';
        else if (mdContent.includes('French (FranÃ§ais)')) config.language = 'fr';

        // Parse story type
        const storyTypeMatch = mdContent.match(/\*\*Type\*\*:\s*(.+?)\s+(.+)/);
        if (storyTypeMatch) {
          const emoji = storyTypeMatch[1].trim();
          const typeName = storyTypeMatch[2].trim();
          const foundType = allStoryTypes.find(t => t.emoji === emoji || t.name[config.language] === typeName);
          if (foundType) config.storyType = foundType.id;
        }

        // Parse additional story details
        const detailsMatch = mdContent.match(/## Additional Story Details\n\n([\s\S]*?)(?=\n##|$)/);
        if (detailsMatch) {
          config.storyDetails = detailsMatch[1].trim();
        }

        // Parse characters
        const charSections = mdContent.split(/###\s+\d+\.\s+/).slice(1);
        charSections.forEach((section) => {
          const lines = section.split('\n').filter(l => l.trim());
          if (lines.length === 0) return;

          const nameMatch = lines[0].match(/^(.+?)(?:\s+â­\s+\(Main Character\))?$/);
          if (!nameMatch) return;

          const char = {
            id: Date.now() + Math.random(),
            name: nameMatch[1].trim(),
            gender: 'other',
            age: '',
            hairColor: '',
            otherFeatures: '',
            strengths: [],
            weaknesses: [],
            fears: [],
            specialDetails: ''
          };

          const isMain = lines[0].includes('â­');
          if (isMain) config.mainCharacters.push(char.id);

          lines.forEach(line => {
            if (line.includes('**Gender**:')) {
              const gender = line.split(':')[1].trim().toLowerCase();
              if (gender.includes('male') && !gender.includes('female')) char.gender = 'male';
              else if (gender.includes('female')) char.gender = 'female';
            }
            else if (line.includes('**Age**:')) {
              char.age = line.split(':')[1].trim().split(' ')[0];
            }
            else if (line.includes('**Hair Color**:')) {
              char.hairColor = line.split(':')[1].trim();
            }
            else if (line.includes('**Other Features**:')) {
              char.otherFeatures = line.split(':')[1].trim();
            }
            else if (line.includes('**Strengths**:')) {
              char.strengths = line.split(':')[1].trim().split(',').map(s => s.trim());
            }
            else if (line.includes('**Weaknesses**:')) {
              char.weaknesses = line.split(':')[1].trim().split(',').map(s => s.trim());
            }
            else if (line.includes('**Fears**:')) {
              char.fears = line.split(':')[1].trim().split(',').map(s => s.trim());
            }
            else if (line.includes('**Special Details**:')) {
              char.specialDetails = line.split(':')[1].trim();
            }
          });

          config.characters.push(char);
        });

        // Parse relationships
        const relSection = mdContent.match(/## Relationships\n\n([\s\S]*?)(?=\n##|$)/);
        if (relSection) {
          const relLines = relSection[1].split('\n').filter(l => l.trim().startsWith('-'));
          relLines.forEach(line => {
            const match = line.match(/\*\*(.+?)\*\*\s+(.+?)\s+\*\*(.+?)\*\*\s+\*\*(.+?)\*\*/);
            if (match) {
              const char1Name = match[1].trim();
              const relType = match[3].trim();
              const char2Name = match[4].trim();

              const char1 = config.characters.find(c => c.name === char1Name);
              const char2 = config.characters.find(c => c.name === char2Name);

              if (char1 && char2) {
                config.relationships[`${char1.id}-${char2.id}`] = relType;
                // Also set reverse relationship
                const relTypeObj = relationshipTypes.find(r => r.value[config.language] === relType);
                if (relTypeObj) {
                  config.relationships[`${char2.id}-${char1.id}`] = relTypeObj.inverse[config.language];
                } else {
                  config.relationships[`${char2.id}-${char1.id}`] = relType;
                }
              }
            }
          });
        }

        // Parse settings
        const pagesMatch = mdContent.match(/\*\*Number of Pages\*\*:\s*(\d+)/);
        if (pagesMatch) config.pages = parseInt(pagesMatch[1]);

        const levelMatch = mdContent.match(/\*\*Reading Level\*\*:\s*(.+)/);
        if (levelMatch) {
          const level = levelMatch[1].trim();
          if (level.includes('1st') || level.includes('1Ã¨re') || level.includes('1.')) {
            config.languageLevel = '1st-grade';
          } else if (level.includes('Advanced') || level.includes('AvancÃ©') || level.includes('Fortgeschritten')) {
            config.languageLevel = 'advanced';
          } else {
            config.languageLevel = 'standard';
          }
        }

        return config;
      };

      const importConfiguration = (e) => {
        const file = e.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = (event) => {
            try {
              const content = event.target.result;
              let config;

              // Detect file type
              if (file.name.endsWith('.md')) {
                config = parseMarkdownConfig(content);
              } else {
                config = JSON.parse(content);
              }

              setLanguage(config.language || 'en');
              setStoryType(config.storyType || '');
              setStoryDetails(config.storyDetails || '');
              setCharacters(config.characters || []);
              setCustomStrengths(config.customStrengths || []);
              setCustomWeaknesses(config.customWeaknesses || []);
              setCustomFears(config.customFears || []);
              setCustomRelationships(config.customRelationships || []);
              setCustomStoryTypes(config.customStoryTypes || []);
              setRelationships(config.relationships || {});
              setPages(config.pages || 5);
              setLanguageLevel(config.languageLevel || 'standard');
              setMainCharacters(config.mainCharacters || []);
              setStep(1);
              alert(language === 'de' ? 'Konfiguration erfolgreich importiert!' : language === 'fr' ? 'Configuration importÃ©e avec succÃ¨s!' : 'Configuration imported successfully!');
            } catch (error) {
              console.error('Import error:', error);
              alert((language === 'de' ? 'Fehler beim Laden der Konfigurationsdatei: ' : language === 'fr' ? 'Erreur de chargement du fichier de configuration: ' : 'Error loading configuration file: ') + error.message);
            }
          };
          reader.readAsText(file);
        }
      };

      const startNewCharacter = () => {
        setCurrentCharacter({
          id: Date.now(),
          name: '',
          photo: null,
          photoUrl: null,
          thumbnailUrl: null,
          useDescription: false,
          descriptionAge: '',
          hairColor: '',
          clothing: '',
          otherFeatures: '',
          gender: 'other',
          age: '',
          height: '',
          build: '',
          strengths: [],
          weaknesses: [],
          specialDetails: '',
          fears: []
        });
        setShowCharacterCreated(false);
        setGeneratedAvatar(null);
        setGeneratedAvatars([]);
        setAnalyzedTraitsText('');
        setUploadType('photo'); // Reset to photo upload mode
        setAvatarPrompt(''); // Clear avatar prompt
      };

      const editCharacter = (char) => {
        console.log('âœï¸ Editing character:', char);
        console.log('âœï¸ Character has photoUrl:', !!char.photoUrl);
        console.log('âœï¸ Character strengths:', char.strengths);
        console.log('âœï¸ Character weaknesses:', char.weaknesses);
        console.log('âœï¸ Character fears:', char.fears);

        // Extract custom attributes (not in default lists) and populate custom arrays
        // This ensures custom attributes show up as buttons in edit form
        const allDefaultStrengths = [...defaultStrengths.en, ...defaultStrengths.de, ...defaultStrengths.fr];
        const allDefaultWeaknesses = [...defaultWeaknesses.en, ...defaultWeaknesses.de, ...defaultWeaknesses.fr];
        const allDefaultFears = [...fearOptions.en, ...fearOptions.de, ...fearOptions.fr];

        const customStrs = (char.strengths || []).filter(s => !allDefaultStrengths.includes(s));
        const customWeaks = (char.weaknesses || []).filter(w => !allDefaultWeaknesses.includes(w));
        const customFrs = (char.fears || []).filter(f => !allDefaultFears.includes(f));

        // Merge with existing custom attributes (avoid duplicates)
        setCustomStrengths([...new Set([...customStrengths, ...customStrs])]);
        setCustomWeaknesses([...new Set([...customWeaknesses, ...customWeaks])]);
        setCustomFears([...new Set([...customFears, ...customFrs])]);

        // Store backup before editing
        setCharacterBackup(JSON.parse(JSON.stringify(char))); // Deep copy
        setCurrentCharacter(char);
        setCharacters(characters.filter(c => c.id !== char.id));
        setShowCharacterCreated(false);
        setGeneratedAvatar(null);
        setGeneratedAvatars([]);
        // Scroll to character form after state updates
        setTimeout(() => {
          if (characterFormRef.current) {
            characterFormRef.current.scrollIntoView({ behavior: 'smooth', block: 'start' });
          }
        }, 100);
      };

      const cancelEditCharacter = () => {
        if (characterBackup) {
          // Restore the backup
          setCharacters([...characters, characterBackup]);
          setCharacterBackup(null);
        }
        setCurrentCharacter(null);
        setShowCharacterCreated(false);
        setGeneratedAvatar(null);
        setGeneratedAvatars([]);
      };

      // Helper function to safely navigate between steps
      // Restores any character being edited before changing steps
      const safeSetStep = (newStep) => {
        // If a character is being edited, restore it first
        if (characterBackup) {
          console.log('âš ï¸ Character was being edited - restoring backup before navigation');
          setCharacters([...characters, characterBackup]);
          setCharacterBackup(null);
          setCurrentCharacter(null);
          setShowCharacterCreated(false);
          setGeneratedAvatar(null);
          setGeneratedAvatars([]);
        }
        setStep(newStep);
      };

      const deleteCharacter = (charId) => {
        if (confirm(t.deleteCharacter + '?')) {
          setCharacters(characters.filter(c => c.id !== charId));
          // Remove from main characters if present
          setMainCharacters(mainCharacters.filter(id => id !== charId));
          // Remove relationships involving this character (use functional update)
          setRelationships(prev => {
            const newRelationships = {};
            Object.keys(prev).forEach(key => {
              if (!key.includes(charId.toString())) {
                newRelationships[key] = prev[key];
              }
            });
            console.log('ðŸ—‘ï¸ [DELETE] Removed relationships for character', charId, '- remaining:', Object.keys(newRelationships).length);
            return newRelationships;
          });
        }
      };

      const saveCurrentCharacter = () => {
        if (currentCharacter.name &&
            currentCharacter.strengths && currentCharacter.strengths.length >= 3 &&
            currentCharacter.weaknesses && currentCharacter.weaknesses.length >= 2) {
          const updatedCharacters = [...characters, currentCharacter];
          setCharacters(updatedCharacters);

          // Auto-select main characters based on age
          autoSelectMainCharacters(updatedCharacters);

          setShowCharacterCreated(true);
          setCurrentCharacter(null);
          setCharacterBackup(null); // Clear backup after successful save

          // Scroll to top of page
          window.scrollTo({ top: 0, behavior: 'smooth' });
        }
      };

      // Compress image to reduce storage and network transfer size
      const compressImage = (dataUrl, maxWidth = 400, maxHeight = 400, quality = 0.8) => {
        return new Promise((resolve) => {
          const img = new Image();
          img.onload = () => {
            const canvas = document.createElement('canvas');
            let { width, height } = img;

            // Calculate new dimensions maintaining aspect ratio
            if (width > maxWidth || height > maxHeight) {
              const ratio = Math.min(maxWidth / width, maxHeight / height);
              width = Math.round(width * ratio);
              height = Math.round(height * ratio);
            }

            canvas.width = width;
            canvas.height = height;

            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0, width, height);

            // Convert to JPEG for better compression
            const compressedUrl = canvas.toDataURL('image/jpeg', quality);
            console.log(`ðŸ“· Image compressed: ${Math.round(dataUrl.length/1024)}KB â†’ ${Math.round(compressedUrl.length/1024)}KB`);
            resolve(compressedUrl);
          };
          img.src = dataUrl;
        });
      };

      // Note: Cropping is now done server-side by Python MediaPipe API
      // Face crop, body crop, and body without background are all returned by the API

      const handlePhotoUpload = async (e) => {
        const file = e.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onloadend = async () => {
            const originalImage = reader.result;

            // First, create a basic compressed version for immediate display
            const basicPhotoUrl = await compressImage(originalImage);

            // Update character with basic photo immediately (so UI shows something)
            setCurrentCharacter({
              ...currentCharacter,
              photo: file,
              photoUrl: basicPhotoUrl,
              thumbnailUrl: basicPhotoUrl // Use same initially, will update after analysis
            });
            setGeneratedAvatar(null);

            // Only analyze and auto-fill if it's a real photo (not a ready avatar)
            if (uploadType === 'photo') {
              // In dev mode, run both APIs in parallel for comparison
              // Otherwise, just run Gemini
              let geminiTraits = null;
              let pythonTraits = null;
              let primaryTraits = null;

              // Run BOTH APIs in parallel:
              // - Python MediaPipe: face/body detection (bounding boxes, cropping)
              // - Gemini: feature extraction (age, gender, hair, clothing, etc.)
              console.log('ðŸ”„ Running Python (face detection) and Gemini (features) in parallel...');

              const [pythonResult, geminiResult] = await Promise.allSettled([
                analyzeImageWithPython(originalImage),
                analyzeImageForTraits(originalImage)
              ]);

              pythonTraits = pythonResult.status === 'fulfilled' ? pythonResult.value : null;
              geminiTraits = geminiResult.status === 'fulfilled' ? geminiResult.value : null;

              console.log('ðŸ Python result:', pythonTraits ? 'success' : 'failed');
              console.log('ðŸ¤– Gemini result:', geminiTraits ? 'success' : 'failed');

              // Combine results: Python for detection, Gemini for features
              primaryTraits = {
                // Use Python bounding boxes (more accurate for face/body detection)
                faceBox: pythonTraits?.faceBox || null,
                bodyBox: pythonTraits?.bodyBox || null,
                // Use Gemini for ALL features (more detailed analysis)
                age: geminiTraits?.age || pythonTraits?.age || '',
                gender: geminiTraits?.gender || pythonTraits?.gender || '',
                height: geminiTraits?.height || pythonTraits?.height || '',
                build: geminiTraits?.build || pythonTraits?.build || '',
                hairColor: geminiTraits?.hairColor || '',
                clothing: geminiTraits?.clothing || '',
                otherFeatures: geminiTraits?.otherFeatures || '',
                fullText: geminiTraits?.fullText || '',
                // Store pre-cropped images from Python
                faceThumbnail: pythonTraits?.faceThumbnail || null,
                bodyCrop: pythonTraits?.bodyCrop || null
              };

              if (primaryTraits) {
                // Use Python pre-cropped images (no fallback to Gemini/manual cropping)
                // Face crop = display avatar, Body crop = image generation
                let finalPhotoUrl = pythonTraits?.faceThumbnail || basicPhotoUrl;
                let bodyPhotoUrl = pythonTraits?.bodyCrop || basicPhotoUrl;
                let bodyNoBgUrl = pythonTraits?.bodyNoBg || null;

                if (pythonTraits?.faceThumbnail) {
                  console.log('âœ… Using Python face thumbnail as display avatar');
                } else {
                  console.log('âš ï¸ No face detected, using original image');
                }

                if (pythonTraits?.bodyCrop) {
                  console.log('âœ… Using Python body crop for image generation');
                } else {
                  console.log('âš ï¸ No body detected, using original image');
                }

                if (bodyNoBgUrl) {
                  console.log('âœ… Got body crop with background removed');
                }

                setCurrentCharacter(prev => {
                  // Priority: user setting > image detection
                  // Only use image-detected values if user hasn't set them
                  const shouldUseImageGender = !prev.gender || prev.gender === 'other';
                  const shouldUseImageAge = !prev.age || prev.age === '';
                  const shouldUseImageHeight = !prev.height || prev.height === '';
                  const shouldUseImageBuild = !prev.build || prev.build === '';

                  return {
                    ...prev,
                    gender: shouldUseImageGender ? (primaryTraits.gender || prev.gender) : prev.gender,
                    age: shouldUseImageAge ? (primaryTraits.age || prev.age) : prev.age,
                    height: shouldUseImageHeight ? (primaryTraits.height || prev.height) : prev.height,
                    build: shouldUseImageBuild ? (primaryTraits.build || prev.build) : prev.build,
                    hairColor: primaryTraits.hairColor || prev.hairColor,
                    clothing: primaryTraits.clothing || prev.clothing,
                    otherFeatures: primaryTraits.otherFeatures || prev.otherFeatures,
                    photoUrl: finalPhotoUrl,        // Face crop - used throughout the app for display
                    thumbnailUrl: finalPhotoUrl,    // Same as photoUrl (face)
                    bodyPhotoUrl: bodyPhotoUrl,     // Body crop with background
                    bodyNoBgUrl: bodyNoBgUrl,       // Body crop WITHOUT background - for image generation
                    // Store both results for dev mode comparison
                    faceBox: primaryTraits.faceBox || null,
                    bodyBox: primaryTraits.bodyBox || null,
                    devComparison: characterDevMode ? {
                      gemini: geminiTraits,
                      python: pythonTraits
                    } : null
                  };
                });

                // Store the full analyzed text for display
                if (primaryTraits.fullText) {
                  setAnalyzedTraitsText(primaryTraits.fullText);
                }
              }
            }
          };
          reader.readAsDataURL(file);
        }
      };

      const handleNameChange = (name) => {
        // Gender priority: user setting > name detection > image detection
        // Only auto-detect from name if gender is not already set (is 'other' or empty)
        const currentGender = currentCharacter.gender;
        const shouldAutoDetect = !currentGender || currentGender === 'other';

        if (shouldAutoDetect) {
          const detectedGender = detectGender(name);
          setCurrentCharacter({
            ...currentCharacter,
            name,
            gender: detectedGender
          });
        } else {
          // Keep existing gender (user or image-detected)
          setCurrentCharacter({
            ...currentCharacter,
            name
          });
        }
      };

      const toggleArrayItem = (field, item) => {
        const currentArray = currentCharacter[field];
        const newArray = currentArray.includes(item)
          ? currentArray.filter(i => i !== item)
          : [...currentArray, item];
        setCurrentCharacter({ ...currentCharacter, [field]: newArray });
      };

      const addCustomStrength = () => {
        if (newStrength && !allStrengths.includes(newStrength)) {
          setCustomStrengths([...customStrengths, newStrength]);
          setCurrentCharacter({
            ...currentCharacter,
            strengths: [...currentCharacter.strengths, newStrength]
          });
          setNewStrength('');
        }
      };

      const addCustomWeakness = () => {
        if (newWeakness && !allWeaknesses.includes(newWeakness)) {
          setCustomWeaknesses([...customWeaknesses, newWeakness]);
          setCurrentCharacter({
            ...currentCharacter,
            weaknesses: [...currentCharacter.weaknesses, newWeakness]
          });
          setNewWeakness('');
        }
      };

      const addCustomFear = () => {
        if (newFear && !allFears.includes(newFear)) {
          setCustomFears([...customFears, newFear]);
          setCurrentCharacter({
            ...currentCharacter,
            fears: [...currentCharacter.fears, newFear]
          });
          setNewFear('');
        }
      };

      const addCustomRelationship = () => {
        if (newRelationship && !customRelationships.includes(newRelationship)) {
          setCustomRelationships([...customRelationships, newRelationship]);
          setNewRelationship('');
        }
      };

      const toggleMainCharacter = (charId) => {
        if (mainCharacters.includes(charId)) {
          setMainCharacters(mainCharacters.filter(id => id !== charId));
        } else if (mainCharacters.length < 2) {
          setMainCharacters([...mainCharacters, charId]);
        }
      };

      const initializeRelationships = () => {
        // Use functional update to avoid stale closure issues
        setRelationships(prevRelationships => {
          const newRelationships = { ...prevRelationships };
          characters.forEach(char1 => {
            characters.forEach(char2 => {
              if (char1.id !== char2.id) {
                const key = `${char1.id}-${char2.id}`;
                if (!prevRelationships[key]) {
                  newRelationships[key] = getNotKnownRelationship(language);
                }
                // If relationship already exists, keep it (already in newRelationships from spread)
              }
            });
          });
          console.log('ðŸ”— [INIT] Initialized relationships:', Object.keys(newRelationships).length);
          return newRelationships;
        });
      };

      const updateRelationship = (char1Id, char2Id, type) => {
        const inverse = getInverseRelationship(type);
        // Use functional update to avoid stale closure issues
        setRelationships(prev => ({
          ...prev,
          [`${char1Id}-${char2Id}`]: type,
          [`${char2Id}-${char1Id}`]: inverse
        }));
      };

      const areAllRelationshipsDefined = () => {
        for (let i = 0; i < characters.length; i++) {
          for (let j = 0; j < characters.length; j++) {
            if (i !== j) {
              const key = `${characters[i].id}-${characters[j].id}`;
              if (!relationships[key]) return false;
            }
          }
        }
        return true;
      };

      const renderStep0 = () => (
        <div className="flex flex-col min-h-[calc(100vh-72px)] px-4 lg:px-8 py-6 lg:py-8 relative">
          {/* Decorative Sparkles - Only 4 total, hidden on mobile */}
          <div className="hidden lg:block absolute bottom-10 right-20 text-3xl opacity-50 animate-pulse">âœ¨</div>
          <div className="hidden lg:block absolute top-10 right-1/3 text-3xl opacity-50 animate-pulse" style={{animationDelay: '1s'}}>âœ¨</div>
          <div className="hidden lg:block absolute bottom-24 left-1/4 text-3xl opacity-50 animate-pulse" style={{animationDelay: '1.5s'}}>âœ¨</div>
          <div className="hidden lg:block absolute bottom-1/3 right-1/3 text-3xl opacity-50 animate-pulse" style={{animationDelay: '2s'}}>âœ¨</div>

          <div className="flex flex-col lg:flex-row gap-6 lg:gap-12 w-full relative z-10">
            {/* Left Side - Text and Button */}
            <div className="w-full lg:w-[35%] flex flex-col justify-center">
              <div>
                <h1 className="text-4xl lg:text-6xl font-title text-black mb-4 lg:mb-6 leading-tight">
                  {t.heroTitle}
                </h1>
                <p className="text-lg lg:text-2xl font-body text-black mb-3 lg:mb-4">
                  {t.heroDescription}
                </p>
                <p className="text-lg lg:text-2xl font-body text-black mb-6 lg:mb-8">
                  {t.bookText}
                </p>

                {/* Button directly below text */}
                <button
                  onClick={() => setShowAuthModal(true)}
                  className="bg-indigo-600 hover:bg-indigo-700 text-white px-8 lg:px-12 py-4 lg:py-6 rounded-xl text-lg lg:text-2xl font-bold shadow-xl hover:shadow-2xl transform hover:scale-105 transition-all inline-flex items-center gap-3"
                >
                  <Icon name="sparkles" size={28} />
                  {t.startJourney}
                  <Icon name="arrow-right" size={28} />
                </button>
              </div>
            </div>

            {/* Right Side - Photos and Video (Mobile: stacked, Desktop: side-by-side) */}
            <div className="w-full lg:w-[65%] flex items-center">
              {/* Photos Section */}
              <div className="flex flex-row gap-3 lg:gap-6 items-center justify-center w-full">
                {/* Photos Column - Stacked Vertically on both mobile and desktop */}
                <div className="flex flex-col gap-2 lg:gap-4 w-1/4 lg:w-[28%]">
                  {/* Real Photo */}
                  <div className="text-center">
                    <div className="mb-1 lg:mb-2">
                      <img src="images/Real person.jpg" alt="Your Picture" className="w-full h-auto object-contain rounded-lg max-h-[100px] lg:max-h-[180px]" />
                    </div>
                    <p className="text-xs lg:text-base text-black font-semibold">
                      {language === 'de' ? 'Dein Foto' : language === 'fr' ? 'Votre Photo' : 'Your Picture'}
                    </p>
                  </div>

                  {/* Arrow Down - Rotated 90 degrees */}
                  <div className="flex justify-center my-1 lg:my-2">
                    <img src="images/arrow-icon-1162.png" alt="Arrow Down" className="w-6 h-6 lg:w-12 lg:h-12" style={{transform: 'rotate(90deg)'}} />
                  </div>

                  {/* Avatar */}
                  <div className="text-center">
                    <div className="mb-1 lg:mb-2">
                      <img src="images/Avatar.jpg" alt="Your Character" className="w-full h-auto object-contain rounded-lg max-h-[100px] lg:max-h-[180px]" />
                    </div>
                    <p className="text-xs lg:text-base text-black font-semibold">
                      {language === 'de' ? 'Dein Charakter' : language === 'fr' ? 'Votre Personnage' : 'Your Character'}
                    </p>
                  </div>
                </div>

                {/* Arrow Right - Hidden on mobile, shown on desktop */}
                <div className="hidden lg:flex justify-center items-center lg:w-[8%] self-center">
                  <img src="images/arrow-icon-1162.png" alt="Arrow Right" className="w-14 h-14 lg:w-16 lg:h-16" />
                </div>

                {/* Video Column */}
                <div className="text-center w-3/4 lg:w-[64%]">
                  <div className="rounded-xl overflow-hidden shadow-2xl mb-1 lg:mb-2 h-[280px] lg:h-[480px]">
                    <video
                      autoPlay
                      loop
                      muted
                      playsInline
                      poster="images/video-poster.jpg"
                      className="w-full h-full object-cover"
                    >
                      <source src="images/Boy to pirat to book.mp4" type="video/mp4" />
                      Your browser does not support the video tag.
                    </video>
                  </div>
                  <p className="text-xs lg:text-base text-black font-semibold">
                    {language === 'de' ? 'Deine Geschichte' : language === 'fr' ? 'Votre Histoire' : 'Your Story'}
                  </p>
                </div>
              </div>
            </div>
          </div>
        </div>
      );

      const renderStep1 = () => (
        <div className="space-y-6">
          <div className="flex justify-between items-center flex-wrap gap-2 mb-4">
            <h2 className="text-3xl font-bold text-gray-800 flex items-center gap-2">
              <Icon name="book-open" size={24} /> {t.chooseStoryType}
            </h2>
          </div>
          <div className="grid grid-cols-3 md:grid-cols-5 lg:grid-cols-6 gap-2">
            {allStoryTypes.map(type => (
              <button
                key={type.id}
                onClick={() => {
                  setStoryType(type.id);
                  // Auto-scroll to art style selection after a short delay
                  setTimeout(() => {
                    const artStyleSection = document.getElementById('art-style-section');
                    if (artStyleSection) {
                      artStyleSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    }
                  }, 100);
                }}
                className={`p-2 rounded-lg border-2 transition-all ${
                  storyType === type.id
                    ? 'border-indigo-600 bg-indigo-50 shadow-lg'
                    : 'border-gray-200 hover:border-indigo-300'
                }`}
              >
                <div className="text-2xl mb-1">{type.emoji}</div>
                <div className="font-semibold text-xs">{type.name[language]}</div>
              </button>
            ))}
            {/* Add Custom Type Button */}
            <button
              onClick={addCustomStoryType}
              className="p-2 rounded-lg border-2 border-dashed border-indigo-300 hover:border-indigo-600 transition-all hover:bg-indigo-50"
            >
              <div className="text-2xl mb-1">âž•</div>
              <div className="font-semibold text-xs text-indigo-600">{t.addCustomStoryType}</div>
            </button>
          </div>

          {/* Art Style Selection - Show only after story type is selected */}
          {storyType && (
            <div id="art-style-section" className="md:bg-indigo-50 md:border-2 md:border-indigo-200 md:rounded-lg md:p-4 mt-4">
              <div className="flex items-center gap-2 mb-2">
                <Icon name="palette" size={18} className="text-indigo-600" />
                <h2 className="text-lg md:text-xl font-bold text-gray-800">{t.chooseArtStyle}</h2>
              </div>
              <p className="text-sm text-gray-500 mb-2 md:mb-3">{t.artStyleDescription}</p>
              <div className="grid grid-cols-3 md:grid-cols-5 lg:grid-cols-7 gap-2">
                {artStyles.map(style => (
                  <button
                    key={style.id}
                    onClick={() => setArtStyle(style.id)}
                    className={`rounded-lg border-2 transition-all overflow-hidden flex flex-col bg-white ${
                      artStyle === style.id
                        ? 'border-indigo-600 shadow-lg ring-2 ring-indigo-200'
                        : 'border-gray-200 hover:border-indigo-300'
                    }`}
                  >
                    {/* Image at the top - Taller to show more */}
                    <div className="relative w-full h-32 overflow-hidden">
                      <img
                        src={style.image}
                        alt={style.name[language]}
                        className="w-full h-full object-cover"
                      />
                    </div>

                    {/* Text content below image - No emoji */}
                    <div className="p-1.5 flex flex-col items-center text-center">
                      <div className="font-bold text-xs text-gray-800">{style.name[language]}</div>
                    </div>
                  </button>
                ))}
              </div>
            </div>
          )}
        </div>
      );

      const renderStep2 = () => {
        // Character is initialized by useEffect when step changes to 2
        // This prevents state updates during render

        // Ensure arrays are initialized (only if currentCharacter exists)
        if (currentCharacter) {
          if (!currentCharacter.strengths) currentCharacter.strengths = [];
          if (!currentCharacter.weaknesses) currentCharacter.weaknesses = [];
          if (!currentCharacter.fears) currentCharacter.fears = [];
        }

        const canSave = currentCharacter && currentCharacter.name &&
                        currentCharacter.strengths && currentCharacter.strengths.length >= 3 &&
                        currentCharacter.weaknesses && currentCharacter.weaknesses.length >= 2;

        return (
          <div className="space-y-6">
            <h2 className="text-3xl font-bold text-gray-800 flex items-center gap-2">
              <Icon name="users" size={24} /> {t.createCharacters}
            </h2>

            {/* Character list with action buttons - shown when there are existing characters */}
            {characters.length > 0 && !currentCharacter && (
              <div className="space-y-4">
                {/* Success message if just created */}
                {showCharacterCreated && (
                  <div className="md:bg-green-50 md:border-2 md:border-green-400 md:rounded-xl p-4 animate-fade-in">
                    <div className="flex items-center gap-3">
                      <div className="bg-green-500 text-white rounded-full w-8 h-8 flex items-center justify-center">
                        <Icon name="check" size={20} />
                      </div>
                      <h3 className="text-lg font-bold text-green-700">
                        {language === 'de' ? 'Charakter erfolgreich erstellt!' : language === 'fr' ? 'Personnage crÃ©Ã© avec succÃ¨s !' : 'Character Created Successfully!'}
                      </h3>
                    </div>
                  </div>
                )}

                {/* Existing characters */}
                <div className="bg-white border-2 border-indigo-200 rounded-lg p-3">
                  <h3 className="text-base font-bold text-gray-800 mb-2">{t.yourCharacters}</h3>
                  <div className="grid md:grid-cols-2 gap-2">
                    {characters.map((char) => (
                      <div key={char.id} className="border border-gray-200 rounded p-2">
                        {/* Top row: Photo/Name on left, Buttons on right */}
                        <div className="flex items-start justify-between gap-2 mb-2">
                          <div className="flex items-center gap-2 flex-1 min-w-0">
                            {(char.thumbnailUrl || char.photoUrl) && (
                              <img src={char.thumbnailUrl || char.photoUrl} alt={char.name} className="w-12 h-12 md:w-16 md:h-16 rounded-full object-cover border-2 border-indigo-200 flex-shrink-0" />
                            )}
                            <div className="flex-1 min-w-0">
                              <h4 className="font-bold text-sm md:text-base truncate">{char.name}</h4>
                              <p className="text-xs md:text-sm text-gray-500">
                                {char.gender === 'male' ? t.male : char.gender === 'female' ? t.female : t.other}, {char.age} {language === 'de' ? 'J' : language === 'fr' ? 'ans' : 'y'}
                              </p>
                            </div>
                          </div>
                          <div className="flex gap-1 flex-shrink-0">
                            <button
                              onClick={() => editCharacter(char)}
                              className="bg-indigo-600 text-white px-2 md:px-3 py-1 rounded text-xs hover:bg-indigo-700"
                            >
                              {t.editCharacter}
                            </button>
                            <button
                              onClick={() => deleteCharacter(char.id)}
                              className="bg-red-500 text-white px-2 md:px-3 py-1 rounded text-xs hover:bg-red-600"
                            >
                              {t.deleteCharacter}
                            </button>
                          </div>
                        </div>
                        {/* Character traits below */}
                        {char.strengths && char.strengths.length > 0 && (
                          <p className="text-xs text-gray-800 mb-1">
                            <strong className="text-green-600">{t.strengths}:</strong> {char.strengths.join(', ')}
                          </p>
                        )}
                        {char.weaknesses && char.weaknesses.length > 0 && (
                          <p className="text-xs text-gray-800 mb-1">
                            <strong className="text-orange-600">{t.weaknesses}:</strong> {char.weaknesses.join(', ')}
                          </p>
                        )}
                        {char.fears && char.fears.length > 0 && (
                          <p className="text-xs text-gray-800 mb-1">
                            <strong className="text-red-600">{t.fears}:</strong> {char.fears.join(', ')}
                          </p>
                        )}
                      </div>
                    ))}
                  </div>
                </div>

                {/* What would you like to do next? */}
                <div className="md:bg-indigo-50 md:border-2 md:border-indigo-200 md:rounded-lg p-4">
                  <p className="text-gray-800 mb-4 text-center font-semibold">
                    {language === 'de'
                      ? 'Was mÃ¶chten Sie als NÃ¤chstes tun?'
                      : language === 'fr'
                      ? 'Que voulez-vous faire ensuite ?'
                      : 'What would you like to do next?'}
                  </p>
                  <div className="grid md:grid-cols-2 gap-3">
                    <button
                      onClick={() => {
                        setShowCharacterCreated(false);
                        startNewCharacter();
                      }}
                      className="bg-indigo-500 text-white px-6 py-3 rounded-lg hover:bg-indigo-600 font-semibold flex items-center justify-center gap-2 transition-colors"
                    >
                      <Icon name="user-plus" size={20} />
                      {language === 'de' ? 'Weiteren Charakter erstellen' : language === 'fr' ? 'CrÃ©er un autre personnage' : 'Create Another Character'}
                    </button>
                    <button
                      onClick={() => {
                        setShowCharacterCreated(false);
                        initializeRelationships();
                        setStep(3);
                      }}
                      className="bg-indigo-600 text-white px-6 py-3 rounded-lg hover:bg-indigo-700 font-semibold flex items-center justify-center gap-2 transition-colors"
                    >
                      <Icon name="arrow-right" size={20} />
                      {language === 'de' ? 'Weiter zu Beziehungen' : language === 'fr' ? 'Continuer vers les relations' : 'Continue to Relationships'}
                    </button>
                  </div>
                </div>
              </div>
            )}

            {currentCharacter && !currentCharacter.photoUrl && (
              <div ref={characterFormRef} className="bg-indigo-50 border-2 border-indigo-300 rounded-lg p-4">
                    <p className="text-sm font-semibold text-indigo-700 mb-4 text-center">{t.uploadPhotoFirst}</p>

                    {/* Upload button - prominent, first */}
                    <div className="text-center mb-5">
                      <label className="cursor-pointer inline-flex items-center justify-center gap-3 bg-indigo-600 text-white px-10 py-4 rounded-xl text-xl hover:bg-indigo-700 font-bold shadow-lg">
                        <Icon name="upload" size={28} /> {t.uploadPhoto}
                        <input
                          type="file"
                          accept="image/*"
                          onChange={handlePhotoUpload}
                          className="hidden"
                        />
                      </label>
                    </div>

                    {/* Photo examples - smaller on desktop */}
                    <div className="max-w-xl mx-auto">
                      <div className="grid grid-cols-2 md:grid-cols-5 gap-2">
                        {/* Good example 1: Full body */}
                        <div className="text-center">
                          <img src="images/Full body.jpg" alt="Full body example" className="w-full md:max-h-32 object-contain rounded border-2 border-green-400 mb-1" />
                          <span className="text-xs text-green-600 font-medium">âœ“ {language === 'de' ? 'GanzkÃ¶rper' : language === 'fr' ? 'Corps entier' : 'Full body'}</span>
                        </div>
                        {/* Good example 2: Upper body */}
                        <div className="text-center">
                          <img src="images/Upper body.jpg" alt="Upper body example" className="w-full md:max-h-32 object-contain rounded border-2 border-green-400 mb-1" />
                          <span className="text-xs text-green-600 font-medium">âœ“ {language === 'de' ? 'OberkÃ¶rper' : language === 'fr' ? 'Buste' : 'Upper body'}</span>
                        </div>
                        {/* Bad example 1: Close up or blurry */}
                        <div className="text-center">
                          <img src="images/No zoomed in close up.jpg" alt="Too close example" className="w-full md:max-h-32 object-contain rounded border-2 border-red-400 mb-1" />
                          <span className="text-xs text-red-600 font-medium">âœ— {language === 'de' ? 'Nahaufnahme/Unscharf' : language === 'fr' ? 'Gros plan/Flou' : 'Close-up/Blurry'}</span>
                        </div>
                        {/* Bad example 2: Sunglasses, hat, helmet */}
                        <div className="text-center">
                          <img src="images/No sunglasses, hat or helmets.jpg" alt="No accessories example" className="w-full md:max-h-32 object-contain rounded border-2 border-red-400 mb-1" />
                          <span className="text-xs text-red-600 font-medium">âœ— {language === 'de' ? 'Brille/Hut/Helm' : language === 'fr' ? 'Lunettes/Chapeau' : 'Glasses/Hat/Helmet'}</span>
                        </div>
                        {/* Bad example 3: Crowded/multiple people */}
                        <div className="text-center">
                          <img src="images/One person not many.jpg" alt="One person only example" className="w-full md:max-h-32 object-contain rounded border-2 border-red-400 mb-1" />
                          <span className="text-xs text-red-600 font-medium">âœ— {language === 'de' ? 'Eine Person, nicht viele' : language === 'fr' ? 'Une personne, pas plusieurs' : 'One person, not many'}</span>
                        </div>
                      </div>
                    </div>
              </div>
            )}

            {currentCharacter && currentCharacter.photoUrl && (
              <div ref={characterFormRef} className="bg-white border-2 border-indigo-200 rounded-lg p-3 space-y-3">
                <h3 className="text-base font-bold text-gray-800">{currentCharacter.id ? t.editCharacter : t.startCreating}</h3>

                {/* Character Name */}
                {currentCharacter.photoUrl && (
                  <div>
                    <label className="block text-xs font-semibold mb-1">{t.characterName} *</label>
                    <input
                      type="text"
                      value={currentCharacter.name}
                      onChange={(e) => handleNameChange(e.target.value)}
                      className="w-full px-2 py-1.5 border border-gray-300 rounded text-sm"
                      placeholder={t.characterName}
                    />
                  </div>
                )}

                {currentCharacter.photoUrl && (
                <div className="grid md:grid-cols-2 gap-3">
                  <div className="md:border md:border-indigo-300 md:rounded-lg p-2 md:bg-indigo-50">
                    <label className="block text-xs font-semibold mb-2 text-center">{t.characterPhoto}</label>
                    <div className="flex flex-col items-center gap-2">
                      <img
                        src={currentCharacter.photoUrl}
                        alt="Character"
                        className="w-20 h-20 rounded-full object-cover border-2 border-indigo-400"
                      />

                      <label className="cursor-pointer bg-indigo-600 text-white px-3 py-1.5 rounded text-xs hover:bg-indigo-700 flex items-center gap-1 font-semibold">
                        <Icon name="upload" size={14} /> {t.uploadPhoto}
                        <input
                          type="file"
                          accept="image/*"
                          onChange={handlePhotoUpload}
                          className="hidden"
                        />
                      </label>

                      {/* Developer Mode Toggle - Admin only */}
                      {currentUser && currentUser.role === 'admin' && (
                        <button
                          onClick={() => setCharacterDevMode(!characterDevMode)}
                          className={`px-3 py-1 rounded text-xs font-semibold flex items-center gap-1 ${
                            characterDevMode
                              ? 'bg-purple-600 text-white'
                              : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
                          }`}
                        >
                          <Icon name="code" size={12} />
                          {language === 'de' ? 'Dev' : 'Dev'}
                          {characterDevMode ? ' âœ“' : ''}
                        </button>
                      )}

                      {/* Developer Mode Panel - Admin only */}
                      {currentUser && currentUser.role === 'admin' && characterDevMode && (
                        <div className="w-full bg-purple-50 border-2 border-purple-400 rounded-lg p-2 space-y-2 mt-2">
                          <h4 className="text-xs font-bold text-purple-800 flex items-center gap-1">
                            <Icon name="code" size={12} />
                            Photo Analysis (Python MediaPipe)
                          </h4>

                          {/* Three Image Outputs - Face, Body, Body No BG */}
                          <div className="grid grid-cols-3 gap-2">
                            {/* Face Crop */}
                            <div className="text-center">
                              <p className="text-[10px] font-semibold text-green-700 mb-1">Face Crop</p>
                              <div className="border border-green-300 rounded bg-white p-1 aspect-square flex items-center justify-center overflow-hidden">
                                {currentCharacter.photoUrl ? (
                                  <img src={currentCharacter.photoUrl} alt="Face" className="max-w-full max-h-full object-contain" />
                                ) : <div className="text-[8px] text-gray-400">N/A</div>}
                              </div>
                              <p className="text-[8px] text-gray-500 mt-0.5">Display avatar</p>
                            </div>

                            {/* Body Crop */}
                            <div className="text-center">
                              <p className="text-[10px] font-semibold text-blue-700 mb-1">Body Crop</p>
                              <div className="border border-blue-300 rounded bg-white p-1 aspect-square flex items-center justify-center overflow-hidden">
                                {currentCharacter.bodyPhotoUrl ? (
                                  <img src={currentCharacter.bodyPhotoUrl} alt="Body" className="max-w-full max-h-full object-contain" />
                                ) : <div className="text-[8px] text-gray-400">N/A</div>}
                              </div>
                              <p className="text-[8px] text-gray-500 mt-0.5">With background</p>
                            </div>

                            {/* Body No Background */}
                            <div className="text-center">
                              <p className="text-[10px] font-semibold text-purple-700 mb-1">Body No BG</p>
                              <div className="border border-purple-300 rounded bg-gray-200 p-1 aspect-square flex items-center justify-center overflow-hidden" style={{backgroundImage: 'repeating-conic-gradient(#ccc 0% 25%, transparent 0% 50%)', backgroundSize: '10px 10px'}}>
                                {currentCharacter.bodyNoBgUrl ? (
                                  <img src={currentCharacter.bodyNoBgUrl} alt="Body No BG" className="max-w-full max-h-full object-contain" />
                                ) : <div className="text-[8px] text-gray-500 bg-white px-1 rounded">N/A</div>}
                              </div>
                              <p className="text-[8px] text-green-600 mt-0.5 font-semibold">Used for images</p>
                            </div>
                          </div>

                          {/* Gemini Features */}
                          {currentCharacter.devComparison?.gemini && (
                            <div className="bg-blue-50 border border-blue-300 rounded p-2 mt-2">
                              <h5 className="text-[10px] font-bold text-blue-800 mb-1">Features (from Gemini)</h5>
                              <div className="text-[8px] grid grid-cols-2 gap-x-2 gap-y-0.5">
                                <p><span className="font-semibold">Hair:</span> {currentCharacter.devComparison.gemini?.hairColor || 'N/A'}</p>
                                <p><span className="font-semibold">Clothing:</span> {currentCharacter.devComparison.gemini?.clothing || 'N/A'}</p>
                                <p><span className="font-semibold">Skin:</span> {currentCharacter.devComparison.gemini?.skinTone || 'N/A'}</p>
                                <p><span className="font-semibold">Other:</span> {currentCharacter.devComparison.gemini?.otherFeatures || 'N/A'}</p>
                              </div>
                            </div>
                          )}

                          {/* Final Used Values */}
                          <div className="text-[9px] bg-white p-1 rounded border border-purple-300">
                            <p className="font-semibold text-purple-700">Final Bounding Boxes (used):</p>
                            <p className="text-purple-600">
                              Face: {currentCharacter.faceBox
                                ? `x:${Math.round(currentCharacter.faceBox.x)}% y:${Math.round(currentCharacter.faceBox.y)}% w:${Math.round(currentCharacter.faceBox.width)}% h:${Math.round(currentCharacter.faceBox.height)}%`
                                : 'Not detected'}
                            </p>
                            <p className="text-purple-600">
                              Body: {currentCharacter.bodyBox
                                ? `x:${Math.round(currentCharacter.bodyBox.x)}% y:${Math.round(currentCharacter.bodyBox.y)}% w:${Math.round(currentCharacter.bodyBox.width)}% h:${Math.round(currentCharacter.bodyBox.height)}%`
                                : 'Not detected'}
                            </p>
                          </div>

                          {/* Raw Gemini Response */}
                          {analyzedTraitsText && (
                            <details className="text-xs">
                              <summary className="cursor-pointer font-semibold text-purple-700 text-[10px]">
                                Raw Gemini Response
                              </summary>
                              <pre className="mt-1 text-[8px] text-purple-800 whitespace-pre-wrap font-mono bg-white p-1 rounded border border-purple-300 max-h-24 overflow-y-auto">
                                {analyzedTraitsText}
                              </pre>
                            </details>
                          )}
                        </div>
                      )}

                      {/* Generate Avatar Button - Admin only */}
                      {currentUser && currentUser.role === 'admin' && currentCharacter.photoUrl && !generatedAvatar && generatedAvatars.length === 0 && (
                        <button
                          onClick={() => generateAvatar(currentCharacter.photoUrl)}
                          disabled={isGeneratingAvatar}
                          className={`px-3 py-1.5 rounded text-xs font-semibold flex items-center gap-1 ${
                            isGeneratingAvatar
                              ? 'bg-gray-400 cursor-not-allowed'
                              : 'bg-indigo-500 text-white hover:bg-indigo-600'
                          }`}
                        >
                          {isGeneratingAvatar ? (
                            <>
                              <Icon name="loader" size={14} className="animate-spin" /> {t.generatingAvatar}
                            </>
                          ) : (
                            <>
                              <Icon name="sparkles" size={14} /> {language === 'de' ? 'Avatare (3x)' : language === 'fr' ? 'Avatars (3x)' : 'Avatars (3x)'}
                            </>
                          )}
                        </button>
                      )}

                      {/* Show 3 avatar variants for selection */}
                      {generatedAvatars.length > 0 && (
                        <div className="w-full mt-2 p-2 bg-white rounded border border-indigo-400">
                          <h3 className="text-xs font-bold text-gray-800 mb-2 text-center">
                            {language === 'de' ? 'WÃ¤hle Avatar' : language === 'fr' ? 'Choisir avatar' : 'Choose Avatar'}
                          </h3>

                          <div className="grid grid-cols-3 gap-1.5 mb-2">
                            {generatedAvatars.map((variant, index) => (
                              <div key={index} className="flex flex-col items-center">
                                <div className="relative w-full aspect-square mb-1 border border-gray-300 rounded overflow-hidden hover:border-indigo-600 transition-all cursor-pointer">
                                  <img
                                    src={variant.image}
                                    alt={variant.type}
                                    className="w-full h-full object-cover"
                                    onClick={async () => {
                                      // Compress the avatar before storing
                                      const compressedImage = await compressImage(variant.image);
                                      setGeneratedAvatar(compressedImage);
                                      if (variant.traits) {
                                        setCurrentCharacter(prev => ({
                                          ...prev,
                                          photoUrl: compressedImage,
                                          photo: null,
                                          age: variant.traits.age || prev.age,
                                          height: variant.traits.height || prev.height,
                                          build: variant.traits.build || prev.build,
                                          hairColor: variant.traits.hairColor || prev.hairColor,
                                          otherFeatures: variant.traits.otherFeatures || prev.otherFeatures
                                        }));
                                        if (variant.traits.fullText) {
                                          setAnalyzedTraitsText(variant.traits.fullText);
                                        }
                                      }
                                      setGeneratedAvatars([]); // Clear variants after selection
                                    }}
                                  />
                                </div>
                                <p className="text-[9px] font-semibold text-gray-800">{variant.type}</p>
                              </div>
                            ))}
                          </div>

                          <div className="flex gap-1">
                            <button
                              onClick={() => setGeneratedAvatars([])}
                              className="flex-1 bg-gray-500 text-white px-2 py-1 rounded text-[10px] hover:bg-gray-600 font-semibold"
                            >
                              <Icon name="x" size={10} className="inline mr-0.5" />
                              {language === 'de' ? 'Verwerfen' : language === 'fr' ? 'Rejeter' : 'Discard'}
                            </button>
                            <button
                              onClick={() => generateAvatar(currentCharacter.photoUrl)}
                              disabled={isGeneratingAvatar}
                              className="flex-1 bg-indigo-500 text-white px-2 py-1 rounded text-[10px] hover:bg-indigo-600 font-semibold disabled:bg-gray-400"
                            >
                              <Icon name="refresh-cw" size={10} className="inline mr-0.5" />
                              {language === 'de' ? 'Neu' : language === 'fr' ? 'Nouveau' : 'New'}
                            </button>
                          </div>
                        </div>
                      )}

                      {generatedAvatar && (
                        <div className="w-full mt-2 p-2 bg-white rounded border border-indigo-400">
                          <h3 className="text-xs font-bold text-gray-800 mb-2 text-center">{t.avatarGenerated}</h3>
                          <img
                            src={generatedAvatar}
                            alt="Generated Avatar"
                            className="w-full rounded mb-2"
                          />

                          {/* Use Generated Avatar / Keep Original buttons - Admin only */}
                          {currentUser && currentUser.role === 'admin' && (
                            <div className="flex gap-2 mb-3">
                              <button
                                onClick={async () => {
                                  // Compress the avatar before storing
                                  const compressedAvatar = await compressImage(generatedAvatar);

                                  // First, update the photo to use the compressed avatar
                                  setCurrentCharacter(prev => ({
                                    ...prev,
                                    photoUrl: compressedAvatar,
                                    photo: null
                                  }));

                                  // Then analyze the generated avatar to extract features
                                  const traits = await analyzeImageForTraits(generatedAvatar);
                                  if (traits) {
                                    setCurrentCharacter(prev => ({
                                      ...prev,
                                      photoUrl: compressedAvatar,
                                      photo: null,
                                      age: traits.age || prev.age,
                                      height: traits.height || prev.height,
                                      build: traits.build || prev.build,
                                      hairColor: traits.hairColor || prev.hairColor,
                                      otherFeatures: traits.otherFeatures || prev.otherFeatures
                                    }));
                                  }

                                  setGeneratedAvatar(null);
                                }}
                                className="flex-1 bg-green-500 text-white px-4 py-2 rounded-lg hover:bg-green-600 font-semibold text-sm"
                              >
                                <Icon name="check" size={16} className="inline mr-1" /> {t.useGeneratedAvatar}
                              </button>
                              <button
                                onClick={() => setGeneratedAvatar(null)}
                                className="flex-1 bg-gray-500 text-white px-4 py-2 rounded-lg hover:bg-gray-600 font-semibold text-sm"
                              >
                                <Icon name="x" size={16} className="inline mr-1" /> {t.keepOriginal}
                              </button>
                            </div>
                          )}


                          {/* Show Prompt Button - Admin only */}
                          {currentUser && currentUser.role === 'admin' && avatarPrompt && (
                            <details className="bg-gray-50 border border-gray-300 rounded-lg p-2 mb-2">
                              <summary className="cursor-pointer text-xs font-semibold text-gray-800 hover:text-gray-900">
                                {t.showPrompt}
                              </summary>
                              <pre className="mt-2 text-xs text-gray-500 whitespace-pre-wrap font-mono bg-white p-2 rounded border border-gray-200">
                                {avatarPrompt}
                              </pre>
                            </details>
                          )}

                        </div>
                      )}
                    </div>
                  </div>

                  {/* Character attributes - only show after photo is uploaded */}
                  {currentCharacter.photoUrl && (
                    <div className="md:border-2 md:border-green-300 md:rounded-lg p-4 md:bg-green-50">
                      <label className="block text-lg font-semibold mb-3 text-center md:block hidden">{t.orDescribe}</label>
                      <div className="space-y-2">
                        {/* Gender */}
                        <div className="flex items-center gap-2">
                          <label className="text-xs font-semibold whitespace-nowrap min-w-[60px]">{t.gender}:</label>
                          <select
                            value={currentCharacter.gender}
                            onChange={(e) => setCurrentCharacter({ ...currentCharacter, gender: e.target.value })}
                            className="flex-1 px-2 py-1.5 border border-gray-300 rounded text-sm"
                          >
                            <option value="male">{t.male}</option>
                            <option value="female">{t.female}</option>
                            <option value="other">{t.other}</option>
                          </select>
                        </div>

                        {/* Age and Height on same row */}
                        <div className="grid grid-cols-2 gap-2">
                          <div className="flex items-center gap-2">
                            <label className="text-xs font-semibold whitespace-nowrap">{t.age}:</label>
                            <input
                              type="number"
                              value={currentCharacter.age}
                              onChange={(e) => setCurrentCharacter({ ...currentCharacter, age: e.target.value })}
                              className="w-full px-2 py-1.5 border border-gray-300 rounded text-sm"
                              placeholder={t.age}
                              min="1"
                              max="99"
                            />
                          </div>
                          <div className="flex items-center gap-2">
                            <label className="text-xs font-semibold whitespace-nowrap">
                              {language === 'de' ? 'GrÃ¶ÃŸe:' : language === 'fr' ? 'Taille:' : 'Height:'}
                            </label>
                            <input
                              type="number"
                              value={currentCharacter.height}
                              onChange={(e) => setCurrentCharacter({ ...currentCharacter, height: e.target.value })}
                              className="w-full px-2 py-1.5 border border-gray-300 rounded text-sm"
                              placeholder="cm"
                              min="50"
                              max="250"
                            />
                          </div>
                        </div>

                        {/* Build */}
                        <div className="flex items-center gap-2">
                          <label className="text-xs font-semibold whitespace-nowrap min-w-[60px]">
                            {language === 'de' ? 'KÃ¶rperbau:' : language === 'fr' ? 'Corpulence:' : 'Build:'}
                          </label>
                          <select
                            value={currentCharacter.build}
                            onChange={(e) => setCurrentCharacter({ ...currentCharacter, build: e.target.value })}
                            className="flex-1 px-2 py-1.5 border border-gray-300 rounded text-sm"
                          >
                            <option value="">{language === 'de' ? 'WÃ¤hlen...' : language === 'fr' ? 'SÃ©lectionner...' : 'Select...'}</option>
                            <option value="slim">{language === 'de' ? 'Schlank' : language === 'fr' ? 'Mince' : 'Slim'}</option>
                            <option value="average">{language === 'de' ? 'Durchschnittlich' : language === 'fr' ? 'Moyenne' : 'Average'}</option>
                            <option value="athletic">{language === 'de' ? 'Athletisch' : language === 'fr' ? 'AthlÃ©tique' : 'Athletic'}</option>
                            <option value="chubby">{language === 'de' ? 'Mollig' : language === 'fr' ? 'PotelÃ©' : 'Chubby'}</option>
                            <option value="overweight">{language === 'de' ? 'Ãœbergewichtig' : language === 'fr' ? 'En surpoids' : 'Overweight'}</option>
                            <option value="heavily overweight">{language === 'de' ? 'Stark Ã¼bergewichtig' : language === 'fr' ? 'TrÃ¨s en surpoids' : 'Heavily Overweight'}</option>
                          </select>
                        </div>

                        {/* Hair Color and Other Features - Admin only */}
                        {currentUser && currentUser.role === 'admin' && (
                          <>
                            <div className="flex items-center gap-2">
                              <label className="text-xs font-semibold whitespace-nowrap min-w-[60px]">{t.hairColor}:</label>
                              <input
                                type="text"
                                value={currentCharacter.hairColor}
                                onChange={(e) => setCurrentCharacter({ ...currentCharacter, hairColor: e.target.value })}
                                className="flex-1 px-2 py-1.5 border border-gray-300 rounded text-sm"
                                placeholder={t.hairColor}
                              />
                            </div>
                            <div className="flex items-start gap-2">
                              <label className="text-xs font-semibold whitespace-nowrap min-w-[60px] pt-1.5">{t.otherFeatures}:</label>
                              <textarea
                                value={currentCharacter.otherFeatures}
                                onChange={(e) => setCurrentCharacter({ ...currentCharacter, otherFeatures: e.target.value })}
                                className="flex-1 px-2 py-1.5 border border-gray-300 rounded text-sm"
                                placeholder={t.descriptionPlaceholder}
                                rows={2}
                              />
                            </div>
                          </>
                        )}
                      </div>
                    </div>
                  )}
                </div>
                )}

                {/* Strengths - only show after photo is uploaded */}
                {currentCharacter.photoUrl && (
                  <div>
                    <label className="block text-lg font-semibold mb-2">
                      {t.strengths} * ({t.selectAtLeast} 3) - {t.selected}: {currentCharacter.strengths.length}
                    </label>
                    <div className="flex flex-wrap gap-2 mb-3">
                      {allStrengths.map(strength => (
                        <button
                          key={strength}
                          onClick={() => toggleArrayItem('strengths', strength)}
                          className={`px-3 py-1 rounded-full text-sm ${
                            currentCharacter.strengths.includes(strength)
                              ? 'bg-green-500 text-white'
                              : 'bg-gray-200 text-gray-800 hover:bg-gray-300'
                          }`}
                        >
                          {strength}
                        </button>
                      ))}
                    </div>
                    <div className="flex gap-2">
                      <input
                        type="text"
                        value={newStrength}
                        onChange={(e) => setNewStrength(e.target.value)}
                        onKeyPress={(e) => e.key === 'Enter' && addCustomStrength()}
                        placeholder={t.addCustomStrengths}
                        className="flex-1 px-3 py-2 border border-gray-300 rounded-lg"
                      />
                      <button
                        onClick={addCustomStrength}
                        className="bg-indigo-600 text-white px-4 py-2 rounded-lg hover:bg-indigo-700"
                      >
                        <Icon name="plus" size={20} />
                      </button>
                    </div>
                  </div>
                )}

                {/* Weaknesses - only show after photo is uploaded */}
                {currentCharacter.photoUrl && (
                  <div>
                    <label className="block text-lg font-semibold mb-2">
                      {t.weaknesses} * ({t.selectAtLeast} 2) - {t.selected}: {currentCharacter.weaknesses.length}
                    </label>
                    <div className="flex flex-wrap gap-2 mb-3">
                      {allWeaknesses.map(weakness => (
                        <button
                          key={weakness}
                          onClick={() => toggleArrayItem('weaknesses', weakness)}
                          className={`px-3 py-1 rounded-full text-sm ${
                            currentCharacter.weaknesses.includes(weakness)
                              ? 'bg-indigo-500 text-white'
                              : 'bg-gray-200 text-gray-800 hover:bg-gray-300'
                          }`}
                        >
                          {weakness}
                        </button>
                      ))}
                    </div>
                    <div className="flex gap-2">
                      <input
                        type="text"
                        value={newWeakness}
                        onChange={(e) => setNewWeakness(e.target.value)}
                        onKeyPress={(e) => e.key === 'Enter' && addCustomWeakness()}
                        placeholder={t.addCustomWeaknesses}
                        className="flex-1 px-3 py-2 border border-gray-300 rounded-lg"
                      />
                      <button
                        onClick={addCustomWeakness}
                        className="bg-indigo-600 text-white px-4 py-2 rounded-lg hover:bg-indigo-700"
                      >
                        <Icon name="plus" size={20} />
                      </button>
                    </div>
                  </div>
                )}

                {/* Special details - only show after photo is uploaded */}
                {currentCharacter.photoUrl && (
                  <div>
                    <label className="block text-lg font-semibold mb-2">{t.specialDetails}</label>
                    <textarea
                      value={currentCharacter.specialDetails}
                      onChange={(e) => setCurrentCharacter({ ...currentCharacter, specialDetails: e.target.value })}
                      className="w-full px-4 py-3 border-2 border-gray-300 rounded-lg text-lg"
                      placeholder={t.specialDetailsPlaceholder}
                      rows={3}
                    />
                  </div>
                )}

                {/* Save/Cancel buttons - only show after photo is uploaded */}
                {currentCharacter.photoUrl && (
                  <div className="flex gap-4">
                    <button
                      onClick={cancelEditCharacter}
                      className="flex-1 bg-gray-300 text-gray-800 px-6 py-3 rounded-lg hover:bg-gray-400 font-semibold"
                    >
                      {t.cancel}
                    </button>
                    <button
                      onClick={saveCurrentCharacter}
                      disabled={!canSave}
                      className={`flex-1 px-6 py-3 rounded-lg font-semibold ${
                        canSave
                          ? 'bg-indigo-600 text-white hover:bg-indigo-700'
                          : 'bg-gray-300 text-gray-500 cursor-not-allowed'
                      }`}
                    >
                      {t.saveCharacter}
                    </button>
                  </div>
                )}
              </div>
            )}
          </div>
        );
      };

      const renderStep3 = () => (
        <div className="space-y-4">
          <h2 className="text-2xl md:text-3xl font-bold text-gray-800 flex items-center gap-2">
            <Icon name="heart" size={24} /> {t.defineRelationships}
          </h2>
          <p className="text-sm text-gray-500">{t.defineRelationshipsDesc}</p>

          {/* Compact relationship cards */}
          <div className="grid gap-3 md:gap-4">
            {characters.map((char1, i) => (
              <React.Fragment key={char1.id}>
                {characters.map((char2, j) => {
                  if (i >= j) return null;
                  const key1 = `${char1.id}-${char2.id}`;

                  const isNotKnown = !relationships[key1] || isNotKnownRelationship(relationships[key1]);

                  return (
                    <div key={key1} className={`rounded-lg p-3 md:p-4 ${isNotKnown ? 'bg-white border-red-500 border-[3px]' : 'bg-blue-50 border-blue-300 border-2'}`}>
                      {/* Layout: Character photos on sides, dropdown + details in center - max 75% width on wide screens */}
                      <div className="flex items-center justify-center gap-3 md:gap-6 max-w-[75%] mx-auto">
                        {/* Character 1 - Left side */}
                        <div className="flex flex-col items-center gap-1 flex-shrink-0">
                          {(char1.thumbnailUrl || char1.photoUrl) && (
                            <img src={char1.thumbnailUrl || char1.photoUrl} alt={char1.name} className="w-14 h-14 md:w-16 md:h-16 rounded-full object-cover" />
                          )}
                          <span className="font-semibold text-xs md:text-sm text-center max-w-[80px] truncate">{char1.name}</span>
                        </div>

                        {/* Center: Dropdown + Details stacked - flex-1 for dynamic scaling */}
                        <div className="flex-1 flex flex-col items-center gap-1 min-w-0">
                          <select
                            value={relationships[key1] || getNotKnownRelationship(language)}
                            onChange={(e) => {
                              const value = e.target.value;
                              if (value === '__CREATE_CUSTOM__') {
                                const customRel = prompt(language === 'de' ? 'Beziehung eingeben:' : language === 'fr' ? 'Entrer la relation:' : 'Enter relationship:');
                                if (customRel && customRel.trim()) {
                                  setCustomRelationships([...customRelationships, customRel.trim()]);
                                  updateRelationship(char1.id, char2.id, customRel.trim());
                                }
                              } else {
                                updateRelationship(char1.id, char2.id, value);
                              }
                            }}
                            className={`w-full max-w-[500px] px-2 py-1.5 border rounded text-sm font-medium text-center ${isNotKnown ? 'bg-white border-red-400 border-2' : 'bg-blue-100 border-blue-400'}`}
                          >
                            <option value="__CREATE_CUSTOM__">+ {language === 'de' ? 'Eigene' : language === 'fr' ? 'PersonnalisÃ©' : 'Custom'}</option>
                            {allRelationships.map((type, idx) => (
                              <option key={idx} value={type.value[language]}>{type.value[language]}</option>
                            ))}
                          </select>
                          {/* Details input below dropdown */}
                          {!isNotKnown && (
                            <input
                              type="text"
                              value={relationshipTexts[key1] || ''}
                              onChange={(e) => setRelationshipTexts({ ...relationshipTexts, [key1]: e.target.value })}
                              placeholder={language === 'de' ? 'Details...' : language === 'fr' ? 'DÃ©tails...' : 'Details...'}
                              className="w-full max-w-[500px] px-2 py-1 border border-blue-300 rounded text-xs text-center bg-white"
                            />
                          )}
                        </div>

                        {/* Character 2 - Right side */}
                        <div className="flex flex-col items-center gap-1 flex-shrink-0">
                          {(char2.thumbnailUrl || char2.photoUrl) && (
                            <img src={char2.thumbnailUrl || char2.photoUrl} alt={char2.name} className="w-14 h-14 md:w-16 md:h-16 rounded-full object-cover" />
                          )}
                          <span className="font-semibold text-xs md:text-sm text-center max-w-[80px] truncate">{char2.name}</span>
                        </div>
                      </div>
                    </div>
                  );
                })}
              </React.Fragment>
            ))}
          </div>
        </div>
      );

      const renderStep4 = () => (
        <div className="space-y-6">
          <div className="flex justify-between items-center flex-wrap gap-2">
            <h2 className="text-3xl font-bold text-gray-800 flex items-center gap-2">
              <Icon name="wand-2" size={24} /> {t.storySettings}
            </h2>
            {currentUser && currentUser.role === 'admin' && (
              <div className="flex items-center gap-2 bg-gray-100 px-3 py-2 rounded-lg border border-gray-300">
                <label className="flex items-center gap-2 cursor-pointer">
                  <input
                    type="checkbox"
                    checked={developerMode}
                    onChange={(e) => setDeveloperMode(e.target.checked)}
                    className="w-4 h-4"
                  />
                  <span className="text-sm font-semibold text-gray-800">
                    {language === 'de' ? 'Entwicklermodus' : language === 'fr' ? 'Mode dÃ©veloppeur' : 'Developer Mode'}
                  </span>
                </label>
              </div>
            )}
          </div>


          <div className="space-y-6">
            <div>
              <label className="block text-xl font-semibold mb-3">{t.selectMainCharacters}</label>
              <div className="grid md:grid-cols-2 gap-3">
                {characters.map(char => (
                  <button
                    key={char.id}
                    onClick={() => toggleMainCharacter(char.id)}
                    className={`p-4 rounded-lg border-2 transition-all text-left ${
                      mainCharacters.includes(char.id)
                        ? 'border-indigo-600 bg-indigo-50'
                        : 'border-gray-200 hover:border-indigo-300'
                    }`}
                  >
                    <div className="flex items-center gap-3">
                      {(char.thumbnailUrl || char.photoUrl) && (
                        <img src={char.thumbnailUrl || char.photoUrl} alt={char.name} className="w-12 h-12 rounded-full object-cover" />
                      )}
                      <div className="flex-1">
                        <div className="font-bold text-base flex items-center gap-2">
                          {char.name}
                          <span className={mainCharacters.includes(char.id) ? 'inline-block' : 'hidden'}>
                            <Icon name="star" size={16} className="text-indigo-600" />
                          </span>
                        </div>
                        <div className="text-sm md:text-base text-gray-500">
                          {char.gender === 'male' ? t.male : char.gender === 'female' ? t.female : t.other}, {char.age}
                        </div>
                      </div>
                    </div>
                  </button>
                ))}
              </div>
            </div>

            <div>
              <label className="block text-xl font-semibold mb-3">{t.readingLevel}</label>
              <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                {[
                  {
                    value: '1st-grade',
                    label: t.firstGrade,
                    desc: t.firstGradeDesc,
                    image: 'images/text and image on each page.jpg'
                  },
                  {
                    value: 'standard',
                    label: t.standard,
                    desc: t.standardDesc,
                    image: 'images/left page text, right page image.jpg'
                  },
                  {
                    value: 'advanced',
                    label: t.advanced,
                    desc: t.advancedDesc,
                    image: 'images/dense text left.jpg'
                  }
                ].map(level => (
                  <button
                    key={level.value}
                    onClick={() => setLanguageLevel(level.value)}
                    className={`text-left rounded-lg border-2 transition-all overflow-hidden ${
                      languageLevel === level.value
                        ? 'border-indigo-600 ring-2 ring-indigo-200'
                        : 'border-gray-200 hover:border-indigo-300'
                    }`}
                  >
                    <div className="w-full bg-gray-100 p-2">
                      <img
                        src={level.image}
                        alt={level.label}
                        className="w-full h-auto object-contain"
                      />
                    </div>
                    <div className="p-3">
                      <div className="font-semibold text-base">{level.label}</div>
                      <div className="text-sm text-gray-500">{level.desc}</div>
                    </div>
                  </button>
                ))}
              </div>
            </div>

            {/* Number of Pages - shown after book type is selected */}
            {languageLevel && (
              <div>
                <label className="block text-xl font-semibold mb-3">
                  {t.numberOfPages}
                </label>
                <select
                  value={pages}
                  onChange={(e) => setPages(parseInt(e.target.value))}
                  className="w-full px-4 py-3 border-2 border-indigo-200 rounded-lg focus:border-indigo-600 focus:outline-none text-base md:text-lg font-semibold"
                >
                  {/* Admin/Developer testing option */}
                  {currentUser && currentUser.role === 'admin' && (
                    <option value="10">
                      {languageLevel === '1st-grade'
                        ? `10 ${language === 'de' ? 'Seiten (Test)' : language === 'fr' ? 'pages (Test)' : 'pages (Test)'}`
                        : `10 ${language === 'de' ? 'Seiten (5 Text + 5 Bilder) (Test)' : language === 'fr' ? 'pages (5 texte + 5 images) (Test)' : 'pages (5 text + 5 images) (Test)'}`
                      }
                    </option>
                  )}
                  {/* Normal user options */}
                  <option value="30">
                    {languageLevel === '1st-grade'
                      ? `30 ${language === 'de' ? 'Seiten' : language === 'fr' ? 'pages' : 'pages'}`
                      : `30 ${language === 'de' ? 'Seiten (15 Text + 15 Bilder)' : language === 'fr' ? 'pages (15 texte + 15 images)' : 'pages (15 text + 15 images)'}`
                    }
                  </option>
                  <option value="40">
                    {languageLevel === '1st-grade'
                      ? `40 ${language === 'de' ? 'Seiten' : language === 'fr' ? 'pages' : 'pages'}`
                      : `40 ${language === 'de' ? 'Seiten (20 Text + 20 Bilder)' : language === 'fr' ? 'pages (20 texte + 20 images)' : 'pages (20 text + 20 images)'}`
                    }
                  </option>
                  <option value="50">
                    {languageLevel === '1st-grade'
                      ? `50 ${language === 'de' ? 'Seiten' : language === 'fr' ? 'pages' : 'pages'}`
                      : `50 ${language === 'de' ? 'Seiten (25 Text + 25 Bilder)' : language === 'fr' ? 'pages (25 texte + 25 images)' : 'pages (25 text + 25 images)'}`
                    }
                  </option>
                </select>
                <p className="text-sm text-gray-500 mt-2">
                  {languageLevel === '1st-grade'
                    ? (language === 'de' ? 'Jede Seite enthÃ¤lt ein Bild mit Text darunter' : language === 'fr' ? 'Chaque page contient une image avec du texte en dessous' : 'Each page contains an image with text below')
                    : (language === 'de' ? 'Abwechselnd Textseite und Bildseite' : language === 'fr' ? 'Alternance de pages de texte et d\'images' : 'Alternating text page and image page')
                  }
                </p>
              </div>
            )}

            {/* Additional Story Details */}
            <div>
              <label className="block text-base font-semibold text-gray-800 mb-2">{t.storyDetails}</label>
              <textarea
                value={storyDetails}
                onChange={(e) => setStoryDetails(e.target.value)}
                placeholder={t.storyDetailsPlaceholder}
                className="w-full px-3 py-2 border-2 border-gray-300 rounded-lg focus:border-indigo-600 focus:outline-none text-base"
                rows="3"
              />
            </div>

            {/* Dedication (Widmung) - Optional */}
            <div>
              <label className="block text-base font-semibold text-gray-800 mb-2">
                {language === 'de' ? 'Widmung (Optional)' : language === 'fr' ? 'DÃ©dicace (Facultatif)' : 'Dedication (Optional)'}
              </label>
              <textarea
                value={dedication}
                onChange={(e) => setDedication(e.target.value)}
                placeholder={language === 'de'
                  ? 'z.B. "FÃ¼r meine liebe Tochter Emma zum 5. Geburtstag"'
                  : language === 'fr'
                  ? 'Par exemple "Pour ma chÃ¨re fille Emma pour son 5Ã¨me anniversaire"'
                  : 'e.g. "For my dear daughter Emma on her 5th birthday"'}
                className="w-full px-3 py-2 border-2 border-gray-300 rounded-lg focus:border-indigo-600 focus:outline-none text-base"
                rows="2"
                maxLength="200"
              />
              <p className="text-sm text-gray-500 mt-1">
                {language === 'de'
                  ? 'Dieser Text wird auf Seite 0 Ihres Buches gedruckt. Wenn Sie nichts eingeben, wird Seite 0 nur eine Illustration ohne Text enthalten.'
                  : language === 'fr'
                  ? 'Ce texte sera imprimÃ© sur la page 0 de votre livre. Si vous ne saisissez rien, la page 0 ne contiendra qu\'une illustration sans texte.'
                  : 'This text will be printed on page 0 of your book. If you leave it empty, page 0 will contain only an illustration with no text.'}
              </p>
            </div>

            {/* Developer mode only: Image Generation Mode Toggle */}
            {developerMode && (
              <div className="bg-amber-50 rounded-lg p-4 border border-amber-200">
                <div className="flex items-center justify-between flex-wrap gap-3">
                  <div>
                    <h4 className="font-semibold text-gray-800 flex items-center gap-2">
                      <Icon name="image" size={18} className="text-amber-600" />
                      {language === 'de' ? 'Bildgenerierungsmodus' : language === 'fr' ? 'Mode de gÃ©nÃ©ration d\'images' : 'Image Generation Mode'}
                    </h4>
                    <p className="text-sm text-gray-600 mt-1">
                      {(imageGenMode || serverImageGenMode) === 'sequential'
                        ? (language === 'de' ? 'Sequentiell: Jedes Bild nutzt das vorherige als Referenz (langsamer, aber konsistentere Charaktere)' : language === 'fr' ? 'SÃ©quentiel: Chaque image utilise la prÃ©cÃ©dente comme rÃ©fÃ©rence (plus lent, personnages plus cohÃ©rents)' : 'Sequential: Each image uses previous as reference (slower, but more consistent characters)')
                        : (language === 'de' ? 'Parallel: Alle Bilder gleichzeitig generieren (schneller, aber weniger konsistent)' : language === 'fr' ? 'ParallÃ¨le: GÃ©nÃ©rer toutes les images simultanÃ©ment (plus rapide, moins cohÃ©rent)' : 'Parallel: Generate all images simultaneously (faster, but less consistent)')
                      }
                    </p>
                  </div>
                  <div className="flex gap-2">
                    <button
                      onClick={() => setImageGenMode('parallel')}
                      className={`px-4 py-2 rounded-lg text-sm font-semibold transition-colors ${
                        (imageGenMode || serverImageGenMode) === 'parallel'
                          ? 'bg-amber-600 text-white'
                          : 'bg-white text-gray-700 border border-gray-300 hover:bg-gray-100'
                      }`}
                    >
                      âš¡ Parallel
                    </button>
                    <button
                      onClick={() => setImageGenMode('sequential')}
                      className={`px-4 py-2 rounded-lg text-sm font-semibold transition-colors ${
                        (imageGenMode || serverImageGenMode) === 'sequential'
                          ? 'bg-amber-600 text-white'
                          : 'bg-white text-gray-700 border border-gray-300 hover:bg-gray-100'
                      }`}
                    >
                      ðŸ”— Sequential
                    </button>
                  </div>
                </div>
              </div>
            )}

            {/* Two-stage generation: Outline first, then story - Only show in Developer Mode */}
            {developerMode && (
              <>
                {!editableOutline ? (
                  // Stage 1: Generate Outline
                  <>
                    <button
                      onClick={generateOutline}
                      disabled={isGeneratingOutline || characters.length === 0 || (userQuota && !userQuota.unlimited && userQuota.remaining <= 0)}
                      className={`w-full py-4 rounded-lg font-bold text-lg flex items-center justify-center gap-2 ${
                        isGeneratingOutline || characters.length === 0 || (userQuota && !userQuota.unlimited && userQuota.remaining <= 0)
                          ? 'bg-gray-300 text-gray-500 cursor-not-allowed'
                          : 'bg-indigo-500 text-white hover:bg-indigo-600'
                      }`}
                    >
                      <Icon name="list" size={24} />
                      {isGeneratingOutline ? t.generatingOutline : t.generateOutline}
                    </button>
                    {userQuota && !userQuota.unlimited && userQuota.remaining <= 0 && (
                      <p className="text-sm text-red-600 font-semibold mt-2 text-center">
                        {language === 'de' ? 'Keine Credits mehr verfÃ¼gbar. Kontaktieren Sie den Administrator fÃ¼r mehr Credits.' :
                         language === 'fr' ? 'Plus de crÃ©dits disponibles. Contactez l\'administrateur pour plus de crÃ©dits.' :
                         'No credits remaining. Contact administrator for more credits.'}
                      </p>
                    )}
                  </>
                ) : (
                  // Stage 2: Show outline and Generate Story button
                  <div className="space-y-4">
                    <div className="md:bg-green-50 md:border-2 md:border-green-200 md:rounded-xl p-4 md:p-6">
                      <div className="flex justify-between items-center mb-3">
                        <h3 className="text-lg font-bold text-green-700">{t.outlineReady}</h3>
                        <button
                          onClick={() => {
                            setEditableOutline('');
                            setStoryOutline('');
                          }}
                          className="bg-indigo-500 text-white px-3 py-1 rounded-lg hover:bg-indigo-600 flex items-center gap-1 text-sm"
                        >
                          <Icon name="refresh-cw" size={14} />
                          {t.regenerateOutline}
                        </button>
                      </div>
                      <p className="text-sm text-green-700 mb-3">{t.editOutline}</p>
                      <textarea
                        value={editableOutline}
                        onChange={(e) => setEditableOutline(e.target.value)}
                        className="w-full h-64 px-4 py-3 border-2 border-green-300 rounded-lg resize-y bg-white"
                        placeholder="Story outline..."
                      />
                    </div>

                    <button
                      onClick={generateStory}
                      disabled={isGenerating || !editableOutline || (userQuota && !userQuota.unlimited && userQuota.remaining <= 0)}
                      className={`w-full py-4 rounded-lg font-bold text-lg flex items-center justify-center gap-2 ${
                        isGenerating || !editableOutline || (userQuota && !userQuota.unlimited && userQuota.remaining <= 0)
                          ? 'bg-gray-300 text-gray-500 cursor-not-allowed'
                          : 'bg-indigo-600 text-white hover:bg-indigo-700'
                      }`}
                    >
                      <Icon name="wand-2" size={24} />
                      {isGenerating ? t.creating : t.generateStory}
                    </button>
                    {userQuota && !userQuota.unlimited && userQuota.remaining <= 0 && (
                      <p className="text-sm text-red-600 font-semibold mt-2 text-center">
                        {language === 'de' ? 'Keine Credits mehr verfÃ¼gbar. Kontaktieren Sie den Administrator fÃ¼r mehr Credits.' :
                         language === 'fr' ? 'Plus de crÃ©dits disponibles. Contactez l\'administrateur pour plus de crÃ©dits.' :
                         'No credits remaining. Contact administrator for more credits.'}
                      </p>
                    )}
                  </div>
                )}
              </>
            )}

            {/* Progress indicator for multi-part generation */}
            {generationProgress.total > 0 && (
              <div className="mt-6 bg-indigo-50 border-2 border-indigo-200 rounded-lg p-4">
                <div className="mb-2">
                  <div className="w-full bg-indigo-200 rounded-full h-2 overflow-hidden">
                    <div
                      className="bg-indigo-600 h-full rounded-full transition-all duration-500 ease-out"
                      style={{ width: `${(generationProgress.current / generationProgress.total) * 100}%` }}
                    ></div>
                  </div>
                </div>
                <p className="text-xs text-indigo-600 text-center">
                  {language === 'de' ? 'Geschichte wird generiert, dies kann einige Minuten dauern...' :
                   language === 'fr' ? 'GÃ©nÃ©ration de l\'histoire, cela peut prendre quelques minutes...' :
                   'Generating story, this will take a few minutes...'}
                </p>
              </div>
            )}

            {/* Generate Story Button - Always visible (works for both normal users and developer mode) */}
            <button
              onClick={runAutoMode}
              disabled={characters.length === 0 || isGenerating || isGeneratingOutline || isGeneratingScenes || isGeneratingImages || (userQuota && !userQuota.unlimited && userQuota.remaining <= 0)}
              className={`w-full py-3 rounded-lg font-bold text-base flex items-center justify-center gap-2 ${
                characters.length === 0 || isGenerating || isGeneratingOutline || isGeneratingScenes || isGeneratingImages || (userQuota && !userQuota.unlimited && userQuota.remaining <= 0)
                  ? 'bg-gray-400 cursor-not-allowed'
                  : 'bg-indigo-600 text-white hover:bg-indigo-700'
              }`}
            >
              <Icon name="sparkles" size={20} />
              {language === 'de' ? 'Geschichte Generieren' : language === 'fr' ? 'GÃ©nÃ©rer l\'histoire' : 'Generate Story'}
            </button>

            {/* Developer Mode: Generate Text Only (no images) */}
            {developerMode && (
              <button
                onClick={() => runAutoModeBackground(true)}
                disabled={characters.length === 0 || isGenerating || isGeneratingOutline || isGeneratingScenes || isGeneratingImages}
                className={`w-full py-3 rounded-lg font-bold text-base flex items-center justify-center gap-2 ${
                  characters.length === 0 || isGenerating || isGeneratingOutline || isGeneratingScenes || isGeneratingImages
                    ? 'bg-gray-400 cursor-not-allowed'
                    : 'bg-yellow-500 text-white hover:bg-yellow-600'
                }`}
              >
                <Icon name="file-text" size={20} />
                {language === 'de' ? 'Nur Text generieren (ohne Bilder)' : language === 'fr' ? 'GÃ©nÃ©rer le texte uniquement (sans images)' : 'Generate Text Only (no images)'}
              </button>
            )}
            {userQuota && !userQuota.unlimited && userQuota.remaining <= 0 && (
              <p className="text-xs text-red-600 font-semibold text-center">
                {language === 'de' ? 'Keine Credits mehr verfÃ¼gbar. Kontaktieren Sie den Administrator fÃ¼r mehr Credits.' :
                 language === 'fr' ? 'Plus de crÃ©dits disponibles. Contactez l\'administrateur pour plus de crÃ©dits.' :
                 'No credits remaining. Contact administrator for more credits.'}
              </p>
            )}
          </div>
        </div>
      );

      const renderStep5 = () => {
        // Parse story by pages for side-by-side display - handle both formats:
        // - Markdown format: ## Seite 1 or ## Page 1
        // - Old format: --- Page 1 --- or --- Seite 1 ---
        const pageMatches = generatedStory ? generatedStory.split(/(?:---\s*(?:Page|Seite)\s+\d+\s*---|##\s*(?:Page|Seite)\s+\d+)/i) : [];
        const storyPages = pageMatches.slice(1).filter(p => p.trim().length > 0);

        return (
        <div className="space-y-6">
          <div className="flex justify-between items-center flex-wrap gap-3">
            <h2 className="text-2xl font-bold text-gray-800 flex items-center gap-2">
              <Icon name="book-open" size={24} /> {t.yourStory}
            </h2>
            {currentUser && currentUser.role === 'admin' && (
              <div className="flex items-center gap-3">
                {/* Developer Mode Toggle - Admin only */}
                <div className="flex items-center gap-2 bg-gray-100 px-3 py-2 rounded-lg border border-gray-300">
                  <label className="flex items-center gap-2 cursor-pointer">
                    <input
                      type="checkbox"
                      checked={developerMode}
                      onChange={(e) => setDeveloperMode(e.target.checked)}
                      className="w-4 h-4"
                    />
                    <span className="text-sm font-semibold text-gray-800">
                      {language === 'de' ? 'Entwicklermodus' : language === 'fr' ? 'Mode dÃ©veloppeur' : 'Developer Mode'}
                    </span>
                  </label>
                </div>
              </div>
            )}
          </div>

          {/* 1. Prompt Used - Developer Mode Only */}
          {developerMode && generatedPrompt && (
            <div className="bg-gray-50 border-2 border-gray-300 rounded-xl p-6">
              <div className="flex justify-between items-center mb-4">
                <h3 className="text-lg font-bold text-gray-800">{t.promptUsed}</h3>
                <button
                  onClick={() => setShowPrompt(!showPrompt)}
                  className="bg-gray-500 text-white px-4 py-2 rounded-lg hover:bg-gray-600 flex items-center gap-2"
                >
                  <Icon name={showPrompt ? "eye-off" : "eye"} size={20} />
                  {showPrompt ? t.hidePrompt : t.viewPrompt}
                </button>
              </div>
              {showPrompt && (
                <div className="bg-white border border-gray-300 rounded-lg p-4 mt-4">
                  <pre className="whitespace-pre-wrap text-sm text-gray-800 font-mono">
                    {generatedPrompt}
                  </pre>
                </div>
              )}
            </div>
          )}

          {/* 2. Story Outline - Developer Mode Only */}
          {developerMode && storyOutline && (
            <div className="md:bg-indigo-50 md:border-2 md:border-indigo-200 md:rounded-xl p-4 md:p-6">
              <h3 className="text-lg font-bold text-gray-800 mb-3 flex items-center gap-2">
                <Icon name="list" size={20} /> Story Outline
              </h3>
              <div className="bg-white border border-indigo-200 rounded-lg p-4">
                <pre className="whitespace-pre-wrap text-sm text-gray-800 font-mono">
                  {storyOutline}
                </pre>
              </div>
            </div>
          )}

          {/* 3. Full Story Text - Developer Mode Only */}
          {developerMode && (
            <div className="md:bg-white md:border-2 md:border-indigo-200 md:rounded-xl p-4 md:p-8">
              <div className="flex justify-between items-center mb-4">
                <h3 className="text-lg font-bold text-gray-800">Full Story Text (Parsed)</h3>
                <button
                  onClick={() => {
                    if (editingStory) {
                      setGeneratedStory(editableStory);
                      setEditingStory(false);
                    } else {
                      setEditableStory(generatedStory);
                      setEditingStory(true);
                    }
                  }}
                  className="bg-indigo-500 text-white px-4 py-2 rounded-lg hover:bg-indigo-600 flex items-center gap-2"
                >
                  <Icon name={editingStory ? "save" : "edit"} size={16} />
                  {editingStory ? t.saveStory : t.editStory}
                </button>
              </div>
              {editingStory ? (
                <textarea
                  value={editableStory}
                  onChange={(e) => setEditableStory(e.target.value)}
                  className="w-full h-96 px-4 py-3 border border-gray-300 rounded-lg font-serif text-gray-800 resize-none"
                />
              ) : (
                <div className="prose max-w-none whitespace-pre-wrap leading-relaxed text-gray-800">
                  {generatedStory}
                </div>
              )}
            </div>
          )}

          {/* 4. Raw AI Response - Developer Mode Only */}
          {developerMode && rawAIResponse && (
            <div className="md:bg-yellow-50 md:border-2 md:border-yellow-300 md:rounded-xl p-4 md:p-6">
              <details className="group">
                <summary className="cursor-pointer text-lg font-bold text-yellow-800 mb-3 flex items-center gap-2 hover:text-yellow-900">
                  <Icon name="code" size={20} />
                  Raw AI Response (Unparsed)
                  <span className="text-sm font-normal text-yellow-600 ml-2">Click to expand</span>
                </summary>
                <div className="mt-4 bg-white border border-yellow-200 rounded-lg p-4 max-h-96 overflow-auto">
                  <pre className="whitespace-pre-wrap text-sm text-gray-800 font-mono">
                    {rawAIResponse}
                  </pre>
                </div>
              </details>
            </div>
          )}

          <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-3">
            {/* Developer mode only: TXT download */}
            {developerMode && (
              <button
                onClick={() => downloadStory('txt')}
                className="bg-indigo-600 text-white px-6 py-3 rounded-lg hover:bg-indigo-700 font-semibold flex items-center justify-center gap-2"
              >
                <Icon name="download" size={20} /> {t.downloadTXT}
              </button>
            )}
            {/* All users: Printable PDF */}
            {sceneImages.length > 0 && (
              <button
                onClick={downloadPrintablePDF}
                disabled={isGenerating}
                className={`bg-green-500 text-white px-6 py-3 rounded-lg font-semibold flex items-center justify-center gap-2 ${isGenerating ? 'opacity-50 cursor-not-allowed' : 'hover:bg-green-600'}`}
              >
                <Icon name="file-text" size={20} /> {language === 'de' ? 'PDF herunterladen' : language === 'fr' ? 'TÃ©lÃ©charger PDF' : 'Download PDF'}
              </button>
            )}
            {/* Admin only: Print Book via print provider */}
            {currentUser && currentUser.role === 'admin' && sceneImages.length > 0 && (
              <button
                onClick={orderPrintedBook}
                disabled={isGenerating}
                className={`bg-indigo-500 text-white px-6 py-3 rounded-lg font-semibold flex items-center justify-center gap-2 ${isGenerating ? 'opacity-50 cursor-not-allowed' : 'hover:bg-indigo-600'}`}
              >
                <Icon name="printer" size={20} /> {language === 'de' ? 'Buch drucken' : language === 'fr' ? 'Imprimer le livre' : 'Print Book'}
              </button>
            )}
            {/* Buy Book via Stripe */}
            {sceneImages.length > 0 && currentStoryId && (
              <button
                disabled={isGenerating}
                onClick={async () => {
                  try {
                    console.log('ðŸ’³ [STRIPE] Initiating checkout for story:', currentStoryId);
                    console.log('   Story Title:', storyTitle);
                    console.log('   User:', currentUser?.username);

                    const response = await fetch(`${API_URL}/api/stripe/create-checkout-session`, {
                      method: 'POST',
                      headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`
                      },
                      body: JSON.stringify({ storyId: currentStoryId })
                    });

                    const data = await response.json();

                    if (!response.ok) {
                      console.error('âŒ [STRIPE] Failed to create checkout session:', data.error);
                      alert('Failed to create checkout session: ' + data.error);
                      return;
                    }

                    console.log('âœ… [STRIPE] Checkout session created:', data.sessionId);
                    console.log('   Checkout URL:', data.url);
                    console.log('   Redirecting to Stripe...');

                    // Redirect to Stripe Checkout
                    window.location.href = data.url;
                  } catch (err) {
                    console.error('âŒ [STRIPE] Error:', err);
                    alert('Error creating checkout: ' + err.message);
                  }
                }}
                className={`bg-indigo-500 text-white px-6 py-3 rounded-lg font-semibold flex items-center justify-center gap-2 ${isGenerating ? 'opacity-50 cursor-not-allowed' : 'hover:bg-indigo-600'}`}
              >
                <Icon name="shopping-cart" size={20} /> {language === 'de' ? 'Buch kaufen (CHF 36)' : language === 'fr' ? 'Acheter le livre (CHF 36)' : 'Buy Book (CHF 36)'}
              </button>
            )}
            {/* Developer mode only: Download Prompt */}
            {developerMode && generatedPrompt && (
              <button
                onClick={downloadPrompt}
                className="bg-indigo-600 text-white px-6 py-3 rounded-lg hover:bg-indigo-700 font-semibold flex items-center justify-center gap-2"
              >
                <Icon name="download" size={20} /> {t.downloadPrompt}
              </button>
            )}
            {/* Developer mode only: Generate Scenes */}
            {developerMode && (
              <button
                onClick={generateScenes}
                disabled={isGeneratingScenes || !generatedStory}
                className={`px-6 py-3 rounded-lg font-semibold flex items-center justify-center gap-2 ${
                  isGeneratingScenes || !generatedStory
                    ? 'bg-gray-300 text-gray-500 cursor-not-allowed'
                    : 'bg-green-500 text-white hover:bg-green-600'
                }`}
              >
                <Icon name="image" size={20} /> {isGeneratingScenes ? t.creatingScenes : t.createScenes}
              </button>
            )}
            {/* Developer mode only: Download Scenes & Generate Images */}
            {developerMode && Array.isArray(sceneDescriptions) && sceneDescriptions.length > 0 && (
              <>
                <button
                  onClick={downloadScenes}
                  className="bg-green-500 text-white px-6 py-3 rounded-lg hover:bg-green-600 font-semibold flex items-center justify-center gap-2"
                >
                  <Icon name="download" size={20} /> {t.downloadScenes}
                </button>
                <button
                  onClick={generateSceneImages}
                  disabled={isGeneratingImages}
                  className={`px-6 py-3 rounded-lg font-semibold flex items-center justify-center gap-2 ${
                    isGeneratingImages
                      ? 'bg-gray-300 text-gray-500 cursor-not-allowed'
                      : 'bg-indigo-500 text-white hover:bg-indigo-600'
                  }`}
                >
                  <Icon name="sparkles" size={20} /> {isGeneratingImages ? t.generatingImages : t.generateImages}
                </button>
              </>
            )}
            {/* Developer mode only: Download All Images */}
            {developerMode && sceneImages.length > 0 && (
              <button
                onClick={() => {
                  sceneImages.forEach((img, i) => {
                    if (img.imageData) {
                      setTimeout(() => downloadImage(img.imageData, img.pageNumber), i * 100);
                    }
                  });
                }}
                className="bg-indigo-500 text-white px-6 py-3 rounded-lg hover:bg-indigo-600 font-semibold flex items-center justify-center gap-2"
              >
                <Icon name="download" size={20} /> Download All Images
              </button>
            )}
            <button
              onClick={resetAllStoryState}
              disabled={isGenerating}
              className={`bg-indigo-500 text-white px-6 py-3 rounded-lg font-semibold flex items-center justify-center gap-2 sm:col-span-2 lg:col-span-1 ${isGenerating ? 'opacity-50 cursor-not-allowed' : 'hover:bg-indigo-600'}`}
            >
              {t.createAnotherStory}
            </button>
          </div>

          {/* Display Cover Images with Controls */}
          {(coverImages.frontCover || coverImages.initialPage || coverImages.backCover || coverImagePrompts.frontCover || coverImagePrompts.initialPage || coverImagePrompts.backCover) && (
            <div className="bg-indigo-50 border-2 border-indigo-200 rounded-xl p-6 mt-6">
              <h3 className="text-xl font-bold text-gray-800 mb-4 flex items-center gap-2">
                <Icon name="book" size={24} /> Cover Pages
              </h3>
              {/* First row: Front Cover and Initial Page */}
              <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                {/* Front Cover */}
                {(coverImages.frontCover || coverImagePrompts.frontCover) && (
                  <div className="bg-white border-2 border-indigo-300 rounded-lg p-4 shadow-lg">
                    <h4 className="text-lg font-bold text-gray-800 mb-3">{language === 'de' ? 'Titelseite' : language === 'fr' ? 'Couverture' : 'Front Cover'}</h4>
                    {coverImages.frontCover ? (
                      <>
                        <div className="relative mb-3">
                          <img
                            src={getCoverImageData(coverImages.frontCover)}
                            alt="Front Cover"
                            className="w-full rounded-lg shadow-md"
                          />
                        </div>
                        {currentUser && currentUser.role === 'admin' && developerMode && (
                          <>
                            <div className="flex gap-2 mb-3">
                              <button
                                onClick={() => regenerateCoverImage('frontCover')}
                                className="flex-1 bg-indigo-500 text-white px-3 py-2 rounded-lg hover:bg-indigo-600 flex items-center justify-center gap-1 text-sm font-semibold"
                              >
                                <Icon name="refresh-cw" size={14} /> {t.regenerateImage}
                              </button>
                              <button
                                onClick={() => toggleCoverImageEdit('frontCover')}
                                className="flex-1 bg-indigo-500 text-white px-3 py-2 rounded-lg hover:bg-indigo-600 flex items-center justify-center gap-1 text-sm"
                              >
                                <Icon name="edit" size={14} /> {t.editImage}
                              </button>
                            </div>
                          </>
                        )}
                      </>
                    ) : (
                      <div className="bg-red-50 border-2 border-red-200 rounded-lg p-4 text-red-700 mb-3">
                        <p className="font-semibold">âš ï¸ Error generating image</p>
                      </div>
                    )}

                    {currentUser && currentUser.role === 'admin' && editingCoverImage === 'frontCover' && (
                      <div className="bg-indigo-50 border-2 border-indigo-300 rounded-lg p-3 mb-3">
                        <p className="text-sm font-semibold text-gray-800 mb-2">{t.editInstruction}</p>
                        <textarea
                          value={coverEditInstruction}
                          onChange={(e) => setCoverEditInstruction(e.target.value)}
                          placeholder={coverImagePrompts.frontCover || "Enter prompt..."}
                          className="w-full px-3 py-2 border border-indigo-300 rounded-lg text-sm mb-2 h-24"
                        />
                        <button
                          onClick={() => applyCoverImageEdit('frontCover')}
                          className="w-full bg-indigo-600 text-white px-4 py-2 rounded-lg hover:bg-indigo-700 text-sm font-semibold"
                        >
                          {t.applyEdit}
                        </button>
                      </div>
                    )}

                    {developerMode && coverSceneDescriptions.titlePage && (
                      <details className="bg-green-50 border border-green-300 rounded-lg p-3 mb-2">
                        <summary className="cursor-pointer text-sm font-semibold text-green-800 hover:text-green-900">
                          {language === 'de' ? 'Szenenbeschreibung' : language === 'fr' ? 'Description de scÃ¨ne' : 'Scene Description'}
                        </summary>
                        <pre className="mt-2 text-xs text-gray-700 whitespace-pre-wrap font-mono bg-white p-3 rounded border border-gray-200 overflow-x-auto">
                          {coverSceneDescriptions.titlePage}
                        </pre>
                      </details>
                    )}

                    {developerMode && coverImagePrompts.frontCover && (
                      <details className="bg-gray-50 border border-gray-300 rounded-lg p-3 mb-2">
                        <summary className="cursor-pointer text-sm font-semibold text-gray-800 hover:text-gray-900">
                          {t.showPrompt}
                        </summary>
                        <pre className="mt-2 text-xs text-gray-500 whitespace-pre-wrap font-mono bg-white p-3 rounded border border-gray-200 overflow-x-auto">
                          {coverImagePrompts.frontCover}
                        </pre>
                      </details>
                    )}

                    {developerMode && coverImages.frontCover?.qualityScore !== null && coverImages.frontCover?.qualityScore !== undefined && (
                      <details className="bg-indigo-50 border border-indigo-300 rounded-lg p-3 mb-2">
                        <summary className="cursor-pointer text-sm font-semibold text-indigo-700 hover:text-indigo-900 flex items-center justify-between">
                          <span>
                            {language === 'de' ? 'QualitÃ¤tsbewertung' : language === 'fr' ? 'Score de qualitÃ©' : 'Quality Score'}
                          </span>
                          <span className={`text-lg font-bold ${
                            coverImages.frontCover.qualityScore >= 80 ? 'text-green-600' :
                            coverImages.frontCover.qualityScore >= 60 ? 'text-yellow-600' :
                            'text-red-600'
                          }`}>
                            {(coverImages.frontCover.qualityScore / 10).toFixed(1)}/10
                          </span>
                        </summary>
                        {coverImages.frontCover.qualityReasoning && (
                          <div className="mt-2 text-xs text-gray-800 bg-white p-3 rounded border border-gray-200">
                            <div className="font-semibold mb-1">{language === 'de' ? 'Feedback:' : language === 'fr' ? 'Retour:' : 'Feedback:'}</div>
                            <p className="whitespace-pre-wrap">{coverImages.frontCover.qualityReasoning}</p>
                          </div>
                        )}
                      </details>
                    )}

                    {developerMode && coverImageApiCalls.frontCover && (
                      <details className="bg-indigo-50 border border-indigo-300 rounded-lg p-3">
                        <summary className="cursor-pointer text-sm font-semibold text-indigo-700 hover:text-indigo-900">
                          {language === 'de' ? 'API-Aufruf anzeigen' : language === 'fr' ? 'Afficher l\'appel API' : 'Show API Call'}
                        </summary>
                        <div className="mt-2 text-xs text-gray-800">
                          <div className="mb-2"><span className="font-semibold">Model:</span> {coverImageApiCalls.frontCover.model}</div>
                          <div className="mb-2"><span className="font-semibold">Type:</span> {coverImageApiCalls.frontCover.type}</div>
                          <pre className="text-xs text-gray-500 whitespace-pre-wrap font-mono bg-white p-3 rounded border border-gray-200 overflow-x-auto max-h-96">
                            {JSON.stringify(coverImageApiCalls.frontCover, null, 2)}
                          </pre>
                        </div>
                      </details>
                    )}
                  </div>
                )}

                {/* Initial Page */}
                {(coverImages.initialPage || coverImagePrompts.initialPage) && (
                  <div className="bg-white border-2 border-indigo-300 rounded-lg p-4 shadow-lg">
                    <h4 className="text-lg font-bold text-gray-800 mb-3">{language === 'de' ? 'Einleitungsseite' : language === 'fr' ? 'Page d\'introduction' : 'Initial Page'}</h4>
                    {coverImages.initialPage ? (
                      <>
                        <img
                          src={getCoverImageData(coverImages.initialPage)}
                          alt="Initial Page"
                          className="w-full rounded-lg shadow-md mb-3"
                        />
                        {currentUser && currentUser.role === 'admin' && developerMode && (
                          <>
                            <div className="flex gap-2 mb-3">
                              <button
                                onClick={() => regenerateCoverImage('initialPage')}
                                className="flex-1 bg-indigo-500 text-white px-3 py-2 rounded-lg hover:bg-indigo-600 flex items-center justify-center gap-1 text-sm font-semibold"
                              >
                                <Icon name="refresh-cw" size={14} /> {t.regenerateImage}
                              </button>
                              <button
                                onClick={() => toggleCoverImageEdit('initialPage')}
                                className="flex-1 bg-indigo-500 text-white px-3 py-2 rounded-lg hover:bg-indigo-600 flex items-center justify-center gap-1 text-sm"
                              >
                                <Icon name="edit" size={14} /> {t.editImage}
                              </button>
                            </div>
                          </>
                        )}
                      </>
                    ) : (
                      <div className="bg-red-50 border-2 border-red-200 rounded-lg p-4 text-red-700 mb-3">
                        <p className="font-semibold">âš ï¸ Error generating image</p>
                      </div>
                    )}

                    {currentUser && currentUser.role === 'admin' && editingCoverImage === 'initialPage' && (
                      <div className="bg-indigo-50 border-2 border-indigo-300 rounded-lg p-3 mb-3">
                        <p className="text-sm font-semibold text-gray-800 mb-2">{t.editInstruction}</p>
                        <textarea
                          value={coverEditInstruction}
                          onChange={(e) => setCoverEditInstruction(e.target.value)}
                          placeholder={coverImagePrompts.initialPage || "Enter prompt..."}
                          className="w-full px-3 py-2 border border-indigo-300 rounded-lg text-sm mb-2 h-24"
                        />
                        <button
                          onClick={() => applyCoverImageEdit('initialPage')}
                          className="w-full bg-indigo-600 text-white px-4 py-2 rounded-lg hover:bg-indigo-700 text-sm font-semibold"
                        >
                          {t.applyEdit}
                        </button>
                      </div>
                    )}

                    {developerMode && coverSceneDescriptions.initialPage && (
                      <details className="bg-green-50 border border-green-300 rounded-lg p-3 mb-2">
                        <summary className="cursor-pointer text-sm font-semibold text-green-800 hover:text-green-900">
                          {language === 'de' ? 'Szenenbeschreibung' : language === 'fr' ? 'Description de scÃ¨ne' : 'Scene Description'}
                        </summary>
                        <pre className="mt-2 text-xs text-gray-700 whitespace-pre-wrap font-mono bg-white p-3 rounded border border-gray-200 overflow-x-auto">
                          {coverSceneDescriptions.initialPage}
                        </pre>
                      </details>
                    )}

                    {developerMode && coverImagePrompts.initialPage && (
                      <details className="bg-gray-50 border border-gray-300 rounded-lg p-3 mb-2">
                        <summary className="cursor-pointer text-sm font-semibold text-gray-800 hover:text-gray-900">
                          {t.showPrompt}
                        </summary>
                        <pre className="mt-2 text-xs text-gray-500 whitespace-pre-wrap font-mono bg-white p-3 rounded border border-gray-200 overflow-x-auto">
                          {coverImagePrompts.initialPage}
                        </pre>
                      </details>
                    )}

                    {developerMode && coverImages.initialPage?.qualityScore !== null && coverImages.initialPage?.qualityScore !== undefined && (
                      <details className="bg-indigo-50 border border-indigo-300 rounded-lg p-3 mb-2">
                        <summary className="cursor-pointer text-sm font-semibold text-indigo-700 hover:text-indigo-900 flex items-center justify-between">
                          <span>
                            {language === 'de' ? 'QualitÃ¤tsbewertung' : language === 'fr' ? 'Score de qualitÃ©' : 'Quality Score'}
                          </span>
                          <span className={`text-lg font-bold ${
                            coverImages.initialPage.qualityScore >= 80 ? 'text-green-600' :
                            coverImages.initialPage.qualityScore >= 60 ? 'text-yellow-600' :
                            'text-red-600'
                          }`}>
                            {(coverImages.initialPage.qualityScore / 10).toFixed(1)}/10
                          </span>
                        </summary>
                        {coverImages.initialPage.qualityReasoning && (
                          <div className="mt-2 text-xs text-gray-800 bg-white p-3 rounded border border-gray-200">
                            <div className="font-semibold mb-1">{language === 'de' ? 'Feedback:' : language === 'fr' ? 'Retour:' : 'Feedback:'}</div>
                            <p className="whitespace-pre-wrap">{coverImages.initialPage.qualityReasoning}</p>
                          </div>
                        )}
                      </details>
                    )}

                    {developerMode && coverImageApiCalls.initialPage && (
                      <details className="bg-indigo-50 border border-indigo-300 rounded-lg p-3">
                        <summary className="cursor-pointer text-sm font-semibold text-indigo-700 hover:text-indigo-900">
                          {language === 'de' ? 'API-Aufruf anzeigen' : language === 'fr' ? 'Afficher l\'appel API' : 'Show API Call'}
                        </summary>
                        <div className="mt-2 text-xs text-gray-800">
                          <div className="mb-2"><span className="font-semibold">Model:</span> {coverImageApiCalls.initialPage.model}</div>
                          <div className="mb-2"><span className="font-semibold">Type:</span> {coverImageApiCalls.initialPage.type}</div>
                          <pre className="text-xs text-gray-500 whitespace-pre-wrap font-mono bg-white p-3 rounded border border-gray-200 overflow-x-auto max-h-96">
                            {JSON.stringify(coverImageApiCalls.initialPage, null, 2)}
                          </pre>
                        </div>
                      </details>
                    )}
                  </div>
                )}
              </div>

              {/* Second row: Back Cover */}
              <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mt-6">
                {/* Back Cover */}
                {(coverImages.backCover || coverImagePrompts.backCover) && (
                  <div className="bg-white border-2 border-indigo-300 rounded-lg p-4 shadow-lg">
                    <h4 className="text-lg font-bold text-gray-800 mb-3">Back Cover</h4>
                    {coverImages.backCover ? (
                      <>
                        <img
                          src={getCoverImageData(coverImages.backCover)}
                          alt="Back Cover"
                          className="w-full rounded-lg shadow-md mb-3"
                        />
                        {currentUser && currentUser.role === 'admin' && developerMode && (
                          <>
                            <div className="flex gap-2 mb-3">
                              <button
                                onClick={() => regenerateCoverImage('backCover')}
                                className="flex-1 bg-indigo-500 text-white px-3 py-2 rounded-lg hover:bg-indigo-600 flex items-center justify-center gap-1 text-sm font-semibold"
                              >
                                <Icon name="refresh-cw" size={14} /> {t.regenerateImage}
                              </button>
                              <button
                                onClick={() => toggleCoverImageEdit('backCover')}
                                className="flex-1 bg-indigo-500 text-white px-3 py-2 rounded-lg hover:bg-indigo-600 flex items-center justify-center gap-1 text-sm"
                              >
                                <Icon name="edit" size={14} /> {t.editImage}
                              </button>
                            </div>
                          </>
                        )}
                      </>
                    ) : (
                      <div className="bg-red-50 border-2 border-red-200 rounded-lg p-4 text-red-700 mb-3">
                        <p className="font-semibold">âš ï¸ Error generating image</p>
                      </div>
                    )}

                    {editingCoverImage === 'backCover' && (
                      <div className="bg-indigo-50 border-2 border-indigo-300 rounded-lg p-3 mb-3">
                        <p className="text-sm font-semibold text-gray-800 mb-2">{t.editInstruction}</p>
                        <textarea
                          value={coverEditInstruction}
                          onChange={(e) => setCoverEditInstruction(e.target.value)}
                          placeholder={coverImagePrompts.backCover || "Enter prompt..."}
                          className="w-full px-3 py-2 border border-indigo-300 rounded-lg text-sm mb-2 h-24"
                        />
                        <button
                          onClick={() => applyCoverImageEdit('backCover')}
                          className="w-full bg-indigo-600 text-white px-4 py-2 rounded-lg hover:bg-indigo-700 text-sm font-semibold"
                        >
                          {t.applyEdit}
                        </button>
                      </div>
                    )}

                    {developerMode && coverSceneDescriptions.backCover && (
                      <details className="bg-green-50 border border-green-300 rounded-lg p-3 mb-2">
                        <summary className="cursor-pointer text-sm font-semibold text-green-800 hover:text-green-900">
                          {language === 'de' ? 'Szenenbeschreibung' : language === 'fr' ? 'Description de scÃ¨ne' : 'Scene Description'}
                        </summary>
                        <pre className="mt-2 text-xs text-gray-700 whitespace-pre-wrap font-mono bg-white p-3 rounded border border-gray-200 overflow-x-auto">
                          {coverSceneDescriptions.backCover}
                        </pre>
                      </details>
                    )}

                    {developerMode && coverImagePrompts.backCover && (
                      <details className="bg-gray-50 border border-gray-300 rounded-lg p-3 mb-2">
                        <summary className="cursor-pointer text-sm font-semibold text-gray-800 hover:text-gray-900">
                          {t.showPrompt}
                        </summary>
                        <pre className="mt-2 text-xs text-gray-500 whitespace-pre-wrap font-mono bg-white p-3 rounded border border-gray-200 overflow-x-auto">
                          {coverImagePrompts.backCover}
                        </pre>
                      </details>
                    )}

                    {developerMode && coverImages.backCover?.qualityScore !== null && coverImages.backCover?.qualityScore !== undefined && (
                      <details className="bg-indigo-50 border border-indigo-300 rounded-lg p-3 mb-2">
                        <summary className="cursor-pointer text-sm font-semibold text-indigo-700 hover:text-indigo-900 flex items-center justify-between">
                          <span>
                            {language === 'de' ? 'QualitÃ¤tsbewertung' : language === 'fr' ? 'Score de qualitÃ©' : 'Quality Score'}
                          </span>
                          <span className={`text-lg font-bold ${
                            coverImages.backCover.qualityScore >= 80 ? 'text-green-600' :
                            coverImages.backCover.qualityScore >= 60 ? 'text-yellow-600' :
                            'text-red-600'
                          }`}>
                            {(coverImages.backCover.qualityScore / 10).toFixed(1)}/10
                          </span>
                        </summary>
                        {coverImages.backCover.qualityReasoning && (
                          <div className="mt-2 text-xs text-gray-800 bg-white p-3 rounded border border-gray-200">
                            <div className="font-semibold mb-1">{language === 'de' ? 'Feedback:' : language === 'fr' ? 'Retour:' : 'Feedback:'}</div>
                            <p className="whitespace-pre-wrap">{coverImages.backCover.qualityReasoning}</p>
                          </div>
                        )}
                      </details>
                    )}

                    {developerMode && coverImageApiCalls.backCover && (
                      <details className="bg-indigo-50 border border-indigo-300 rounded-lg p-3">
                        <summary className="cursor-pointer text-sm font-semibold text-indigo-700 hover:text-indigo-900">
                          {language === 'de' ? 'API-Aufruf anzeigen' : language === 'fr' ? 'Afficher l\'appel API' : 'Show API Call'}
                        </summary>
                        <div className="mt-2 text-xs text-gray-800">
                          <div className="mb-2"><span className="font-semibold">Model:</span> {coverImageApiCalls.backCover.model}</div>
                          <div className="mb-2"><span className="font-semibold">Type:</span> {coverImageApiCalls.backCover.type}</div>
                          <pre className="text-xs text-gray-500 whitespace-pre-wrap font-mono bg-white p-3 rounded border border-gray-200 overflow-x-auto max-h-96">
                            {JSON.stringify(coverImageApiCalls.backCover, null, 2)}
                          </pre>
                        </div>
                      </details>
                    )}
                  </div>
                )}
              </div>
            </div>
          )}

          {/* Display Generated Images - Developer Mode Only */}
          {developerMode && sceneImages.length > 0 && (
            <div className="bg-indigo-50 border-2 border-indigo-200 rounded-xl p-6 mt-6">
              <h3 className="text-xl font-bold text-indigo-700 mb-4 flex items-center gap-2">
                <Icon name="sparkles" size={24} /> {t.imagesReady}
              </h3>
              <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                {sceneImages.map((image, index) => (
                  <div key={index} className="bg-white border-2 border-indigo-300 rounded-lg p-4 shadow-lg">
                    <div className="flex justify-between items-center mb-3">
                      <h4 className="text-lg font-bold text-indigo-700">
                        {t.imageForPage} {image.pageNumber}
                      </h4>
                      {image.imageData && (
                        <button
                          onClick={() => downloadImage(image.imageData, image.pageNumber)}
                          className="bg-indigo-500 text-white px-3 py-1 rounded-lg hover:bg-indigo-600 flex items-center gap-1 text-sm"
                        >
                          <Icon name="download" size={16} /> {t.downloadImage}
                        </button>
                      )}
                    </div>
                    {image.imageData ? (
                      <>
                        <img
                          src={image.imageData}
                          alt={`Scene for page ${image.pageNumber}`}
                          className="w-full rounded-lg shadow-md mb-3"
                        />


                        {/* Image Action Buttons */}
                        <div className="flex gap-2 mb-3">
                          <button
                            onClick={() => {
                              const scene = sceneDescriptions.find(s => s.pageNumber === image.pageNumber);
                              if (scene) {
                                const confirmed = confirm(`Regenerate image for page ${image.pageNumber}?`);
                                if (confirmed) {
                                  // Regenerate this specific image with character avatars
                                  (async () => {
                                    try {
                                      const imagePrompt = imagePrompts[image.pageNumber];
                                      if (imagePrompt) {
                                        // Find characters in this scene (same logic as generateSceneImages)
                                        const charactersInScene = characters.filter(char =>
                                          scene.description.toLowerCase().includes(char.name.toLowerCase())
                                        );

                                        // Collect avatar images for characters in this scene
                                        // Use same priority as server: bodyNoBgUrl > bodyPhotoUrl > photoUrl
                                        const characterAvatars = charactersInScene
                                          .map(char => char.bodyNoBgUrl || char.bodyPhotoUrl || char.photoUrl)
                                          .filter(url => url);

                                        const safePrompt = `CHILDREN'S BOOK ILLUSTRATION - Safe, family-friendly content.

${imagePrompt}

IMPORTANT: This is a wholesome children's storybook illustration. All content is innocent and age-appropriate.`;

                                        let newImageData;
                                        if (characterAvatars.length > 0) {
                                          // Send with avatar images for better consistency
                                          console.log(`Regenerating page ${image.pageNumber} with ${characterAvatars.length} avatar(s)...`);
                                          newImageData = await callGeminiAPIWithImages(safePrompt, characterAvatars, image.pageNumber);
                                        } else {
                                          // Text-only if no avatars available
                                          console.log(`Regenerating page ${image.pageNumber} with text-only prompt...`);
                                          newImageData = await callGeminiAPIWithLogging(safePrompt, null, image.pageNumber);
                                        }

                                        // Analyze quality for admin
                                        let qualityAnalysis = null;
                                        if (currentUser && currentUser.role === 'admin' && newImageData) {
                                          qualityAnalysis = await analyzeImageQuality(newImageData, imagePrompt, characterAvatars);
                                        }

                                        const updatedImages = [...sceneImages];
                                        updatedImages[index] = {
                                          ...image,
                                          imageData: newImageData,
                                          qualityScore: qualityAnalysis?.score || null,
                                          qualityReasoning: qualityAnalysis?.reasoning || null
                                        };
                                        setSceneImages(updatedImages);
                                      }
                                    } catch (error) {
                                      alert(`Error regenerating image: ${error.message}`);
                                    }
                                  })();
                                }
                              }
                            }}
                            className="flex-1 bg-indigo-500 text-white px-3 py-2 rounded-lg hover:bg-indigo-600 flex items-center justify-center gap-1 text-sm"
                          >
                            <Icon name="refresh-cw" size={14} /> {t.regenerateImage}
                          </button>
                          <button
                            onClick={() => {
                              if (editingImageIndex === index) {
                                setEditingImageIndex(null);
                                setImageEditInstruction('');
                              } else {
                                setEditingImageIndex(index);
                                setImageEditInstruction('');
                              }
                            }}
                            className="flex-1 bg-indigo-500 text-white px-3 py-2 rounded-lg hover:bg-indigo-600 flex items-center justify-center gap-1 text-sm"
                          >
                            <Icon name="edit" size={14} /> {t.editImage}
                          </button>
                        </div>

                        {/* Edit Image Interface */}
                        {editingImageIndex === index && (
                          <div className="bg-indigo-50 border-2 border-indigo-300 rounded-lg p-3 mb-3">
                            <p className="text-sm font-semibold text-gray-800 mb-2">{t.editInstruction}</p>
                            <input
                              type="text"
                              value={imageEditInstruction}
                              onChange={(e) => setImageEditInstruction(e.target.value)}
                              placeholder="e.g., Make the sky darker, add more trees..."
                              className="w-full px-3 py-2 border border-indigo-300 rounded-lg text-sm mb-2"
                            />
                            <button
                              onClick={async () => {
                                if (!imageEditInstruction.trim()) {
                                  alert(language === 'de' ? 'Bitte geben Sie Bearbeitungsanweisungen ein' : language === 'fr' ? 'Veuillez entrer des instructions d\'Ã©dition' : 'Please enter edit instructions');
                                  return;
                                }
                                try {
                                  const editedImage = await editImage(image.imageData, imageEditInstruction);
                                  if (editedImage) {
                                    const updatedImages = [...sceneImages];
                                    updatedImages[index] = { ...image, imageData: editedImage };
                                    setSceneImages(updatedImages);
                                    setEditingImageIndex(null);
                                    setImageEditInstruction('');
                                  }
                                } catch (error) {
                                  alert(`Error editing image: ${error.message}`);
                                }
                              }}
                              className="w-full bg-indigo-600 text-white px-4 py-2 rounded-lg hover:bg-indigo-700 text-sm font-semibold"
                            >
                              {t.applyEdit}
                            </button>
                          </div>
                        )}

                        {/* Scene Description */}
                        {sceneDescriptions.find(s => s.pageNumber === image.pageNumber)?.description && (
                          <details className="bg-green-50 border border-green-300 rounded-lg p-3 mb-2">
                            <summary className="cursor-pointer text-sm font-semibold text-green-800 hover:text-green-900">
                              {language === 'de' ? 'Szenenbeschreibung' : language === 'fr' ? 'Description de scÃ¨ne' : 'Scene Description'}
                            </summary>
                            <pre className="mt-2 text-xs text-gray-700 whitespace-pre-wrap font-mono bg-white p-3 rounded border border-gray-200 overflow-x-auto">
                              {sceneDescriptions.find(s => s.pageNumber === image.pageNumber)?.description}
                            </pre>
                          </details>
                        )}

                        {/* Show Prompt */}
                        {imagePrompts[image.pageNumber] && (
                          <details className="bg-gray-50 border border-gray-300 rounded-lg p-3 mb-2">
                            <summary className="cursor-pointer text-sm font-semibold text-gray-800 hover:text-gray-900">
                              {t.showPrompt}
                            </summary>
                            <pre className="mt-2 text-xs text-gray-500 whitespace-pre-wrap font-mono bg-white p-3 rounded border border-gray-200 overflow-x-auto">
                              {imagePrompts[image.pageNumber]}
                            </pre>
                          </details>
                        )}

                        {/* Show API Call - Admin only */}
                        {currentUser && currentUser.role === 'admin' && apiCalls[image.pageNumber] && (
                          <details className="bg-indigo-50 border border-indigo-300 rounded-lg p-3 mb-2">
                            <summary className="cursor-pointer text-sm font-semibold text-indigo-700 hover:text-indigo-900">
                              {language === 'de' ? 'API-Aufruf anzeigen' : language === 'fr' ? 'Afficher l\'appel API' : 'Show API Call'}
                            </summary>
                            <div className="mt-2 text-xs text-gray-800">
                              <div className="mb-2">
                                <span className="font-semibold">Endpoint:</span> {apiCalls[image.pageNumber].endpoint}
                              </div>
                              <div className="mb-2">
                                <span className="font-semibold">Method:</span> {apiCalls[image.pageNumber].method}
                              </div>
                              <div className="mb-2">
                                <span className="font-semibold">Timestamp:</span> {new Date(apiCalls[image.pageNumber].timestamp).toLocaleString()}
                              </div>
                              <div className="mb-1 font-semibold">Payload:</div>
                              <pre className="text-xs text-gray-500 whitespace-pre-wrap font-mono bg-white p-3 rounded border border-gray-200 overflow-x-auto max-h-96">
                                {JSON.stringify(apiCalls[image.pageNumber].payload, null, 2)}
                              </pre>
                            </div>
                          </details>
                        )}

                        {/* Quality Score with Collapsible Explanation */}
                        {currentUser && currentUser.role === 'admin' && image.qualityScore !== null && image.qualityScore !== undefined && (
                          <details className="bg-indigo-50 border border-indigo-300 rounded-lg p-3 mb-2">
                            <summary className="cursor-pointer text-sm font-semibold text-indigo-700 hover:text-indigo-900 flex items-center justify-between">
                              <span>
                                {language === 'de' ? 'QualitÃ¤tsbewertung' : language === 'fr' ? 'Score de qualitÃ©' : 'Quality Score'}
                              </span>
                              <span className={`text-lg font-bold ${
                                image.qualityScore >= 80 ? 'text-green-600' :
                                image.qualityScore >= 60 ? 'text-yellow-600' :
                                'text-red-600'
                              }`}>
                                {(image.qualityScore / 10).toFixed(1)}/10
                              </span>
                            </summary>
                            {image.qualityReasoning && (
                              <div className="mt-2 text-xs text-gray-800 bg-white p-3 rounded border border-gray-200">
                                <div className="font-semibold mb-1">{language === 'de' ? 'Feedback:' : language === 'fr' ? 'Retour:' : 'Feedback:'}</div>
                                <p className="whitespace-pre-wrap">{image.qualityReasoning}</p>
                              </div>
                            )}
                          </details>
                        )}

                        {/* Regeneration Info - Dev Mode Only */}
                        {currentUser && currentUser.role === 'admin' && image.wasRegenerated && (
                          <details className="bg-orange-50 border border-orange-300 rounded-lg p-3 mb-2">
                            <summary className="cursor-pointer text-sm font-semibold text-orange-700 hover:text-orange-900 flex items-center justify-between">
                              <span>ðŸ”„ {language === 'de' ? 'Bild regeneriert' : language === 'fr' ? 'Image rÃ©gÃ©nÃ©rÃ©e' : 'Image Regenerated'}</span>
                              {image.originalScore !== null && image.originalScore !== undefined && (
                                <span className="text-sm">
                                  Original: <span className="text-red-600 font-bold">{(image.originalScore / 10).toFixed(1)}/10</span>
                                </span>
                              )}
                            </summary>
                            <div className="mt-3">
                              <p className="text-xs text-gray-600 mb-2">
                                {language === 'de'
                                  ? 'Das Bild wurde automatisch regeneriert, da die erste Version eine niedrige QualitÃ¤t hatte.'
                                  : language === 'fr'
                                  ? "L'image a Ã©tÃ© automatiquement rÃ©gÃ©nÃ©rÃ©e car la premiÃ¨re version avait une qualitÃ© faible."
                                  : 'Image was automatically regenerated because the first version had low quality.'}
                              </p>
                              {image.originalImage && (
                                <div className="mt-2">
                                  <p className="text-xs font-semibold text-gray-700 mb-1">
                                    {language === 'de' ? 'Originalbild:' : language === 'fr' ? 'Image originale:' : 'Original Image:'}
                                  </p>
                                  <img
                                    src={image.originalImage}
                                    alt="Original (lower quality)"
                                    className="w-full rounded border-2 border-orange-200 opacity-75"
                                  />
                                  {image.originalReasoning && (
                                    <div className="mt-2 text-xs text-gray-600 bg-white p-2 rounded border">
                                      <div className="font-semibold mb-1">{language === 'de' ? 'Original Feedback:' : language === 'fr' ? 'Retour original:' : 'Original Feedback:'}</div>
                                      <p className="whitespace-pre-wrap">{image.originalReasoning}</p>
                                    </div>
                                  )}
                                </div>
                              )}
                            </div>
                          </details>
                        )}
                      </>
                    ) : (
                      <>
                        {/* Error Display for Blocked/Failed Images */}
                        <div className="bg-red-50 border-2 border-red-200 rounded-lg p-4 text-red-700 mb-3">
                          <p className="font-semibold">âš ï¸ Error generating image:</p>
                          <p className="text-sm mt-1">{image.error || 'Unknown error'}</p>
                        </div>

                        {/* Action Buttons - Even for Failed Images */}
                        <div className="flex gap-2 mb-3">
                          <button
                            onClick={() => {
                              const scene = sceneDescriptions.find(s => s.pageNumber === image.pageNumber);
                              if (scene) {
                                const confirmed = confirm(`Retry generating image for page ${image.pageNumber}?`);
                                if (confirmed) {
                                  (async () => {
                                    try {
                                      const imagePrompt = imagePrompts[image.pageNumber];
                                      if (imagePrompt) {
                                        const newImageData = await callGeminiAPI(imagePrompt);
                                        const updatedImages = [...sceneImages];
                                        updatedImages[index] = { ...image, imageData: newImageData, error: null };
                                        setSceneImages(updatedImages);
                                      }
                                    } catch (error) {
                                      alert(`Error regenerating image: ${error.message}`);
                                      const updatedImages = [...sceneImages];
                                      updatedImages[index] = { ...image, error: error.message };
                                      setSceneImages(updatedImages);
                                    }
                                  })();
                                }
                              }
                            }}
                            className="flex-1 bg-indigo-500 text-white px-3 py-2 rounded-lg hover:bg-indigo-600 flex items-center justify-center gap-1 text-sm font-semibold"
                          >
                            <Icon name="refresh-cw" size={14} /> {language === 'de' ? 'Erneut versuchen' : language === 'fr' ? 'RÃ©essayer' : 'Retry'}
                          </button>
                          <button
                            onClick={() => {
                              if (editingImageIndex === index) {
                                setEditingImageIndex(null);
                                setImageEditInstruction('');
                              } else {
                                setEditingImageIndex(index);
                                setImageEditInstruction('');
                              }
                            }}
                            className="flex-1 bg-indigo-500 text-white px-3 py-2 rounded-lg hover:bg-indigo-600 flex items-center justify-center gap-1 text-sm"
                          >
                            <Icon name="edit" size={14} /> {language === 'de' ? 'Prompt bearbeiten' : language === 'fr' ? 'Modifier le prompt' : 'Edit Prompt'}
                          </button>
                        </div>

                        {/* Edit Prompt Interface for Failed Images */}
                        {editingImageIndex === index && (
                          <div className="bg-indigo-50 border-2 border-indigo-300 rounded-lg p-3 mb-3">
                            <p className="text-sm font-semibold text-gray-800 mb-2">
                              {language === 'de' ? 'Prompt bearbeiten und erneut versuchen:' : language === 'fr' ? 'Modifier le prompt et rÃ©essayer:' : 'Edit prompt and retry:'}
                            </p>
                            <textarea
                              value={imageEditInstruction}
                              onChange={(e) => setImageEditInstruction(e.target.value)}
                              placeholder={imagePrompts[image.pageNumber] || "Enter new prompt..."}
                              className="w-full px-3 py-2 border border-indigo-300 rounded-lg text-sm mb-2 h-24"
                            />
                            <button
                              onClick={async () => {
                                if (!imageEditInstruction.trim()) {
                                  alert(language === 'de' ? 'Bitte geben Sie einen Prompt ein' : language === 'fr' ? 'Veuillez entrer un prompt' : 'Please enter a prompt');
                                  return;
                                }
                                try {
                                  const newImageData = await callGeminiAPI(imageEditInstruction);
                                  const updatedImages = [...sceneImages];
                                  updatedImages[index] = { ...image, imageData: newImageData, error: null };
                                  setSceneImages(updatedImages);
                                  // Update the prompt
                                  setImagePrompts({...imagePrompts, [image.pageNumber]: imageEditInstruction});
                                  setEditingImageIndex(null);
                                  setImageEditInstruction('');
                                } catch (error) {
                                  alert(`Error generating image: ${error.message}`);
                                  const updatedImages = [...sceneImages];
                                  updatedImages[index] = { ...image, error: error.message };
                                  setSceneImages(updatedImages);
                                }
                              }}
                              className="w-full bg-indigo-600 text-white px-4 py-2 rounded-lg hover:bg-indigo-700 text-sm font-semibold"
                            >
                              {language === 'de' ? 'Mit neuem Prompt generieren' : language === 'fr' ? 'GÃ©nÃ©rer avec nouveau prompt' : 'Generate with new prompt'}
                            </button>
                          </div>
                        )}

                        {/* Show Prompt - Even for Failed Images */}
                        {imagePrompts[image.pageNumber] && (
                          <details className="bg-gray-50 border border-gray-300 rounded-lg p-3 mb-2">
                            <summary className="cursor-pointer text-sm font-semibold text-gray-800 hover:text-gray-900">
                              {language === 'de' ? 'Verwendeten Prompt anzeigen' : language === 'fr' ? 'Afficher le prompt utilisÃ©' : 'Show Used Prompt'}
                            </summary>
                            <pre className="mt-2 text-xs text-gray-500 whitespace-pre-wrap font-mono bg-white p-3 rounded border border-gray-200 overflow-x-auto">
                              {imagePrompts[image.pageNumber]}
                            </pre>
                          </details>
                        )}

                        {/* Show API Call - Admin only - Even for Failed Images */}
                        {currentUser && currentUser.role === 'admin' && apiCalls[image.pageNumber] && (
                          <details className="bg-indigo-50 border border-indigo-300 rounded-lg p-3">
                            <summary className="cursor-pointer text-sm font-semibold text-indigo-700 hover:text-indigo-900">
                              {language === 'de' ? 'API-Aufruf anzeigen' : language === 'fr' ? 'Afficher l\'appel API' : 'Show API Call'}
                            </summary>
                            <div className="mt-2 text-xs text-gray-800">
                              <div className="mb-2">
                                <span className="font-semibold">Endpoint:</span> {apiCalls[image.pageNumber].endpoint || 'N/A'}
                              </div>
                              <div className="mb-2">
                                <span className="font-semibold">Method:</span> {apiCalls[image.pageNumber].method || 'N/A'}
                              </div>
                              <div className="mb-2">
                                <span className="font-semibold">Timestamp:</span> {apiCalls[image.pageNumber].timestamp ? new Date(apiCalls[image.pageNumber].timestamp).toLocaleString() : 'N/A'}
                              </div>
                              <div className="mb-1 font-semibold">Payload:</div>
                              <pre className="text-xs text-gray-500 whitespace-pre-wrap font-mono bg-white p-3 rounded border border-gray-200 overflow-x-auto max-h-96">
                                {JSON.stringify(apiCalls[image.pageNumber].payload || {}, null, 2)}
                              </pre>
                            </div>
                          </details>
                        )}
                      </>
                    )}
                  </div>
                ))}
              </div>
            </div>
          )}

          {/* Final Story: Side-by-Side Pages with Images (MOVED TO END) */}
          {sceneImages.length > 0 && generatedStory && (
            <div className="space-y-8 mt-8">
              <h3 className="text-2xl font-bold text-gray-800 text-center mb-6">
                {storyTitle || (language === 'de' ? 'Ihre Geschichte' : language === 'fr' ? 'Votre histoire' : 'Your Story')}
              </h3>

              {(() => {
                // Split story into pages - handle both markdown (## Seite/Page 1) and old format (--- Page 1 ---)
                console.log('ðŸ“– [STORY DISPLAY] generatedStory length:', generatedStory?.length);
                console.log('ðŸ“– [STORY DISPLAY] generatedStory first 500 chars:', generatedStory?.substring(0, 500));
                const pageMatches = generatedStory.split(/(?:---\s*(?:Page|Seite)\s+\d+\s*---|##\s*(?:Page|Seite)\s+\d+)/i);
                console.log('ðŸ“– [STORY DISPLAY] pageMatches count:', pageMatches.length);
                console.log('ðŸ“– [STORY DISPLAY] pageMatches[0] (should be empty or intro):', pageMatches[0]?.substring(0, 200));
                console.log('ðŸ“– [STORY DISPLAY] pageMatches[1] (first page):', pageMatches[1]?.substring(0, 200));
                const storyPages = pageMatches.slice(1);
                console.log('ðŸ“– [STORY DISPLAY] storyPages count:', storyPages.length);

                // Check if this is a Picture Book (1st-grade level) - use vertical layout
                const isPictureBook = languageLevel === '1st-grade';

                return storyPages.map((pageText, index) => {
                const pageNumber = index + 1;
                const image = sceneImages.find(img => img.pageNumber === pageNumber);

                return (
                  <div key={pageNumber} className="p-4 md:p-6">
                    <h4 className="text-xl font-bold text-gray-800 mb-4 text-center">
                      {language === 'de' ? `Seite ${pageNumber}` : language === 'fr' ? `Page ${pageNumber}` : `Page ${pageNumber}`}
                    </h4>

                    {/* Picture Book Layout: Image on top, text below */}
                    {isPictureBook ? (
                      <div className="flex flex-col items-center max-w-2xl mx-auto">
                        {/* Image on top */}
                        {image && image.imageData ? (
                          <div className="w-full mb-4">
                            <div className="relative">
                              <img
                                src={image.imageData}
                                alt={`Scene for page ${pageNumber}`}
                                className="w-full rounded-lg shadow-md object-cover"
                              />
                              {(developerMode || (currentUser && currentUser.role === 'admin')) && image.score !== null && image.score !== undefined && (
                                <div className="absolute top-2 right-2 bg-indigo-600 text-white px-3 py-1 rounded-full shadow-lg flex items-center gap-1 text-sm font-bold">
                                  <span>â­</span>
                                  <span>{typeof image.score === 'number' ? image.score.toFixed(1) : image.score}/10</span>
                                </div>
                              )}
                            </div>
                            {developerMode && (
                              <button
                                onClick={() => downloadImage(image.imageData, pageNumber)}
                                className="mt-3 bg-indigo-500 text-white px-4 py-2 rounded-lg hover:bg-indigo-600 flex items-center justify-center gap-2 text-sm w-full"
                              >
                                <Icon name="download" size={16} /> Download Image
                              </button>
                            )}
                          </div>
                        ) : (
                          <div className="w-full flex items-center justify-center bg-gray-100 rounded-lg p-8 mb-4">
                            <p className="text-gray-500 text-center">
                              {language === 'de' ? 'Kein Bild fÃ¼r diese Seite' : language === 'fr' ? 'Pas d\'image pour cette page' : 'No image for this page'}
                            </p>
                          </div>
                        )}

                        {/* Text below */}
                        <div className="w-full bg-indigo-50 rounded-lg p-6 border-2 border-indigo-200">
                          <p className="text-gray-800 leading-relaxed whitespace-pre-wrap font-serif text-xl text-center">
                            {pageText.trim()}
                          </p>
                        </div>
                      </div>
                    ) : (
                      /* Standard Layout: Image on left, text on right (side-by-side) */
                      <div className="grid md:grid-cols-2 gap-6">
                        {/* Image on the left */}
                        {image && image.imageData ? (
                          <div className="flex flex-col">
                            <div className="relative">
                              <img
                                src={image.imageData}
                                alt={`Scene for page ${pageNumber}`}
                                className="w-full rounded-lg shadow-md object-cover"
                              />
                              {(developerMode || (currentUser && currentUser.role === 'admin')) && image.score !== null && image.score !== undefined && (
                                <div className="absolute top-2 right-2 bg-indigo-600 text-white px-3 py-1 rounded-full shadow-lg flex items-center gap-1 text-sm font-bold">
                                  <span>â­</span>
                                  <span>{typeof image.score === 'number' ? image.score.toFixed(1) : image.score}/10</span>
                                </div>
                              )}
                            </div>
                            {developerMode && (
                              <button
                                onClick={() => downloadImage(image.imageData, pageNumber)}
                                className="mt-3 bg-indigo-500 text-white px-4 py-2 rounded-lg hover:bg-indigo-600 flex items-center justify-center gap-2 text-sm"
                              >
                                <Icon name="download" size={16} /> Download Image
                              </button>
                            )}
                          </div>
                        ) : (
                          <div className="flex items-center justify-center bg-gray-100 rounded-lg p-8">
                            <p className="text-gray-500 text-center">
                              {language === 'de' ? 'Kein Bild fÃ¼r diese Seite' : language === 'fr' ? 'Pas d\'image pour cette page' : 'No image for this page'}
                            </p>
                          </div>
                        )}

                        {/* Text on the right */}
                        <div className="flex items-center">
                          <div className="prose max-w-none">
                            <p className="text-gray-800 leading-relaxed whitespace-pre-wrap font-serif text-xl">
                              {pageText.trim()}
                            </p>
                          </div>
                        </div>
                      </div>
                    )}
                  </div>
                );
              });
              })()}
            </div>
          )}

          {/* Bottom Action Buttons - for normal users who scrolled to the end */}
          {sceneImages.length > 0 && generatedStory && (
            <div className="bg-gradient-to-r from-indigo-50 to-purple-50 border-2 border-indigo-200 rounded-xl p-6 mt-6">
              <h3 className="text-lg font-bold text-gray-800 mb-4 text-center">
                {language === 'de' ? 'Was mÃ¶chten Sie als NÃ¤chstes tun?' : language === 'fr' ? 'Que souhaitez-vous faire ensuite ?' : 'What would you like to do next?'}
              </h3>
              <div className="grid grid-cols-1 sm:grid-cols-3 gap-3">
                {/* Download PDF */}
                <button
                  onClick={downloadPrintablePDF}
                  disabled={isGenerating}
                  className={`bg-green-500 text-white px-6 py-3 rounded-lg font-semibold flex items-center justify-center gap-2 ${isGenerating ? 'opacity-50 cursor-not-allowed' : 'hover:bg-green-600'}`}
                >
                  <Icon name="file-text" size={20} /> {language === 'de' ? 'PDF herunterladen' : language === 'fr' ? 'TÃ©lÃ©charger PDF' : 'Download PDF'}
                </button>
                {/* Buy Book */}
                {currentStoryId && (
                  <button
                    disabled={isGenerating}
                    onClick={async () => {
                      try {
                        const response = await fetch(`${API_URL}/api/stripe/create-checkout-session`, {
                          method: 'POST',
                          headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${authToken}`
                          },
                          body: JSON.stringify({ storyId: currentStoryId })
                        });
                        const data = await response.json();
                        if (!response.ok) {
                          alert('Failed to create checkout session: ' + data.error);
                          return;
                        }
                        window.location.href = data.url;
                      } catch (err) {
                        alert('Error creating checkout: ' + err.message);
                      }
                    }}
                    className={`bg-indigo-500 text-white px-6 py-3 rounded-lg font-semibold flex items-center justify-center gap-2 ${isGenerating ? 'opacity-50 cursor-not-allowed' : 'hover:bg-orange-600'}`}
                  >
                    <Icon name="shopping-cart" size={20} /> {language === 'de' ? 'Buch kaufen (CHF 36)' : language === 'fr' ? 'Acheter le livre (CHF 36)' : 'Buy Book (CHF 36)'}
                  </button>
                )}
                {/* Create Another Story */}
                <button
                  onClick={resetAllStoryState}
                  disabled={isGenerating}
                  className={`bg-indigo-500 text-white px-6 py-3 rounded-lg font-semibold flex items-center justify-center gap-2 ${isGenerating ? 'opacity-50 cursor-not-allowed' : 'hover:bg-indigo-600'}`}
                >
                  <Icon name="plus" size={20} /> {t.createAnotherStory}
                </button>
              </div>
            </div>
          )}
        </div>
        );
      };

      return (
        <div className="min-h-screen bg-gray-50">
          {/* Admin Impersonation Banner */}
          {impersonateUserId && (
            <div className="fixed top-0 left-0 right-0 bg-red-600 text-white py-2 px-4 z-50 flex items-center justify-between">
              <div className="flex items-center gap-2">
                <span className="font-bold">ADMIN MODE:</span>
                <span>{language === 'de' ? 'Bearbeite Geschichte fÃ¼r Benutzer' : language === 'fr' ? 'Modification de l\'histoire pour l\'utilisateur' : 'Editing story for user'} {impersonateUsername || impersonateUserId}</span>
              </div>
              <button
                onClick={() => {
                  window.close();
                }}
                className="bg-white text-red-600 px-3 py-1 rounded font-semibold hover:bg-red-100"
              >
                {language === 'de' ? 'Tab schliessen' : language === 'fr' ? 'Fermer l\'onglet' : 'Close Tab'}
              </button>
            </div>
          )}
          {/* Authentication Modal */}
          {showAuthModal && (
            <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4">
              <div className="bg-white rounded-xl shadow-xl max-w-md w-full p-8 animate-fade-in">
                {/* Password Reset Sent Confirmation */}
                {authMode === 'resetSent' ? (
                  <div className="text-center">
                    <div className="text-5xl mb-4">ðŸ“§</div>
                    <h2 className="text-2xl font-bold text-gray-800 mb-2">{t.resetLinkSent}</h2>
                    <button
                      onClick={() => { setAuthMode('login'); setAuthError(''); }}
                      className="mt-4 text-indigo-600 font-semibold hover:text-gray-800"
                    >
                      {t.backToLogin}
                    </button>
                  </div>
                ) : authMode === 'reset' ? (
                  /* Password Reset Form */
                  <>
                    <div className="text-center mb-6">
                      <h2 className="text-2xl font-bold text-gray-800 mb-2">{t.resetPassword}</h2>
                      <p className="text-gray-500">{t.resetPasswordDesc}</p>
                    </div>

                    {authError && (
                      <div className="bg-red-50 border border-red-200 text-red-600 px-4 py-3 rounded-lg mb-4">
                        {authError}
                      </div>
                    )}

                    <form onSubmit={handlePasswordReset} className="space-y-4">
                      <div>
                        <label className="block text-sm font-medium text-gray-800 mb-1">{t.email}</label>
                        <input
                          type="email"
                          value={authForm.username}
                          onChange={(e) => setAuthForm({...authForm, username: e.target.value})}
                          className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-transparent outline-none"
                          placeholder="your@email.com"
                          required
                        />
                      </div>

                      <button
                        type="submit"
                        className="w-full bg-indigo-600 text-white py-3 rounded-lg font-semibold hover:bg-indigo-700 transition-colors"
                      >
                        {t.sendResetLink}
                      </button>
                    </form>

                    <div className="mt-4 text-center">
                      <button
                        onClick={() => { setAuthMode('login'); setAuthError(''); }}
                        className="text-indigo-600 font-semibold hover:text-gray-800"
                      >
                        {t.backToLogin}
                      </button>
                    </div>
                  </>
                ) : (
                  /* Login / Register Form */
                  <>
                    <div className="text-center mb-6">
                      <h2 className="text-2xl font-bold text-gray-800 mb-2">
                        {authMode === 'login' ? t.welcomeBack : t.createAccount}
                      </h2>
                      <p className="text-gray-500">{t.loginRequired}</p>
                    </div>

                    {authError && (
                      <div className="bg-red-50 border border-red-200 text-red-600 px-4 py-3 rounded-lg mb-4">
                        {authError}
                      </div>
                    )}

                    {/* Social Login Buttons */}
                    <div className="space-y-3 mb-4">
                      <button
                        type="button"
                        onClick={handleGoogleSignIn}
                        className="w-full flex items-center justify-center gap-3 bg-white border border-gray-300 text-gray-700 py-3 rounded-lg font-semibold hover:bg-gray-50 transition-colors"
                      >
                        <svg className="w-5 h-5" viewBox="0 0 24 24">
                          <path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/>
                          <path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/>
                          <path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/>
                          <path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/>
                        </svg>
                        {t.continueWithGoogle}
                      </button>

{/* Apple Sign-In disabled - enable in Firebase console first
                      <button
                        type="button"
                        onClick={handleAppleSignIn}
                        className="w-full flex items-center justify-center gap-3 bg-black text-white py-3 rounded-lg font-semibold hover:bg-gray-800 transition-colors"
                      >
                        <svg className="w-5 h-5" viewBox="0 0 24 24" fill="currentColor">
                          <path d="M17.05 20.28c-.98.95-2.05.8-3.08.35-1.09-.46-2.09-.48-3.24 0-1.44.62-2.2.44-3.06-.35C2.79 15.25 3.51 7.59 9.05 7.31c1.35.07 2.29.74 3.08.8 1.18-.24 2.31-.93 3.57-.84 1.51.12 2.65.72 3.4 1.8-3.12 1.87-2.38 5.98.48 7.13-.57 1.5-1.31 2.99-2.54 4.09l.01-.01zM12.03 7.25c-.15-2.23 1.66-4.07 3.74-4.25.29 2.58-2.34 4.5-3.74 4.25z"/>
                        </svg>
                        {t.continueWithApple}
                      </button>
                      */}
                    </div>

                    {/* Divider */}
                    <div className="relative my-6">
                      <div className="absolute inset-0 flex items-center">
                        <div className="w-full border-t border-gray-300"></div>
                      </div>
                      <div className="relative flex justify-center text-sm">
                        <span className="px-2 bg-white text-gray-500">{t.orContinueWith}</span>
                      </div>
                    </div>

                    <form onSubmit={authMode === 'login' ? handleLogin : handleRegister} className="space-y-4">
                      <div>
                        <label className="block text-sm font-medium text-gray-800 mb-1">{t.email}</label>
                        <input
                          type="email"
                          value={authForm.username}
                          onChange={(e) => setAuthForm({...authForm, username: e.target.value})}
                          className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-transparent outline-none"
                          placeholder="your@email.com"
                          required
                        />
                      </div>

                      <div>
                        <label className="block text-sm font-medium text-gray-800 mb-1">{t.password}</label>
                        <input
                          type="password"
                          value={authForm.password}
                          onChange={(e) => setAuthForm({...authForm, password: e.target.value})}
                          className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-transparent outline-none"
                          required
                        />
                      </div>

                      {authMode === 'login' && (
                        <div className="text-right">
                          <button
                            type="button"
                            onClick={() => { setAuthMode('reset'); setAuthError(''); }}
                            className="text-sm text-indigo-600 hover:text-indigo-800"
                          >
                            {t.forgotPassword}
                          </button>
                        </div>
                      )}

                      <button
                        type="submit"
                        className="w-full bg-indigo-600 text-white py-3 rounded-lg font-semibold hover:bg-indigo-700 transition-colors"
                      >
                        {authMode === 'login' ? t.signIn : t.signUp}
                      </button>
                    </form>

                    <div className="mt-4 text-center">
                      <p className="text-sm text-gray-500">
                        {authMode === 'login' ? t.noAccount : t.haveAccount}
                        {' '}
                        <button
                          onClick={() => {
                            setAuthMode(authMode === 'login' ? 'register' : 'login');
                            setAuthError('');
                          }}
                          className="text-indigo-600 font-semibold hover:text-gray-800"
                        >
                          {authMode === 'login' ? t.signUp : t.signIn}
                        </button>
                      </p>
                    </div>
                  </>
                )}
              </div>
            </div>
          )}

          {/* Admin Panel Modal */}
          {showAdminPanel && currentUser && currentUser.role === 'admin' && (
            <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4 overflow-y-auto">
              <div className="bg-white rounded-xl shadow-2xl max-w-6xl w-full max-h-[90vh] overflow-y-auto p-8 animate-fade-in">
                <div className="flex justify-between items-center mb-6">
                  <h2 className="text-3xl font-bold text-yellow-700 flex items-center gap-2">
                    <span className="text-4xl">{adminTab === 'orders' ? 'ðŸ“¦' : 'ðŸ‘¥'}</span>
                    {adminTab === 'orders'
                      ? (language === 'de' ? 'Fehlgeschlagene Bestellungen' : language === 'fr' ? 'Commandes Ã©chouÃ©es' : 'Failed Orders')
                      : (language === 'de' ? 'Benutzerverwaltung' : language === 'fr' ? 'Gestion des utilisateurs' : 'User Management')
                    }
                  </h2>
                  <button
                    onClick={() => setShowAdminPanel(false)}
                    className="text-gray-500 hover:text-gray-800 text-2xl font-bold"
                  >
                    âœ•
                  </button>
                </div>

                {/* Admin Panel Tabs */}
                <div className="flex gap-2 mb-6 border-b border-gray-200 pb-2">
                  <button
                    onClick={() => { setAdminTab('users'); fetchAllUsers(); }}
                    className={`px-4 py-2 rounded-t-lg font-semibold ${adminTab === 'users' ? 'bg-yellow-100 text-yellow-800 border-b-2 border-yellow-600' : 'bg-gray-100 text-gray-500 hover:bg-gray-200'}`}
                  >
                    ðŸ‘¥ {language === 'de' ? 'Benutzer' : language === 'fr' ? 'Utilisateurs' : 'Users'}
                  </button>
                  <button
                    onClick={() => { setAdminTab('orders'); fetchFailedOrders(); }}
                    className={`px-4 py-2 rounded-t-lg font-semibold ${adminTab === 'orders' ? 'bg-red-100 text-red-800 border-b-2 border-red-600' : 'bg-gray-100 text-gray-500 hover:bg-gray-200'}`}
                  >
                    ðŸ“¦ {language === 'de' ? 'Bestellungen' : language === 'fr' ? 'Commandes' : 'Orders'}
                    {failedOrders.length > 0 && (
                      <span className="ml-2 px-2 py-0.5 bg-red-600 text-white text-xs rounded-full">{failedOrders.length}</span>
                    )}
                  </button>
                </div>

                {/* Users Tab */}
                {adminTab === 'users' && (
                <>
                <div className="flex gap-3 mb-4">
                    <button
                      onClick={fetchAllUsers}
                      className="bg-indigo-600 text-white px-4 py-2 rounded-lg hover:bg-indigo-700 flex items-center gap-2"
                    >
                      <span>ðŸ”„</span>
                      Refresh Users
                    </button>
                    <button
                      onClick={() => window.open('/admin-dashboard.html', '_blank')}
                      className="bg-indigo-600 text-white px-4 py-2 rounded-lg hover:bg-indigo-700 flex items-center gap-2"
                    >
                      <span>ðŸ“Š</span>
                      View Dashboard
                    </button>
                  </div>

                {adminUsers.length === 0 ? (
                  <div className="text-center py-12">
                    <div className="text-gray-300 mb-4 text-6xl">ðŸ‘¥</div>
                    <p className="text-gray-500 text-lg">Click "Refresh Users" to load user list</p>
                  </div>
                ) : (
                  <div className="overflow-x-auto">
                    <table className="w-full border-collapse">
                      <thead>
                        <tr className="bg-gray-100">
                          <th className="px-4 py-3 text-left text-sm font-semibold text-gray-800">Email</th>
                          <th className="px-4 py-3 text-left text-sm font-semibold text-gray-800">Role</th>
                          <th className="px-4 py-3 text-center text-sm font-semibold text-gray-800">Quota</th>
                          <th className="px-4 py-3 text-center text-sm font-semibold text-gray-800">Used</th>
                          <th className="px-4 py-3 text-center text-sm font-semibold text-gray-800">Remaining</th>
                          <th className="px-4 py-3 text-center text-sm font-semibold text-gray-800">Orders</th>
                          <th className="px-4 py-3 text-center text-sm font-semibold text-gray-800">Actions</th>
                        </tr>
                      </thead>
                      <tbody>
                        {adminUsers.map(user => {
                          const remaining = user.storyQuota === -1 ? 'âˆž' : Math.max(0, user.storyQuota - user.storiesGenerated);
                          const isLow = user.storyQuota !== -1 && remaining <= 1;
                          const isEmpty = user.storyQuota !== -1 && remaining <= 0;

                          return (
                            <tr key={user.id} className="border-b hover:bg-gray-50">
                              <td className="px-4 py-3 text-sm font-medium text-gray-900">
                                {user.username}
                              </td>
                              <td className="px-4 py-3 text-sm">
                                <span className={`px-2 py-1 rounded text-xs font-semibold ${
                                  user.role === 'admin' ? 'bg-yellow-100 text-yellow-800' : 'bg-gray-100 text-gray-800'
                                }`}>
                                  {user.role} {user.role === 'admin' && 'ðŸ‘‘'}
                                </span>
                              </td>
                              <td className="px-4 py-3 text-sm text-center font-medium">
                                {user.storyQuota === -1 ? 'âˆž' : user.storyQuota}
                              </td>
                              <td className="px-4 py-3 text-sm text-center">{user.storiesGenerated || 0}</td>
                              <td className="px-4 py-3 text-sm text-center">
                                <span className={`px-2 py-1 rounded font-semibold ${
                                  isEmpty ? 'bg-red-100 text-red-800' :
                                  isLow ? 'bg-yellow-100 text-yellow-800' :
                                  'bg-green-100 text-green-800'
                                }`}>
                                  {remaining}
                                </span>
                              </td>
                              <td className="px-4 py-3 text-sm text-center">
                                <span className="text-gray-800">{user.totalOrders || 0}</span>
                                {user.failedOrders > 0 && (
                                  <span className="ml-1 px-1 py-0.5 bg-red-100 text-red-800 rounded text-xs font-semibold">
                                    {user.failedOrders} failed
                                  </span>
                                )}
                              </td>
                              <td className="px-4 py-3 text-sm text-center">
                                <div className="flex gap-1 justify-center flex-wrap">
                                  <button
                                    onClick={() => {
                                      if (confirm(`Set ${user.username}'s quota to 0?`)) {
                                        updateUserQuota(user.id, 0);
                                      }
                                    }}
                                    className="bg-red-600 text-white px-2 py-1 rounded text-xs hover:bg-red-700"
                                    title="Set quota to 0"
                                  >
                                    0
                                  </button>
                                  <button
                                    onClick={() => updateUserQuota(user.id, user.storyQuota + 1)}
                                    className="bg-green-600 text-white px-2 py-1 rounded text-xs hover:bg-green-700"
                                    title="Add 1 story"
                                  >
                                    +1
                                  </button>
                                  <button
                                    onClick={() => updateUserQuota(user.id, user.storyQuota + 5)}
                                    className="bg-indigo-600 text-white px-2 py-1 rounded text-xs hover:bg-indigo-700"
                                    title="Add 5 stories"
                                  >
                                    +5
                                  </button>
                                  <button
                                    onClick={() => updateUserQuota(user.id, user.storyQuota + 10)}
                                    className="bg-indigo-600 text-white px-2 py-1 rounded text-xs hover:bg-indigo-700"
                                    title="Add 10 stories"
                                  >
                                    +10
                                  </button>
                                  <button
                                    onClick={() => {
                                      if (confirm(`Give ${user.username} unlimited stories?`)) {
                                        updateUserQuota(user.id, -1);
                                      }
                                    }}
                                    className="bg-yellow-600 text-white px-2 py-1 rounded text-xs hover:bg-yellow-700"
                                    title="Unlimited stories"
                                  >
                                    âˆž
                                  </button>
                                  <button
                                    onClick={async () => {
                                      try {
                                        const response = await fetch(`${API_URL}/api/admin/users/${user.id}/stories`, {
                                          headers: { 'Authorization': `Bearer ${authToken}` }
                                        });
                                        if (response.ok) {
                                          const data = await response.json();
                                          if (data.stories.length === 0) {
                                            alert(language === 'de' ? 'Keine Geschichten gefunden' : language === 'fr' ? 'Aucune histoire trouvÃ©e' : 'No stories found');
                                            return;
                                          }
                                          // Let admin choose which story to view
                                          const storyChoice = prompt(
                                            `${language === 'de' ? 'Geschichten von' : language === 'fr' ? 'Histoires de' : 'Stories for'} ${data.username || user.username}:\n\n` +
                                            data.stories.map((s, i) => `${i+1}. ${s.title} (${new Date(s.createdAt).toLocaleDateString()})`).join('\n') +
                                            `\n\n${language === 'de' ? 'Nummer eingeben zum Ã–ffnen:' : language === 'fr' ? 'Entrez le numÃ©ro pour ouvrir:' : 'Enter number to open:'}`
                                          );
                                          if (storyChoice) {
                                            const idx = parseInt(storyChoice) - 1;
                                            if (idx >= 0 && idx < data.stories.length) {
                                              const story = data.stories[idx];
                                              // Open in new tab with impersonation params
                                              window.open(`${window.location.origin}${window.location.pathname}?impersonate=${user.id}&story=${story.id}`, '_blank');
                                            }
                                          }
                                        } else {
                                          alert('Failed to fetch stories');
                                        }
                                      } catch (err) {
                                        console.error('Error:', err);
                                        alert('Error fetching stories');
                                      }
                                    }}
                                    className="bg-indigo-600 text-white px-2 py-1 rounded text-xs hover:bg-indigo-700"
                                    title={language === 'de' ? 'Geschichten ansehen' : language === 'fr' ? 'Voir les histoires' : 'View Stories'}
                                  >
                                    ðŸ“š
                                  </button>
                                  {user.role !== 'admin' && (
                                    <button
                                      onClick={() => {
                                        const confirmMsg = language === 'de'
                                          ? `WARNUNG: Dies lÃ¶scht den Benutzer "${user.username}" und ALLE zugehÃ¶rigen Daten (Geschichten, Charaktere, Jobs, etc.) unwiderruflich!\n\nBist du sicher?`
                                          : language === 'fr'
                                          ? `ATTENTION: Cela supprimera l'utilisateur "${user.username}" et TOUTES les donnÃ©es associÃ©es (histoires, personnages, jobs, etc.) de maniÃ¨re irrÃ©versible!\n\nÃŠtes-vous sÃ»r?`
                                          : `WARNING: This will permanently delete user "${user.username}" and ALL associated data (stories, characters, jobs, etc.)!\n\nAre you sure?`;
                                        if (confirm(confirmMsg)) {
                                          const doubleConfirmMsg = language === 'de'
                                            ? `Letzte Warnung! Gib "${user.username}" ein um zu bestÃ¤tigen:`
                                            : language === 'fr'
                                            ? `Dernier avertissement! Tapez "${user.username}" pour confirmer:`
                                            : `Final warning! Type "${user.username}" to confirm:`;
                                          const typed = prompt(doubleConfirmMsg);
                                          if (typed === user.username) {
                                            deleteUser(user.id, user.username);
                                          } else if (typed !== null) {
                                            alert(language === 'de' ? 'Benutzername stimmt nicht Ã¼berein. LÃ¶schung abgebrochen.' : language === 'fr' ? 'Le nom d\'utilisateur ne correspond pas. Suppression annulÃ©e.' : 'Username did not match. Deletion cancelled.');
                                          }
                                        }
                                      }}
                                      className="bg-red-800 text-white px-2 py-1 rounded text-xs hover:bg-red-900"
                                      title={language === 'de' ? 'Benutzer lÃ¶schen' : language === 'fr' ? 'Supprimer l\'utilisateur' : 'Delete User'}
                                    >
                                      ðŸ—‘ï¸
                                    </button>
                                  )}
                                </div>
                              </td>
                            </tr>
                          );
                        })}
                      </tbody>
                    </table>
                  </div>
                )}

                {/* Orphaned Data Section */}
                <div className="mt-8 p-6 bg-indigo-50 rounded-lg border-2 border-indigo-200">
                  <div className="flex justify-between items-center mb-4">
                    <h3 className="text-xl font-bold text-orange-900 flex items-center gap-2">
                      <span>ðŸ—‘ï¸</span>
                      {language === 'de' ? 'Verwaiste Daten' : language === 'fr' ? 'DonnÃ©es orphelines' : 'Orphaned Data'}
                    </h3>
                    <button
                      onClick={checkOrphanedData}
                      disabled={isCheckingOrphaned}
                      className="bg-indigo-600 text-white px-4 py-2 rounded-lg hover:bg-indigo-700 flex items-center gap-2 disabled:opacity-50"
                    >
                      <span>ðŸ”</span>
                      {isCheckingOrphaned
                        ? (language === 'de' ? 'PrÃ¼fe...' : language === 'fr' ? 'VÃ©rification...' : 'Checking...')
                        : (language === 'de' ? 'PrÃ¼fen' : language === 'fr' ? 'VÃ©rifier' : 'Check')}
                    </button>
                  </div>

                  {orphanedData === null ? (
                    <p className="text-gray-500 text-center py-4">
                      {language === 'de'
                        ? 'Klicken Sie auf "PrÃ¼fen", um nach verwaisten Charakteren und Geschichten zu suchen'
                        : language === 'fr'
                        ? 'Cliquez sur "VÃ©rifier" pour rechercher les personnages et histoires orphelins'
                        : 'Click "Check" to scan for orphaned characters and stories'}
                    </p>
                  ) : (
                    <div>
                      <div className="grid grid-cols-2 gap-4 mb-4">
                        <div className="bg-white p-4 rounded-lg border border-orange-300">
                          <div className="text-3xl font-bold text-orange-600">{orphanedData.characters}</div>
                          <div className="text-sm text-gray-500">
                            {language === 'de' ? 'Verwaiste Charaktere' : language === 'fr' ? 'Personnages orphelins' : 'Orphaned Characters'}
                          </div>
                        </div>
                        <div className="bg-white p-4 rounded-lg border border-orange-300">
                          <div className="text-3xl font-bold text-orange-600">{orphanedData.stories}</div>
                          <div className="text-sm text-gray-500">
                            {language === 'de' ? 'Verwaiste Geschichten' : language === 'fr' ? 'Histoires orphelines' : 'Orphaned Stories'}
                          </div>
                        </div>
                      </div>

                      {(orphanedData.characters > 0 || orphanedData.stories > 0) && (
                        <button
                          onClick={deleteOrphanedData}
                          disabled={isCheckingOrphaned}
                          className="w-full bg-red-600 text-white px-4 py-3 rounded-lg hover:bg-red-700 font-semibold disabled:opacity-50"
                        >
                          {language === 'de'
                            ? 'Alle verwaisten Daten lÃ¶schen'
                            : language === 'fr'
                            ? 'Supprimer toutes les donnÃ©es orphelines'
                            : 'Delete All Orphaned Data'}
                        </button>
                      )}

                      {orphanedData.characters === 0 && orphanedData.stories === 0 && (
                        <div className="text-center text-green-600 font-semibold py-2">
                          âœ… {language === 'de' ? 'Keine verwaisten Daten gefunden!' : language === 'fr' ? 'Aucune donnÃ©e orpheline trouvÃ©e !' : 'No orphaned data found!'}
                        </div>
                      )}
                    </div>
                  )}
                </div>

                {/* Orphaned Story Jobs */}
                <div className="mt-4 p-4 bg-purple-50 rounded-lg border border-purple-200">
                  <div className="flex justify-between items-center mb-3">
                    <h3 className="font-semibold text-purple-900">
                      {language === 'de' ? 'Verwaiste Story-Jobs' : language === 'fr' ? 'Jobs orphelins' : 'Orphaned Story Jobs'}
                    </h3>
                    <button
                      onClick={checkOrphanedJobs}
                      disabled={isCheckingOrphanedJobs}
                      className="bg-purple-600 text-white px-3 py-1 rounded hover:bg-purple-700 text-sm disabled:opacity-50 flex items-center gap-1"
                    >
                      <span>ðŸ”</span>
                      {isCheckingOrphanedJobs
                        ? (language === 'de' ? 'PrÃ¼fe...' : language === 'fr' ? 'VÃ©rification...' : 'Checking...')
                        : (language === 'de' ? 'PrÃ¼fen' : language === 'fr' ? 'VÃ©rifier' : 'Check')}
                    </button>
                  </div>

                  {orphanedJobs === null ? (
                    <p className="text-gray-500 text-center py-4">
                      {language === 'de'
                        ? 'Klicken Sie auf "PrÃ¼fen", um nach verwaisten Jobs zu suchen'
                        : language === 'fr'
                        ? 'Cliquez sur "VÃ©rifier" pour rechercher les jobs orphelins'
                        : 'Click "Check" to scan for orphaned story jobs (jobs without matching stories)'}
                    </p>
                  ) : (
                    <div>
                      <div className="bg-white p-4 rounded-lg border border-purple-300 mb-4">
                        <div className="text-3xl font-bold text-purple-600">{orphanedJobs.count}</div>
                        <div className="text-sm text-gray-500">
                          {language === 'de' ? 'Verwaiste Jobs' : language === 'fr' ? 'Jobs orphelins' : 'Orphaned Jobs'}
                        </div>
                      </div>

                      {orphanedJobs.count > 0 && (
                        <>
                          <div className="max-h-40 overflow-y-auto mb-4 text-xs bg-white rounded border p-2">
                            {orphanedJobs.jobs.slice(0, 10).map((job, idx) => (
                              <div key={idx} className="py-1 border-b border-gray-100 last:border-0">
                                <span className="font-mono text-gray-600">{job.id.substring(0, 8)}...</span>
                                <span className="ml-2 text-gray-500">{job.username || 'Unknown'}</span>
                                <span className={`ml-2 px-1 rounded text-white ${
                                  job.status === 'completed' ? 'bg-green-500' :
                                  job.status === 'failed' ? 'bg-red-500' :
                                  job.status === 'processing' ? 'bg-blue-500' : 'bg-gray-500'
                                }`}>{job.status}</span>
                                <span className="ml-2 text-gray-400">{new Date(job.createdAt).toLocaleDateString()}</span>
                              </div>
                            ))}
                            {orphanedJobs.count > 10 && (
                              <div className="text-center text-gray-400 pt-2">...and {orphanedJobs.count - 10} more</div>
                            )}
                          </div>
                          <button
                            onClick={deleteOrphanedJobs}
                            disabled={isCheckingOrphanedJobs}
                            className="w-full bg-red-600 text-white px-4 py-3 rounded-lg hover:bg-red-700 font-semibold disabled:opacity-50"
                          >
                            {language === 'de'
                              ? 'Alle verwaisten Jobs lÃ¶schen'
                              : language === 'fr'
                              ? 'Supprimer tous les jobs orphelins'
                              : 'Delete All Orphaned Jobs'}
                          </button>
                        </>
                      )}

                      {orphanedJobs.count === 0 && (
                        <div className="text-center text-green-600 font-semibold py-2">
                          âœ… {language === 'de' ? 'Keine verwaisten Jobs gefunden!' : language === 'fr' ? 'Aucun job orphelin trouvÃ© !' : 'No orphaned jobs found!'}
                        </div>
                      )}
                    </div>
                  )}
                </div>

                <div className="mt-6 p-4 bg-indigo-50 rounded-lg border border-indigo-200">
                  <h3 className="font-semibold text-indigo-900 mb-2">Quick Guide:</h3>
                  <ul className="text-sm text-indigo-800 space-y-1">
                    <li>â€¢ Default quota for new users: 2 stories</li>
                    <li>â€¢ Admin accounts have unlimited stories (âˆž)</li>
                    <li>â€¢ Click +1, +5, or +10 to add stories to a user's quota</li>
                    <li>â€¢ Click âˆž to give unlimited access</li>
                  </ul>
                </div>
                </>
                )}

                {/* Orders Tab */}
                {adminTab === 'orders' && (
                  <div>
                    <div className="flex gap-3 mb-4">
                      <button
                        onClick={fetchFailedOrders}
                        disabled={isLoadingOrders}
                        className="bg-indigo-600 text-white px-4 py-2 rounded-lg hover:bg-indigo-700 flex items-center gap-2 disabled:opacity-50"
                      >
                        <span>ðŸ”„</span>
                        {isLoadingOrders ? 'Loading...' : 'Refresh Orders'}
                      </button>
                    </div>

                    {isLoadingOrders ? (
                      <div className="text-center py-8">
                        <div className="animate-spin text-4xl mb-2">â³</div>
                        <p>{language === 'de' ? 'Lade Bestellungen...' : language === 'fr' ? 'Chargement des commandes...' : 'Loading orders...'}</p>
                      </div>
                    ) : failedOrders.length === 0 ? (
                      <div className="text-center py-8 bg-green-50 rounded-lg border border-green-200">
                        <div className="text-4xl mb-2">âœ…</div>
                        <p className="text-green-700 font-semibold">
                          {language === 'de' ? 'Keine fehlgeschlagenen Bestellungen!' : language === 'fr' ? 'Aucune commande Ã©chouÃ©e!' : 'No failed orders!'}
                        </p>
                      </div>
                    ) : (
                      <div className="overflow-x-auto">
                        <table className="w-full border-collapse">
                          <thead>
                            <tr className="bg-red-100">
                              <th className="px-4 py-3 text-left text-sm font-semibold text-gray-800">Order ID</th>
                              <th className="px-4 py-3 text-left text-sm font-semibold text-gray-800">Customer</th>
                              <th className="px-4 py-3 text-left text-sm font-semibold text-gray-800">Email</th>
                              <th className="px-4 py-3 text-left text-sm font-semibold text-gray-800">Shipping</th>
                              <th className="px-4 py-3 text-center text-sm font-semibold text-gray-800">Amount</th>
                              <th className="px-4 py-3 text-center text-sm font-semibold text-gray-800">Date</th>
                              <th className="px-4 py-3 text-center text-sm font-semibold text-gray-800">Actions</th>
                            </tr>
                          </thead>
                          <tbody>
                            {failedOrders.map(order => (
                              <tr key={order.id} className="border-b hover:bg-red-50">
                                <td className="px-4 py-3 text-sm font-mono">{order.id}</td>
                                <td className="px-4 py-3 text-sm font-medium">{order.customer_name || '-'}</td>
                                <td className="px-4 py-3 text-sm">{order.customer_email || '-'}</td>
                                <td className="px-4 py-3 text-sm">
                                  {order.shipping_city}, {order.shipping_postal_code} {order.shipping_country}
                                </td>
                                <td className="px-4 py-3 text-sm text-center font-semibold">
                                  {(order.amount_total / 100).toFixed(2)} {order.currency?.toUpperCase()}
                                </td>
                                <td className="px-4 py-3 text-sm text-center">
                                  {new Date(order.created_at).toLocaleDateString()}
                                </td>
                                <td className="px-4 py-3 text-sm text-center">
                                  <button
                                    onClick={() => retryPrintOrder(order.id)}
                                    disabled={retryingOrderId === order.id}
                                    className="bg-green-600 text-white px-3 py-1 rounded text-sm hover:bg-green-700 disabled:opacity-50 flex items-center gap-1 mx-auto"
                                  >
                                    {retryingOrderId === order.id ? (
                                      <>
                                        <span className="animate-spin">â³</span>
                                        Retrying...
                                      </>
                                    ) : (
                                      <>
                                        <Icon name="refresh-cw" size={14} />
                                        Retry Print
                                      </>
                                    )}
                                  </button>
                                </td>
                              </tr>
                            ))}
                          </tbody>
                        </table>
                      </div>
                    )}

                    <div className="mt-6 p-4 bg-yellow-50 rounded-lg border border-yellow-200">
                      <h3 className="font-semibold text-yellow-900 mb-2">{language === 'de' ? 'Info:' : language === 'fr' ? 'Info:' : 'Info:'}</h3>
                      <ul className="text-sm text-yellow-800 space-y-1">
                        <li>â€¢ {language === 'de' ? 'Fehlgeschlagene Bestellungen: Zahlung erfolgreich, aber DruckÃ¼bertragung fehlgeschlagen' : language === 'fr' ? 'Commandes Ã©chouÃ©es: paiement rÃ©ussi mais transfert d\'impression Ã©chouÃ©' : 'Failed orders: payment succeeded but print submission failed'}</li>
                        <li>â€¢ {language === 'de' ? 'Klicken Sie auf "Retry Print" um die Bestellung erneut an den Druckdienstleister zu senden' : language === 'fr' ? 'Cliquez sur "Retry Print" pour renvoyer la commande au fournisseur d\'impression' : 'Click "Retry Print" to resend the order to the print provider'}</li>
                      </ul>
                    </div>
                  </div>
                )}
              </div>
            </div>
          )}

          {/* Products Management Panel Modal */}
          {showProductsPanel && currentUser && currentUser.role === 'admin' && (
            <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4 overflow-y-auto">
              <div className="bg-white rounded-xl shadow-2xl max-w-6xl w-full max-h-[90vh] overflow-y-auto p-8 animate-fade-in">
                <div className="flex justify-between items-center mb-6">
                  <h2 className="text-3xl font-bold text-yellow-700 flex items-center gap-2">
                    <span className="text-4xl">ðŸ“¦</span>
                    {language === 'de' ? 'Produktverwaltung' : language === 'fr' ? 'Gestion des produits' : 'Product Management'}
                  </h2>
                  <button
                    onClick={() => setShowProductsPanel(false)}
                    className="text-gray-500 hover:text-gray-800 text-2xl font-bold"
                  >
                    âœ•
                  </button>
                </div>

                <div className="flex justify-between items-center mb-4 gap-4">
                  <div className="flex gap-2">
                    <button
                      onClick={fetchPrintProducts}
                      className="bg-indigo-600 text-white px-4 py-2 rounded-lg hover:bg-indigo-700 flex items-center gap-2"
                    >
                      <span>ðŸ”„</span>
                      Refresh
                    </button>
                    <button
                      onClick={fetchPrintApiProducts}
                      className="bg-indigo-600 text-white px-4 py-2 rounded-lg hover:bg-indigo-700 flex items-center gap-2"
                    >
                      <span>ðŸŒ</span>
                      Fetch from Print Provider
                    </button>
                  </div>
                  <button
                    onClick={() => {
                      setShowProductForm(true);
                      setEditingProduct(null);
                      setProductForm({
                        product_uid: '',
                        product_name: '',
                        description: '',
                        size: '',
                        cover_type: '',
                        min_pages: 24,
                        max_pages: 24,
                        available_page_counts: '[24]',
                        is_active: true
                      });
                    }}
                    className="bg-green-600 text-white px-4 py-2 rounded-lg hover:bg-green-700 flex items-center gap-2"
                  >
                    <span>âž•</span>
                    Add Product
                  </button>
                </div>

                {printProducts.length === 0 ? (
                  <div className="text-center py-12 bg-gray-50 rounded-lg">
                    <div className="text-gray-300 mb-4 text-6xl">ðŸ“¦</div>
                    <p className="text-gray-500 text-lg mb-2">No print products configured</p>
                    <p className="text-gray-400 text-sm">Click "Fetch from Print Provider" to import available products</p>
                  </div>
                ) : (
                  <div className="overflow-x-auto">
                    <table className="w-full border-collapse">
                      <thead>
                        <tr className="bg-gray-100">
                          <th className="px-4 py-3 text-left text-sm font-semibold text-gray-800">Status</th>
                          <th className="px-4 py-3 text-left text-sm font-semibold text-gray-800">Product Name</th>
                          <th className="px-4 py-3 text-left text-sm font-semibold text-gray-800">Size</th>
                          <th className="px-4 py-3 text-left text-sm font-semibold text-gray-800">Cover</th>
                          <th className="px-4 py-3 text-center text-sm font-semibold text-gray-800">Pages</th>
                          <th className="px-4 py-3 text-center text-sm font-semibold text-gray-800">Actions</th>
                        </tr>
                      </thead>
                      <tbody>
                        {printProducts.map(product => (
                          <tr key={product.id} className="border-b hover:bg-gray-50">
                            <td className="px-4 py-3 text-sm text-center">
                              <button
                                onClick={() => toggleProductActive(product.id, product.is_active)}
                                className={`px-3 py-1 rounded-full text-xs font-semibold ${
                                  product.is_active
                                    ? 'bg-green-100 text-green-800 hover:bg-green-200'
                                    : 'bg-red-100 text-red-800 hover:bg-red-200'
                                }`}
                              >
                                {product.is_active ? 'âœ“ Active' : 'âœ• Inactive'}
                              </button>
                            </td>
                            <td className="px-4 py-3 text-sm font-medium text-gray-900">
                              {product.product_name}
                              <div className="text-xs text-gray-500 mt-1">{product.description}</div>
                            </td>
                            <td className="px-4 py-3 text-sm">{product.size}</td>
                            <td className="px-4 py-3 text-sm">{product.cover_type}</td>
                            <td className="px-4 py-3 text-sm text-center">
                              {product.min_pages === product.max_pages
                                ? product.min_pages
                                : `${product.min_pages}-${product.max_pages}`}
                            </td>
                            <td className="px-4 py-3 text-sm text-center">
                              <div className="flex gap-2 justify-center">
                                <button
                                  onClick={() => {
                                    setEditingProduct(product);
                                    setProductForm({
                                      product_uid: product.product_uid,
                                      product_name: product.product_name,
                                      description: product.description,
                                      size: product.size,
                                      cover_type: product.cover_type,
                                      min_pages: product.min_pages,
                                      max_pages: product.max_pages,
                                      available_page_counts: product.available_page_counts,
                                      is_active: product.is_active
                                    });
                                    setShowProductForm(true);
                                  }}
                                  className="bg-indigo-600 text-white px-3 py-1 rounded hover:bg-indigo-700"
                                  title="Edit product"
                                >
                                  âœï¸
                                </button>
                                <button
                                  onClick={() => {
                                    if (confirm(`Delete product "${product.product_name}"?`)) {
                                      deletePrintProduct(product.id);
                                    }
                                  }}
                                  className="bg-red-600 text-white px-3 py-1 rounded hover:bg-red-700"
                                  title="Delete product"
                                >
                                  ðŸ—‘ï¸
                                </button>
                              </div>
                            </td>
                          </tr>
                        ))}
                      </tbody>
                    </table>
                  </div>
                )}

                <div className="mt-6 p-4 bg-yellow-50 rounded-lg border border-yellow-200">
                  <h3 className="font-semibold text-yellow-900 mb-2">About Print Products:</h3>
                  <ul className="text-sm text-yellow-800 space-y-1">
                    <li>â€¢ Click "Fetch from Print Provider" to import available photobook products</li>
                    <li>â€¢ Active products are available for print ordering</li>
                    <li>â€¢ Page counts must match the provider's supported values (typically 24, 28, 32, 36, 40)</li>
                    <li>â€¢ Product UIDs come directly from the print provider's catalog</li>
                  </ul>
                </div>
              </div>
            </div>
          )}

          {/* Product Form Modal */}
          {showProductForm && currentUser && currentUser.role === 'admin' && (
            <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4 overflow-y-auto">
              <div className="bg-white rounded-xl shadow-2xl max-w-2xl w-full p-8 animate-fade-in">
                <div className="flex justify-between items-center mb-6">
                  <h2 className="text-2xl font-bold text-yellow-700">
                    {editingProduct ? 'Edit Print Product' : 'Add Print Product'}
                  </h2>
                  <button
                    onClick={() => {
                      setShowProductForm(false);
                      setEditingProduct(null);
                    }}
                    className="text-gray-500 hover:text-gray-800 text-2xl font-bold"
                  >
                    âœ•
                  </button>
                </div>

                <div className="space-y-4">
                  <div>
                    <label className="block text-sm font-semibold text-gray-800 mb-2">
                      Product UID <span className="text-red-500">*</span>
                    </label>
                    <input
                      type="text"
                      value={productForm.product_uid}
                      onChange={(e) => setProductForm({ ...productForm, product_uid: e.target.value })}
                      placeholder="photobooks-softcover_pf_140x140-mm..."
                      className="w-full px-4 py-2 border-2 border-gray-300 rounded-lg focus:border-yellow-500 focus:outline-none"
                    />
                    <p className="text-xs text-gray-500 mt-1">From the print provider's product catalog API</p>
                  </div>

                  <div>
                    <label className="block text-sm font-semibold text-gray-800 mb-2">
                      Product Name <span className="text-red-500">*</span>
                    </label>
                    <input
                      type="text"
                      value={productForm.product_name}
                      onChange={(e) => setProductForm({ ...productForm, product_name: e.target.value })}
                      placeholder="14x14cm Softcover Photobook - 24 pages"
                      className="w-full px-4 py-2 border-2 border-gray-300 rounded-lg focus:border-yellow-500 focus:outline-none"
                    />
                  </div>

                  <div>
                    <label className="block text-sm font-semibold text-gray-800 mb-2">Description</label>
                    <input
                      type="text"
                      value={productForm.description}
                      onChange={(e) => setProductForm({ ...productForm, description: e.target.value })}
                      placeholder="Square softcover photobook with 24 pages"
                      className="w-full px-4 py-2 border-2 border-gray-300 rounded-lg focus:border-yellow-500 focus:outline-none"
                    />
                  </div>

                  <div className="grid grid-cols-2 gap-4">
                    <div>
                      <label className="block text-sm font-semibold text-gray-800 mb-2">Size</label>
                      <input
                        type="text"
                        value={productForm.size}
                        onChange={(e) => setProductForm({ ...productForm, size: e.target.value })}
                        placeholder="14x14cm"
                        className="w-full px-4 py-2 border-2 border-gray-300 rounded-lg focus:border-yellow-500 focus:outline-none"
                      />
                    </div>
                    <div>
                      <label className="block text-sm font-semibold text-gray-800 mb-2">Cover Type</label>
                      <input
                        type="text"
                        value={productForm.cover_type}
                        onChange={(e) => setProductForm({ ...productForm, cover_type: e.target.value })}
                        placeholder="Softcover"
                        className="w-full px-4 py-2 border-2 border-gray-300 rounded-lg focus:border-yellow-500 focus:outline-none"
                      />
                    </div>
                  </div>

                  <div className="grid grid-cols-2 gap-4">
                    <div>
                      <label className="block text-sm font-semibold text-gray-800 mb-2">
                        Min Pages <span className="text-red-500">*</span>
                      </label>
                      <input
                        type="number"
                        value={productForm.min_pages}
                        onChange={(e) => setProductForm({ ...productForm, min_pages: parseInt(e.target.value) })}
                        min="1"
                        className="w-full px-4 py-2 border-2 border-gray-300 rounded-lg focus:border-yellow-500 focus:outline-none"
                      />
                    </div>
                    <div>
                      <label className="block text-sm font-semibold text-gray-800 mb-2">
                        Max Pages <span className="text-red-500">*</span>
                      </label>
                      <input
                        type="number"
                        value={productForm.max_pages}
                        onChange={(e) => setProductForm({ ...productForm, max_pages: parseInt(e.target.value) })}
                        min="1"
                        className="w-full px-4 py-2 border-2 border-gray-300 rounded-lg focus:border-yellow-500 focus:outline-none"
                      />
                    </div>
                  </div>

                  <div>
                    <label className="block text-sm font-semibold text-gray-800 mb-2">
                      Available Page Counts (JSON Array) <span className="text-red-500">*</span>
                    </label>
                    <input
                      type="text"
                      value={productForm.available_page_counts}
                      onChange={(e) => setProductForm({ ...productForm, available_page_counts: e.target.value })}
                      placeholder="[24,28,32,36,40]"
                      className="w-full px-4 py-2 border-2 border-gray-300 rounded-lg focus:border-yellow-500 focus:outline-none"
                    />
                    <p className="text-xs text-gray-500 mt-1">Format: [24,28,32] - must be valid JSON array</p>
                  </div>

                  <div className="flex items-center gap-2">
                    <input
                      type="checkbox"
                      id="is_active"
                      checked={productForm.is_active}
                      onChange={(e) => setProductForm({ ...productForm, is_active: e.target.checked })}
                      className="w-5 h-5 text-yellow-600"
                    />
                    <label htmlFor="is_active" className="text-sm font-semibold text-gray-800">
                      Active (available for print ordering)
                    </label>
                  </div>

                  <div className="flex gap-3 pt-4">
                    <button
                      onClick={savePrintProduct}
                      className="flex-1 bg-yellow-600 text-white px-6 py-3 rounded-lg hover:bg-yellow-700 font-semibold"
                    >
                      {editingProduct ? 'Update Product' : 'Add Product'}
                    </button>
                    <button
                      onClick={() => {
                        setShowProductForm(false);
                        setEditingProduct(null);
                      }}
                      className="px-6 py-3 bg-gray-200 text-gray-800 rounded-lg hover:bg-gray-300 font-semibold"
                    >
                      Cancel
                    </button>
                  </div>
                </div>
              </div>
            </div>
          )}

          {/* Saved Stories Modal */}
          {showSavedStories && (
            <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4 overflow-y-auto">
              <div className="bg-white rounded-xl shadow-2xl max-w-6xl w-full max-h-[90vh] overflow-y-auto p-8 animate-fade-in">
                <div className="flex justify-between items-center mb-6">
                  <h2 className="text-3xl font-bold text-gray-800 flex items-center gap-2">
                    <Icon name="book-open" size={32} />
                    My Saved Stories
                  </h2>
                  <div className="flex items-center gap-2">
                    <button
                      onClick={async () => {
                        console.log('ðŸ”„ Manual refresh of stories...');
                        const stories = await loadStories();
                        console.log('âœ… Refreshed stories:', stories.length);
                        setSavedStories(stories);
                      }}
                      className="text-indigo-600 hover:text-indigo-700 flex items-center gap-1 px-3 py-1 rounded hover:bg-indigo-50"
                      title="Refresh stories"
                    >
                      <Icon name="refresh-cw" size={20} />
                      <span className="text-sm">Refresh</span>
                    </button>
                    <button
                      onClick={() => setShowSavedStories(false)}
                      className="text-gray-500 hover:text-gray-800"
                    >
                      <Icon name="x" size={24} />
                    </button>
                  </div>
                </div>

                {savedStories.length === 0 ? (
                  <div className="text-center py-12">
                    <Icon name="book" size={64} className="mx-auto text-gray-300 mb-4" />
                    <p className="text-gray-500 text-lg">No saved stories yet. Create your first story!</p>
                  </div>
                ) : (
                  <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                    {savedStories.map(story => (
                      <div key={story.id} className="bg-white rounded-xl p-6 border-2 border-gray-200 hover:border-indigo-300 hover:shadow-lg transition-all">
                        <div className="flex justify-between items-start mb-4">
                          <h3 className="text-lg font-bold text-gray-800 flex-1">{story.title}</h3>
                          <button
                            onClick={async () => {
                              if (confirm('Delete this story?')) {
                                try {
                                  const response = await fetch(`${API_URL}/api/stories/${story.id}`, {
                                    method: 'DELETE',
                                    headers: { 'Authorization': `Bearer ${authToken}` }
                                  });
                                  if (response.ok) {
                                    const updated = await loadStories();
                                    setSavedStories(updated);
                                  }
                                } catch (err) {
                                  console.error('Error deleting story:', err);
                                }
                              }
                            }}
                            className="text-red-500 hover:text-red-700"
                          >
                            <Icon name="trash-2" size={18} />
                          </button>
                        </div>

                        {/* Thumbnail */}
                        {story.thumbnail && (
                          <div className="mb-4">
                            <img
                              src={story.thumbnail}
                              alt={story.title}
                              className="w-full h-48 object-cover rounded-lg shadow-md"
                            />
                          </div>
                        )}

                        <div className="mb-4">
                          <p className="text-sm text-gray-500 mb-2">
                            <strong>Type:</strong> {story.storyType}
                          </p>
                          <p className="text-sm text-gray-500 mb-2">
                            <strong>Pages:</strong> {story.pages}
                          </p>
                          <p className="text-sm text-gray-500 mb-2">
                            <strong>Characters:</strong> {story.characters?.length || 0}
                          </p>
                          <p className="text-sm text-gray-500">
                            <strong>Created:</strong> {new Date(story.createdAt).toLocaleDateString()}
                          </p>
                        </div>

                        {/* Thumbnail placeholder - removed, now using actual thumbnail above */}

                        <button
                          onClick={async () => {
                            try {
                              console.log(`ðŸ“– Loading full story: ${story.id}`);

                              // Reset progress and show progress modal
                              setLoadingProgress(0);
                              setLoadingBytes(0);
                              setLoadingTotalBytes(0);
                              setShowLoadingProgress(true);

                              // Fetch full story with all images using progress tracking
                              const fullStory = await fetchWithProgress(`${API_URL}/api/stories/${story.id}`, {
                                headers: { 'Authorization': `Bearer ${authToken}` }
                              });

                              console.log(`âœ… Loaded full story with ${fullStory.sceneImages?.length || 0} images`);

                              // Load the full story data
                              setCurrentStoryId(fullStory.id);
                              setStoryType(fullStory.storyType);
                              setArtStyle(fullStory.artStyle);
                              setPages(fullStory.pages);
                              setLanguageLevel(fullStory.languageLevel || 'standard'); // Critical for display mode (picture book vs standard)
                              setLanguage(fullStory.language || 'en');
                              setDedication(fullStory.dedication || '');
                              setCharacters(fullStory.characters || []);
                              setMainCharacters(fullStory.mainCharacters || []);
                              setRelationships(fullStory.relationships || {});
                              setRelationshipTexts(fullStory.relationshipTexts || {});
                              setStoryOutline(fullStory.outline || '');
                              setGeneratedStory(fullStory.story || '');
                              setSceneDescriptions(fullStory.sceneDescriptions || []);
                              setSceneImages(fullStory.sceneImages || []);
                              setStoryTitle(fullStory.title || '');
                              setCoverImages(fullStory.coverImages || { frontCover: null, initialPage: null, backCover: null });
                              setImagePrompts(fullStory.imagePrompts || {}); // Load image prompts for developer features
                              setCoverImagePrompts(fullStory.coverImagePrompts || {}); // Load cover image prompts for developer features
                              setRawAIResponse(fullStory.rawAIResponse || ''); // Load raw AI response for developer features
                              setStep(5);
                              setShowSavedStories(false);
                              setShowLoadingProgress(false);
                            } catch (err) {
                              console.error('âŒ Error loading story:', err);
                              setShowLoadingProgress(false);
                              alert(`Failed to load story: ${err.message}`);
                            }
                          }}
                          className="w-full bg-indigo-600 text-white py-2 rounded-lg hover:bg-indigo-700 font-semibold flex items-center justify-center gap-2"
                        >
                          <Icon name="eye" size={18} />
                          View Story
                        </button>
                      </div>
                    ))}
                  </div>
                )}
              </div>
            </div>
          )}

          {/* Shipping Address Modal */}
          {showShippingModal && (
            <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4">
              <div className="bg-white rounded-xl shadow-2xl max-w-2xl w-full p-8 animate-fade-in">
                <div className="flex justify-between items-center mb-6">
                  <h2 className="text-3xl font-bold text-gray-800 flex items-center gap-2">
                    <Icon name="truck" size={32} />
                    {language === 'de' ? 'Lieferadresse' : language === 'fr' ? 'Adresse de livraison' : 'Shipping Address'}
                  </h2>
                  <button
                    onClick={() => setShowShippingModal(false)}
                    className="text-gray-500 hover:text-gray-800"
                  >
                    <Icon name="x" size={24} />
                  </button>
                </div>

                <form onSubmit={(e) => { e.preventDefault(); submitPrintOrder(); }} className="space-y-4">
                  <div className="grid grid-cols-2 gap-4">
                    <div>
                      <label className="block text-sm font-semibold text-gray-800 mb-1">
                        {language === 'de' ? 'Vorname' : language === 'fr' ? 'PrÃ©nom' : 'First Name'}
                      </label>
                      <input
                        type="text"
                        required
                        value={shippingForm.firstName}
                        onChange={(e) => setShippingForm(prev => ({ ...prev, firstName: e.target.value }))}
                        className="w-full px-4 py-2 border-2 border-indigo-200 rounded-lg focus:border-indigo-600 focus:outline-none"
                      />
                    </div>
                    <div>
                      <label className="block text-sm font-semibold text-gray-800 mb-1">
                        {language === 'de' ? 'Nachname' : language === 'fr' ? 'Nom' : 'Last Name'}
                      </label>
                      <input
                        type="text"
                        required
                        value={shippingForm.lastName}
                        onChange={(e) => setShippingForm(prev => ({ ...prev, lastName: e.target.value }))}
                        className="w-full px-4 py-2 border-2 border-indigo-200 rounded-lg focus:border-indigo-600 focus:outline-none"
                      />
                    </div>
                  </div>

                  <div>
                    <label className="block text-sm font-semibold text-gray-800 mb-1">
                      {language === 'de' ? 'StraÃŸe und Hausnummer' : language === 'fr' ? 'Adresse' : 'Address Line 1'}
                    </label>
                    <input
                      type="text"
                      required
                      value={shippingForm.addressLine1}
                      onChange={(e) => setShippingForm(prev => ({ ...prev, addressLine1: e.target.value }))}
                      className="w-full px-4 py-2 border-2 border-indigo-200 rounded-lg focus:border-indigo-600 focus:outline-none"
                    />
                  </div>

                  <div className="grid grid-cols-2 gap-4">
                    <div>
                      <label className="block text-sm font-semibold text-gray-800 mb-1">
                        {language === 'de' ? 'Stadt' : language === 'fr' ? 'Ville' : 'City'}
                      </label>
                      <input
                        type="text"
                        required
                        value={shippingForm.city}
                        onChange={(e) => setShippingForm(prev => ({ ...prev, city: e.target.value }))}
                        className="w-full px-4 py-2 border-2 border-indigo-200 rounded-lg focus:border-indigo-600 focus:outline-none"
                      />
                    </div>
                    <div>
                      <label className="block text-sm font-semibold text-gray-800 mb-1">
                        {language === 'de' ? 'Postleitzahl' : language === 'fr' ? 'Code postal' : 'Postal Code'}
                      </label>
                      <input
                        type="text"
                        required
                        value={shippingForm.postCode}
                        onChange={(e) => setShippingForm(prev => ({ ...prev, postCode: e.target.value }))}
                        className="w-full px-4 py-2 border-2 border-indigo-200 rounded-lg focus:border-indigo-600 focus:outline-none"
                      />
                    </div>
                  </div>

                  <div>
                    <label className="block text-sm font-semibold text-gray-800 mb-1">
                      {language === 'de' ? 'Land' : language === 'fr' ? 'Pays' : 'Country'}
                    </label>
                    <input
                      type="text"
                      readOnly
                      value={language === 'de' ? 'Schweiz (CH)' : language === 'fr' ? 'Suisse (CH)' : 'Switzerland (CH)'}
                      className="w-full px-4 py-2 border-2 border-gray-200 rounded-lg bg-gray-50 text-gray-500 cursor-not-allowed"
                      title={language === 'de' ? 'Versand nur in die Schweiz verfÃ¼gbar' : language === 'fr' ? 'ExpÃ©dition disponible uniquement en Suisse' : 'Shipping available to Switzerland only'}
                    />
                  </div>

                  <div>
                    <label className="block text-sm font-semibold text-gray-800 mb-1">
                      {language === 'de' ? 'E-Mail' : language === 'fr' ? 'E-mail' : 'Email'}
                    </label>
                    <input
                      type="email"
                      required
                      value={shippingForm.email}
                      onChange={(e) => {
                        setShippingForm(prev => ({ ...prev, email: e.target.value }));
                        setEmailChanged(true);
                      }}
                      className="w-full px-4 py-2 border-2 border-indigo-200 rounded-lg focus:border-indigo-600 focus:outline-none"
                    />
                    {emailChanged && shippingForm.email !== currentUser?.username && (
                      <p className="text-sm text-orange-600 mt-1">
                        {language === 'de'
                          ? 'Ihre E-Mail-Adresse wird beim Speichern aktualisiert'
                          : language === 'fr'
                          ? 'Votre adresse e-mail sera mise Ã  jour lors de l\'enregistrement'
                          : 'Your email address will be updated when you submit'}
                      </p>
                    )}
                  </div>

                  <div className="flex gap-3 pt-4">
                    <button
                      type="button"
                      onClick={() => setShowShippingModal(false)}
                      className="flex-1 bg-gray-200 text-gray-800 py-3 rounded-lg hover:bg-gray-300 font-semibold"
                    >
                      {language === 'de' ? 'Abbrechen' : language === 'fr' ? 'Annuler' : 'Cancel'}
                    </button>
                    <button
                      type="submit"
                      className="flex-1 bg-indigo-600 text-white py-3 rounded-lg hover:bg-indigo-700 font-semibold flex items-center justify-center gap-2"
                    >
                      <Icon name="printer" size={20} />
                      {language === 'de' ? 'Druckauftrag erstellen' : language === 'fr' ? 'CrÃ©er la commande' : 'Create Print Order'}
                    </button>
                  </div>
                </form>
              </div>
            </div>
          )}

          {/* Loading Progress Modal */}
          {showLoadingProgress && (
            <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4">
              <div className="bg-white rounded-xl shadow-2xl max-w-md w-full p-8 animate-fade-in">
                <div className="text-center mb-6">
                  <h2 className="text-2xl font-bold text-gray-800 mb-2">Loading Story...</h2>
                  <p className="text-gray-500">
                    {loadingTotalBytes > 0
                      ? `${(loadingBytes / 1024 / 1024).toFixed(2)} MB / ${(loadingTotalBytes / 1024 / 1024).toFixed(2)} MB`
                      : 'Preparing download...'}
                  </p>
                </div>

                {/* Progress Bar */}
                <div className="mb-4">
                  <div className="w-full bg-gray-100 rounded-full h-2 overflow-hidden">
                    <div
                      className="bg-indigo-600 h-full transition-all duration-500 ease-out"
                      style={{ width: `${loadingProgress}%` }}
                    />
                  </div>
                  {loadingProgress > 0 && (
                    <p className="text-sm text-gray-500 text-center mt-2">{loadingProgress}%</p>
                  )}
                </div>

                <p className="text-sm text-gray-500 text-center">
                  Please wait while we load your story with all images...
                </p>
              </div>
            </div>
          )}

          {/* Order Success Modal */}
          {showOrderModal && orderData && (
            <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4">
              <div className="bg-white rounded-xl shadow-2xl max-w-2xl w-full p-8 animate-fade-in max-h-[90vh] overflow-y-auto">
                <div className="text-center mb-6">
                  <h2 className="text-3xl font-bold text-gray-800 mb-2">
                    {orderData.isDraft
                      ? (language === 'de' ? 'ðŸ“‹ Vorschau-Bestellung' : language === 'fr' ? 'ðŸ“‹ Commande d\'aperÃ§u' : 'ðŸ“‹ Preview Order')
                      : (language === 'de' ? 'âœ… Bestellung erstellt!' : language === 'fr' ? 'âœ… Commande crÃ©Ã©e!' : 'âœ… Order Created!')
                    }
                  </h2>
                  <p className="text-gray-500">
                    {orderData.isDraft
                      ? (language === 'de' ? 'ENTWURF (wird nicht gedruckt)' : language === 'fr' ? 'BROUILLON (ne sera pas imprimÃ©)' : 'DRAFT (will not be printed)')
                      : (language === 'de' ? 'WIRD GEDRUCKT' : language === 'fr' ? 'EN IMPRESSION' : 'PRINTING')
                    }
                  </p>
                </div>

                <div className="space-y-4 mb-6">
                  {/* Order ID */}
                  <div className="bg-indigo-50 border border-indigo-200 rounded-lg p-4">
                    <div className="text-sm font-medium text-gray-800 mb-1">
                      {language === 'de' ? 'Bestellnummer' : language === 'fr' ? 'NumÃ©ro de commande' : 'Order ID'}
                    </div>
                    <div className="text-lg font-mono font-bold text-gray-800 select-all">
                      {orderData.orderId}
                    </div>
                  </div>

                  {/* PDF Filename */}
                  <div className="bg-gray-50 border border-gray-200 rounded-lg p-4">
                    <div className="text-sm font-medium text-gray-800 mb-1">PDF</div>
                    <div className="text-gray-900 select-all break-all">{orderData.pdfFilename}</div>
                  </div>

                  {/* Dashboard Link */}
                  <div className="bg-indigo-50 border border-indigo-200 rounded-lg p-4">
                    <div className="text-sm font-medium text-gray-800 mb-2">
                      {language === 'de' ? 'Druckdienstleister Dashboard' : language === 'fr' ? 'Tableau de bord impression' : 'Print Provider Dashboard'}
                    </div>
                    <a
                      href={orderData.dashboardUrl}
                      target="_blank"
                      rel="noopener noreferrer"
                      className="text-indigo-600 hover:text-indigo-800 underline break-all select-all"
                    >
                      {orderData.dashboardUrl}
                    </a>
                  </div>

                  {/* Preview URLs (if draft) */}
                  {orderData.isDraft && orderData.previewUrls && orderData.previewUrls.length > 0 && (
                    <div className="bg-green-50 border border-green-200 rounded-lg p-4">
                      <div className="text-sm font-medium text-gray-800 mb-2">
                        {language === 'de' ? 'Vorschau-Links' : language === 'fr' ? 'Liens d\'aperÃ§u' : 'Preview Links'}
                      </div>
                      <div className="space-y-2">
                        {orderData.previewUrls.map((preview, idx) => (
                          <a
                            key={idx}
                            href={preview.url}
                            target="_blank"
                            rel="noopener noreferrer"
                            className="block text-green-600 hover:text-green-800 underline break-all select-all text-sm"
                          >
                            {preview.url}
                          </a>
                        ))}
                      </div>
                    </div>
                  )}

                  {/* Email confirmation (non-draft) */}
                  {!orderData.isDraft && orderData.email && (
                    <div className="bg-yellow-50 border border-yellow-200 rounded-lg p-4">
                      <div className="text-sm text-gray-800">
                        {language === 'de'
                          ? `Sie erhalten eine BestÃ¤tigungs-E-Mail an ${orderData.email}`
                          : language === 'fr'
                          ? `Vous recevrez un e-mail de confirmation Ã  ${orderData.email}`
                          : `You will receive a confirmation email at ${orderData.email}`
                        }
                      </div>
                    </div>
                  )}

                  {/* Draft warning */}
                  {orderData.isDraft && (
                    <div className="bg-indigo-50 border border-indigo-200 rounded-lg p-4">
                      <div className="text-sm text-orange-700">
                        âš ï¸ {language === 'de'
                          ? 'Um tatsÃ¤chlich zu drucken, Ã¤ndern Sie GELATO_ORDER_TYPE in .env von "draft" auf "order"'
                          : language === 'fr'
                          ? 'Pour imprimer rÃ©ellement, changez GELATO_ORDER_TYPE dans .env de "draft" Ã  "order"'
                          : 'To actually print, change GELATO_ORDER_TYPE in .env from "draft" to "order"'
                        }
                      </div>
                    </div>
                  )}
                </div>

                {/* Action Buttons */}
                <div className="flex gap-4">
                  {/* Admin-only PDF Download Button */}
                  {currentUser && currentUser.role === 'admin' && orderData.pdfUrl && (
                    <a
                      href={orderData.pdfUrl}
                      download={orderData.pdfFilename || 'story.pdf'}
                      className="flex-1 bg-green-600 text-white py-3 rounded-lg hover:bg-green-700 font-semibold flex items-center justify-center gap-2"
                    >
                      <Icon name="download" size={20} />
                      {language === 'de' ? 'PDF herunterladen' : language === 'fr' ? 'TÃ©lÃ©charger PDF' : 'Download PDF'}
                    </a>
                  )}

                  <button
                    onClick={() => setShowOrderModal(false)}
                    className={`${currentUser && currentUser.role === 'admin' ? 'flex-1' : 'w-full'} bg-indigo-600 text-white py-3 rounded-lg hover:bg-indigo-700 font-semibold`}
                  >
                    {language === 'de' ? 'SchlieÃŸen' : language === 'fr' ? 'Fermer' : 'Close'}
                  </button>
                </div>
              </div>
            </div>
          )}

          {/* Black Navigation Bar - Simplified */}
          <nav className="bg-black text-white px-3 py-3">
            <div className="flex justify-between items-center">
              {/* Left: Title - Always visible */}
              <div className="flex-shrink-0">
                <h1 className="text-sm md:text-base font-bold whitespace-nowrap">âœ¨ {t.title}</h1>
              </div>

              {/* Center: Step Navigation - Always visible */}
              {step > 0 && (
                <div className="flex items-center gap-0.5 md:gap-1 flex-1 justify-center">
                  {[1, 2, 3, 4, 5].map(s => {
                    // Determine if this step is accessible
                    let canAccess = false;
                    if (s === 1) {
                      canAccess = true; // Can always go to step 1
                    } else if (s === 2) {
                      canAccess = storyType !== ''; // Can go to step 2 if story type selected
                    } else if (s === 3) {
                      canAccess = storyType !== '' && characters.length > 0; // Need story type AND characters
                    } else if (s === 4) {
                      canAccess = storyType !== '' && characters.length > 0 && areAllRelationshipsDefined(); // Need all previous data
                    } else if (s === 5) {
                      canAccess = generatedStory !== ''; // Can go to step 5 if story exists
                    }

                    return (
                      <React.Fragment key={s}>
                        <button
                          onClick={() => {
                            if (canAccess) {
                              safeSetStep(s);
                            }
                          }}
                          disabled={!canAccess}
                          className={`w-5 h-5 md:w-6 md:h-6 rounded-full flex items-center justify-center text-[10px] md:text-xs font-bold transition-all ${
                            canAccess
                              ? step === s
                                ? 'bg-indigo-600 text-white ring-1 ring-indigo-200'
                                : 'bg-indigo-500 text-white hover:bg-indigo-600 cursor-pointer'
                              : 'bg-gray-600 text-gray-400 cursor-not-allowed'
                          } ${canAccess && step !== s ? 'hover:scale-110' : ''}`}
                        >
                          {s}
                        </button>
                        {s < 5 && <div className={`w-3 md:w-6 h-0.5 ${canAccess ? 'bg-indigo-500' : 'bg-gray-600'}`} />}
                      </React.Fragment>
                    );
                  })}
                </div>
              )}

              {/* Quota Display (when no steps) */}
              {step === 0 && isAuthenticated && currentUser && userQuota && !userQuota.unlimited && (
                <div className={`px-3 py-1 rounded text-xs font-semibold ${
                  userQuota.remaining === 0 ? 'bg-red-600 text-white' :
                  userQuota.remaining === 1 ? 'bg-yellow-600 text-white' :
                  'bg-green-600 text-white'
                }`}>
                  {userQuota.remaining} / {userQuota.quota} stories
                </div>
              )}

              {/* Right: Menu Button */}
              <div className="relative">
                <button
                  onClick={() => setShowMenu(!showMenu)}
                  className="bg-gray-800 text-white px-3 py-1.5 rounded text-xs font-semibold hover:bg-gray-700 flex items-center gap-2"
                >
                  <Icon name="menu" size={16} />
                  <span className="hidden md:inline">Menu</span>
                </button>

                {showMenu && (
                  <div className="absolute right-0 mt-2 bg-gray-800 rounded-lg shadow-lg overflow-hidden z-50 min-w-[200px]">
                    {/* User Info Header */}
                    {isAuthenticated && currentUser && (
                      <div className="border-b border-gray-700 px-4 py-3 bg-gray-900">
                        <div className="text-white font-semibold text-sm mb-1">
                          {currentUser.username} {currentUser.role === 'admin' && 'ðŸ‘‘'}
                        </div>
                        {userQuota && !userQuota.unlimited && (
                          <div className={`text-xs px-2 py-1 rounded inline-block ${
                            userQuota.remaining === 0 ? 'bg-red-600 text-white' :
                            userQuota.remaining === 1 ? 'bg-yellow-600 text-white' :
                            'bg-green-600 text-white'
                          }`}>
                            {userQuota.remaining} / {userQuota.quota} {language === 'de' ? 'Geschichten' : language === 'fr' ? 'histoires' : 'stories'}
                          </div>
                        )}
                      </div>
                    )}

                    {/* Language Selection */}
                    <div className="border-b border-gray-700 px-4 py-2">
                      <div className="text-xs text-gray-400 mb-2">
                        {language === 'de' ? 'Sprache' : language === 'fr' ? 'Langue' : 'Language'}
                      </div>
                      <div className="flex gap-2">
                        <button
                          onClick={() => {
                            setLanguage('en');
                            setShowMenu(false);
                          }}
                          className={`flex-1 px-3 py-2 rounded text-xs font-semibold ${language === 'en' ? 'bg-indigo-600 text-white' : 'bg-gray-700 text-white hover:bg-gray-600'}`}
                        >
                          EN
                        </button>
                        <button
                          onClick={() => {
                            setLanguage('de');
                            setShowMenu(false);
                          }}
                          className={`flex-1 px-3 py-2 rounded text-xs font-semibold ${language === 'de' ? 'bg-indigo-600 text-white' : 'bg-gray-700 text-white hover:bg-gray-600'}`}
                        >
                          DE
                        </button>
                        <button
                          onClick={() => {
                            setLanguage('fr');
                            setShowMenu(false);
                          }}
                          className={`flex-1 px-3 py-2 rounded text-xs font-semibold ${language === 'fr' ? 'bg-indigo-600 text-white' : 'bg-gray-700 text-white hover:bg-gray-600'}`}
                        >
                          FR
                        </button>
                      </div>
                    </div>

                    {isAuthenticated && (
                      <>
                        {/* My Stories */}
                        <button
                          onClick={() => {
                            setShowSavedStories(true);
                            setShowMenu(false);
                          }}
                          className="w-full text-left px-4 py-3 hover:bg-gray-700 text-white flex items-center gap-2 border-b border-gray-700"
                        >
                          <Icon name="book-open" size={16} />
                          <span>{language === 'de' ? 'Meine Geschichten' : language === 'fr' ? 'Mes Histoires' : 'My Stories'} ({savedStories.length})</span>
                        </button>

                        {/* Manage Users (Admin only) */}
                        {currentUser && currentUser.role === 'admin' && (
                          <button
                            onClick={() => {
                              setShowAdminPanel(true);
                              setShowMenu(false);
                            }}
                            className="w-full text-left px-4 py-3 hover:bg-gray-700 text-white flex items-center gap-2 border-b border-gray-700"
                          >
                            <Icon name="users" size={16} />
                            <span>{language === 'de' ? 'Benutzer verwalten' : language === 'fr' ? 'GÃ©rer les utilisateurs' : 'Manage Users'}</span>
                          </button>
                        )}

                        {/* Manage Products (Admin only) */}
                        {currentUser && currentUser.role === 'admin' && (
                          <button
                            onClick={() => {
                              setShowProductsPanel(true);
                              setShowMenu(false);
                              fetchPrintProducts();
                            }}
                            className="w-full text-left px-4 py-3 hover:bg-gray-700 text-white flex items-center gap-2 border-b border-gray-700"
                          >
                            <Icon name="package" size={16} />
                            <span>{language === 'de' ? 'Produkte verwalten' : language === 'fr' ? 'GÃ©rer les produits' : 'Manage Products'}</span>
                          </button>
                        )}

                        {/* Failed Orders (Admin only) */}
                        {currentUser && currentUser.role === 'admin' && (
                          <button
                            onClick={() => {
                              setAdminTab('orders');
                              setShowAdminPanel(true);
                              setShowMenu(false);
                              fetchFailedOrders();
                            }}
                            className="w-full text-left px-4 py-3 hover:bg-gray-700 text-white flex items-center gap-2 border-b border-gray-700"
                          >
                            <Icon name="alert-triangle" size={16} />
                            <span>{language === 'de' ? 'Fehlgeschlagene Bestellungen' : language === 'fr' ? 'Commandes Ã©chouÃ©es' : 'Failed Orders'}</span>
                          </button>
                        )}

                        {/* Logout */}
                        <button
                          onClick={() => {
                            handleLogout();
                            setShowMenu(false);
                          }}
                          className="w-full text-left px-4 py-3 hover:bg-gray-700 text-white flex items-center gap-2"
                        >
                          <Icon name="log-out" size={16} />
                          <span>{t.logout}</span>
                        </button>
                      </>
                    )}
                  </div>
                )}
              </div>
            </div>
          </nav>

          {showApiKeyPrompt && (
              <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
                <div className="bg-white rounded-xl p-8 max-w-md w-full">
                  <h2 className="text-2xl font-bold text-gray-800 mb-4">{t.apiKeyRequired}</h2>
                  <p className="text-gray-500 mb-4">{t.apiKeyPrompt}</p>
                  <input
                    type="password"
                    value={tempApiKey}
                    onChange={(e) => setTempApiKey(e.target.value)}
                    placeholder={t.apiKeyPlaceholder}
                    className="w-full px-4 py-3 border-2 border-gray-300 rounded-lg mb-4"
                  />
                  <p className="text-xs text-gray-500 mb-4">{t.apiKeyNote}</p>
                  <div className="flex gap-4">
                    <button
                      onClick={() => setShowApiKeyPrompt(false)}
                      className="flex-1 bg-gray-300 text-gray-800 px-6 py-3 rounded-lg hover:bg-gray-400"
                    >
                      {t.cancel}
                    </button>
                    <button
                      onClick={saveApiKeyToStorage}
                      className="flex-1 bg-indigo-600 text-white px-6 py-3 rounded-lg hover:bg-indigo-700"
                    >
                      {t.saveApiKey}
                    </button>
                  </div>
                </div>
              </div>
            )}

          {step === 0 && renderStep0()}

          {step > 0 && isAuthenticated && (
            <div className="max-w-7xl mx-auto px-3 md:px-8 mt-2 md:mt-8">
              <div className="md:bg-white md:rounded-2xl md:shadow-xl md:p-8">
                {step === 1 && renderStep1()}
                {step === 2 && renderStep2()}
                {step === 3 && renderStep3()}
                {step === 4 && renderStep4()}
                {step === 5 && renderStep5()}

                {/* Navigation buttons - inside the container */}
                {step < 5 && (
                  <div className={`mt-6 pt-6 border-t border-gray-200 ${step === 4 ? "flex justify-start" : "flex justify-between"}`}>
                    <button
                      onClick={() => safeSetStep(Math.max(0, step - 1))}
                      className="bg-transparent text-gray-800 hover:bg-gray-100 px-6 py-3 rounded-lg font-semibold flex items-center gap-2"
                    >
                      <Icon name="arrow-left" size={20} /> {t.back}
                    </button>

                    {step !== 4 && (
                      <button
                        onClick={() => {
                          const nextStep = Math.min(4, step + 1);
                          console.log('ðŸ”µ Next button clicked:', {
                            currentStep: step,
                            nextStep,
                            storyType,
                            isDisabled: (step === 1 && !storyType) || (step === 2 && characters.length === 0) || (step === 3 && !areAllRelationshipsDefined())
                          });
                          safeSetStep(nextStep);
                        }}
                        disabled={
                          (step === 1 && !storyType) ||
                          (step === 2 && characters.length === 0) ||
                          (step === 3 && !areAllRelationshipsDefined())
                        }
                        className={`px-6 py-3 rounded-lg font-semibold flex items-center gap-2 ${
                          (step === 1 && !storyType) ||
                          (step === 2 && characters.length === 0) ||
                          (step === 3 && !areAllRelationshipsDefined())
                            ? 'bg-gray-300 text-gray-500 cursor-not-allowed'
                            : 'bg-indigo-600 text-white hover:bg-indigo-700'
                        }`}
                      >
                        {t.next} <Icon name="arrow-right" size={20} />
                      </button>
                    )}
                  </div>
                )}
              </div>
            </div>
          )}
        </div>
      );
    }

    const root = createRoot(document.getElementById('root'));
    root.render(<StoryCreator />);
  </script>
</body>
</html>