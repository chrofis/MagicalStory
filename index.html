<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Magical Story</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>âœ¨</text></svg>">
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/lucide@latest"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@700&family=Libre+Baskerville:wght@400&display=swap" rel="stylesheet">
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
    }
    .font-title {
      font-family: 'Cinzel', serif;
      font-weight: 700;
    }
    .font-body {
      font-family: 'Libre Baskerville', serif;
      font-weight: 400;
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect } = React;
    const { createRoot } = ReactDOM;

    // Lucide Icons Component Wrapper
    const Icon = ({ name, size = 24, className = "", ...props }) => {
      useEffect(() => {
        if (window.lucide) {
          window.lucide.createIcons();
        }
      }, []);
      return React.createElement('i', {
        'data-lucide': name,
        className,
        style: { width: size, height: size },
        ...props
      });
    };

    const storyTypes = [
      { id: 'christmas', name: { en: 'Christmas Story', de: 'Weihnachtsgeschichte', fr: 'Histoire de NoÃ«l' }, emoji: 'ðŸŽ„' },
      { id: 'newyear', name: { en: 'New Year Story', de: 'Neujahrsgeschichte', fr: 'Histoire du Nouvel An' }, emoji: 'ðŸŽ†' },
      { id: 'pirate', name: { en: 'Pirate Adventure', de: 'Piraten-Abenteuer', fr: 'Aventure de Pirates' }, emoji: 'ðŸ´â€â˜ ï¸' },
      { id: 'cowboy', name: { en: 'Wild West', de: 'Wilder Westen', fr: 'Far West' }, emoji: 'ðŸ¤ ' },
      { id: 'fireman', name: { en: 'Brave Firefighter', de: 'Tapferer Feuerwehrmann', fr: 'Pompier Courageux' }, emoji: 'ðŸš’' },
      { id: 'unicorn', name: { en: 'Magical Unicorn', de: 'Magisches Einhorn', fr: 'Licorne Magique' }, emoji: 'ðŸ¦„' },
      { id: 'ninja', name: { en: 'Secret Ninja', de: 'Geheimer Ninja', fr: 'Ninja Secret' }, emoji: 'ðŸ¥·' },
      { id: 'space', name: { en: 'Space Explorer', de: 'Weltraum-Entdecker', fr: 'Explorateur Spatial' }, emoji: 'ðŸš€' },
      { id: 'dinosaur', name: { en: 'Dinosaur World', de: 'Dinosaurier-Welt', fr: 'Monde des Dinosaures' }, emoji: 'ðŸ¦–' },
      { id: 'princess', name: { en: 'Princess Story', de: 'Prinzessinnen-Geschichte', fr: 'Histoire de Princesse' }, emoji: 'ðŸ‘‘' },
      { id: 'knight', name: { en: 'Knight Adventure', de: 'Ritter-Abenteuer', fr: 'Aventure de Chevalier' }, emoji: 'âš”ï¸' },
      { id: 'detective', name: { en: 'Detective Mystery', de: 'Detektiv-Geheimnis', fr: 'MystÃ¨re de DÃ©tective' }, emoji: 'ðŸ”' }
    ];

    const artStyles = [
      {
        id: 'pixar',
        name: { en: 'Pixar 3D', de: 'Pixar 3D', fr: 'Pixar 3D' },
        emoji: 'ðŸŽ¬',
        image: 'images/Pixar style.png',
        description: {
          en: 'Vibrant, warm Disney/Pixar style 3D animation',
          de: 'Lebendige, warme Disney/Pixar 3D-Animation',
          fr: 'Animation 3D Disney/Pixar vibrante et chaleureuse'
        },
        prompt: 'pixar style 3d character, vibrant Disney/Pixar 3D animation, warm lighting, child-friendly'
      },
      {
        id: 'cartoon',
        name: { en: 'Cartoon', de: 'Cartoon', fr: 'Dessin animÃ©' },
        emoji: 'ðŸŽ¨',
        image: 'images/cartoon style.jpg',
        description: {
          en: 'Classic 2D cartoon style with bold colors',
          de: 'Klassischer 2D-Cartoon-Stil mit krÃ¤ftigen Farben',
          fr: 'Style cartoon 2D classique aux couleurs vives'
        },
        prompt: '2D cartoon style, bold outlines, vibrant flat colors, classic animation look'
      },
      {
        id: 'anime',
        name: { en: 'Anime', de: 'Anime', fr: 'Anime' },
        emoji: 'â­',
        image: 'images/anime style.jpg',
        description: {
          en: 'Japanese anime style with expressive features',
          de: 'Japanischer Anime-Stil mit ausdrucksstarken Features',
          fr: 'Style anime japonais aux traits expressifs'
        },
        prompt: 'anime style, Japanese animation, expressive eyes, dynamic poses, cel-shaded'
      },
      {
        id: 'chibi',
        name: { en: 'Chibi', de: 'Chibi', fr: 'Chibi' },
        emoji: 'ðŸŒ¸',
        image: 'images/chibi style.jpg',
        description: {
          en: 'Cute chibi style with big heads and small bodies',
          de: 'Niedlicher Chibi-Stil mit groÃŸen KÃ¶pfen und kleinen KÃ¶rpern',
          fr: 'Style chibi mignon avec grandes tÃªtes et petits corps'
        },
        prompt: 'chibi style, super deformed, cute, big head, small body, kawaii, adorable'
      },
      {
        id: 'steampunk',
        name: { en: 'Steampunk', de: 'Steampunk', fr: 'Steampunk' },
        emoji: 'âš™ï¸',
        image: 'images/steampunk.jpg',
        description: {
          en: 'Victorian-era inspired with gears and brass',
          de: 'Von der viktorianischen Ã„ra inspiriert mit ZahnrÃ¤dern und Messing',
          fr: 'InspirÃ© de l\'Ã¨re victorienne avec engrenages et laiton'
        },
        prompt: 'steampunk style, Victorian era, gears, brass, copper, goggles, mechanical details, vintage technology'
      },
      {
        id: 'comic',
        name: { en: 'Comic Book', de: 'Comic', fr: 'Bande dessinÃ©e' },
        emoji: 'ðŸ’¥',
        image: 'images/comic book style.jpg',
        description: {
          en: 'Comic book style with bold lines and halftone',
          de: 'Comic-Stil mit krÃ¤ftigen Linien und Raster',
          fr: 'Style bande dessinÃ©e avec lignes Ã©paisses et trames'
        },
        prompt: 'comic book style, bold ink lines, halftone dots, dynamic action, speech bubbles aesthetic, superhero comic art'
      },
      {
        id: 'manga',
        name: { en: 'Manga', de: 'Manga', fr: 'Manga' },
        emoji: 'ðŸ“š',
        image: 'images/manga style.jpg',
        description: {
          en: 'Japanese manga style, black and white with screentones',
          de: 'Japanischer Manga-Stil, schwarz-weiÃŸ mit Rastern',
          fr: 'Style manga japonais, noir et blanc avec trames'
        },
        prompt: 'manga style, Japanese comic art, detailed linework, screentones, dramatic shading, expressive characters'
      }
    ];

    const defaultStrengths = {
      en: ['Brave', 'Smart', 'Kind', 'Strong', 'Fast', 'Creative', 'Funny', 'Leader', 'Helpful', 'Patient', 'Honest', 'Loyal', 'Curious', 'Determined', 'Caring', 'Confident', 'Cheerful', 'Generous', 'Clever', 'Adventurous', 'Resourceful', 'Protective', 'Imaginative', 'Hardworking', 'Trustworthy'],
      de: ['Mutig', 'Klug', 'Freundlich', 'Stark', 'Schnell', 'Kreativ', 'Lustig', 'FÃ¼hrungspersÃ¶nlichkeit', 'Hilfsbereit', 'Geduldig', 'Ehrlich', 'Treu', 'Neugierig', 'Entschlossen', 'FÃ¼rsorglich', 'Selbstbewusst', 'FrÃ¶hlich', 'GroÃŸzÃ¼gig', 'Schlau', 'Abenteuerlustig', 'Einfallsreich', 'BeschÃ¼tzend', 'Fantasievoll', 'FleiÃŸig', 'VertrauenswÃ¼rdig'],
      fr: ['Courageux', 'Intelligent', 'Gentil', 'Fort', 'Rapide', 'CrÃ©atif', 'DrÃ´le', 'Leader', 'Serviable', 'Patient', 'HonnÃªte', 'Loyal', 'Curieux', 'DÃ©terminÃ©', 'AttentionnÃ©', 'Confiant', 'Joyeux', 'GÃ©nÃ©reux', 'Astucieux', 'Aventureux', 'DÃ©brouillard', 'Protecteur', 'Imaginatif', 'Travailleur', 'Digne de confiance']
    };

    const defaultWeaknesses = {
      en: ['Shy', 'Clumsy', 'Impatient', 'Forgetful', 'Messy', 'Talkative', 'Stubborn', 'Lazy', 'Greedy', 'Jealous', 'Anxious', 'Distracted', 'Reckless', 'Bossy', 'Easily scared', 'Too trusting', 'Perfectionist', 'Indecisive', 'Secretive', 'Boastful', 'Quick-tempered', 'Careless', 'Overly cautious', 'Selfish'],
      de: ['SchÃ¼chtern', 'Tollpatschig', 'Ungeduldig', 'Vergesslich', 'Unordentlich', 'GesprÃ¤chig', 'Stur', 'Faul', 'Gierig', 'EifersÃ¼chtig', 'Ã„ngstlich', 'Abgelenkt', 'Leichtsinnig', 'HerrschsÃ¼chtig', 'Leicht Ã¤ngstlich', 'Zu vertrauensvoll', 'Perfektionist', 'Unentschlossen', 'Verschlossen', 'Prahlerisch', 'JÃ¤hzornig', 'NachlÃ¤ssig', 'Ãœbervorsichtig', 'Egoistisch'],
      fr: ['Timide', 'Maladroit', 'Impatient', 'Distrait', 'DÃ©sordonnÃ©', 'Bavard', 'TÃªtu', 'Paresseux', 'Avide', 'Jaloux', 'Anxieux', 'Distrait', 'Imprudent', 'Autoritaire', 'Facilement effrayÃ©', 'Trop confiant', 'Perfectionniste', 'IndÃ©cis', 'Secret', 'Vantard', 'ColÃ©rique', 'NÃ©gligent', 'Trop prudent', 'Ã‰goÃ¯ste']
    };

    const fearOptions = {
      en: ['Fear of heights', 'Fear of spiders', 'Fear of the dark', 'Fear of being alone', 'Fear of loud noises'],
      de: ['HÃ¶henangst', 'Angst vor Spinnen', 'Angst vor der Dunkelheit', 'Angst allein zu sein', 'Angst vor lauten GerÃ¤uschen'],
      fr: ['Peur du vide', 'Peur des araignÃ©es', 'Peur du noir', 'Peur d\'Ãªtre seul', 'Peur des bruits forts']
    };

    const relationshipTypes = [
      { value: { en: 'Best Friends with', de: 'Beste Freunde mit', fr: 'Meilleurs amis avec' }, inverse: { en: 'Best Friends with', de: 'Beste Freunde mit', fr: 'Meilleurs amis avec' } },
      { value: { en: 'Friends with', de: 'Freunde mit', fr: 'Amis avec' }, inverse: { en: 'Friends with', de: 'Freunde mit', fr: 'Amis avec' } },
      { value: { en: 'Married to', de: 'Verheiratet mit', fr: 'MariÃ©(e) Ã ' }, inverse: { en: 'Married to', de: 'Verheiratet mit', fr: 'MariÃ©(e) Ã ' } },
      { value: { en: 'In a relationship with', de: 'In einer Beziehung mit', fr: 'En relation avec' }, inverse: { en: 'In a relationship with', de: 'In einer Beziehung mit', fr: 'En relation avec' } },
      { value: { en: 'Older Sibling of', de: 'Ã„lteres Geschwister von', fr: 'FrÃ¨re/SÅ“ur aÃ®nÃ©(e) de' }, inverse: { en: 'Younger Sibling of', de: 'JÃ¼ngeres Geschwister von', fr: 'FrÃ¨re/SÅ“ur cadet(te) de' } },
      { value: { en: 'Younger Sibling of', de: 'JÃ¼ngeres Geschwister von', fr: 'FrÃ¨re/SÅ“ur cadet(te) de' }, inverse: { en: 'Older Sibling of', de: 'Ã„lteres Geschwister von', fr: 'FrÃ¨re/SÅ“ur aÃ®nÃ©(e) de' } },
      { value: { en: 'Parent of', de: 'Elternteil von', fr: 'Parent de' }, inverse: { en: 'Child of', de: 'Kind von', fr: 'Enfant de' } },
      { value: { en: 'Child of', de: 'Kind von', fr: 'Enfant de' }, inverse: { en: 'Parent of', de: 'Elternteil von', fr: 'Parent de' } },
      { value: { en: 'Rivals with', de: 'Rivalen mit', fr: 'Rivaux avec' }, inverse: { en: 'Rivals with', de: 'Rivalen mit', fr: 'Rivaux avec' } },
      { value: { en: 'Neighbors with', de: 'Nachbarn mit', fr: 'Voisins avec' }, inverse: { en: 'Neighbors with', de: 'Nachbarn mit', fr: 'Voisins avec' } },
      { value: { en: 'Not Known to', de: 'Nicht bekannt mit', fr: 'Pas connu de' }, inverse: { en: 'Not Known to', de: 'Nicht bekannt mit', fr: 'Pas connu de' } }
    ];

    const translations = {
      en: {
        title: 'Magical Story',
        subtitle: 'Personalize your story to create magic',
        heroTitle: 'Become the hero of your story',
        heroSubtitle: '',
        heroDescription: 'Turn your wildest ideas into a breathtaking personalized tale.',
        bookText: 'Get a beautifully printed book and make someone feel like the legend they truly are.',
        startJourney: 'Start Your Adventure',
        selectLanguage: 'Choose your language',
        login: 'Login',
        register: 'Register',
        logout: 'Logout',
        username: 'Username',
        password: 'Password',
        email: 'Email (optional)',
        welcomeBack: 'Welcome Back!',
        createAccount: 'Create Account',
        noAccount: 'Don\'t have an account?',
        haveAccount: 'Already have an account?',
        signUp: 'Sign up',
        signIn: 'Sign in',
        loginRequired: 'Please login to continue',
        chooseStoryType: 'Choose Your Story Type',
        chooseArtStyle: 'Choose Your Art Style',
        artStyleDescription: 'Select the visual style for your story',
        addCustomStoryType: 'Add Custom Story Type',
        storyTypeName: 'Story Type Name',
        storyTypeEmoji: 'Emoji',
        addStoryType: 'Add',
        createCharacters: 'Create Your Characters',
        characterCreated: 'Character Created!',
        createAnother: 'Create Another Character',
        continueToRelationships: 'Continue to Relationships',
        yourCharacters: 'Your Characters:',
        startCreating: 'Start Creating Character',
        characterName: 'Character Name',
        characterPhoto: 'Character Photo (Optional)',
        uploadPhoto: 'Upload Photo',
        orDescribe: 'OR describe the character',
        characterAge: 'Age',
        hairColor: 'Hair Color',
        otherFeatures: 'Other Features',
        descriptionPlaceholder: 'e.g., Blue eyes, wears glasses, has freckles',
        gender: 'Gender',
        male: 'Male',
        female: 'Female',
        other: 'Unknown',
        age: 'Age',
        strengths: 'Strengths',
        weaknesses: 'Weaknesses',
        selectAtLeast: 'Select at least',
        selected: 'Selected',
        addCustomStrengths: 'Add custom strengths',
        addCustomWeaknesses: 'Add custom weaknesses',
        addCustomFears: 'Add custom fears',
        specialDetails: 'Hobbies, Hopes & Fears, Favourite Animals and Other Details',
        specialDetailsPlaceholder: 'e.g., Enjoys painting, dreams of becoming an astronaut, scared of spiders, loves horses',
        fears: 'Fears',
        addCustomRelationship: 'Add custom relationship',
        cancel: 'Cancel',
        saveCharacter: 'Save Character',
        editCharacter: 'Edit',
        deleteCharacter: 'Delete',
        defineRelationships: 'Define Character Relationships',
        defineRelationshipsDesc: 'Define how each character relates to the others.',
        is: 'is',
        reverseRelationship: 'Reverse relationship:',
        storySettings: 'Story Settings',
        selectMainCharacters: 'Select Main Characters (max 2)',
        numberOfPages: 'Number of Pages',
        readingLevel: 'Reading Level',
        firstGrade: '1st Grade',
        firstGradeDesc: 'Simple words and short sentences',
        standard: 'Standard',
        standardDesc: 'Age-appropriate vocabulary',
        advanced: 'Advanced',
        advancedDesc: 'Complex words and sentences',
        generateStory: 'Generate Story!',
        creating: 'Creating Your Story...',
        storyReady: 'Your Story is Ready!',
        downloadTXT: 'Download as TXT',
        downloadPDF: 'Download as PDF',
        downloadPrompt: 'Download Prompt',
        viewPrompt: 'View Prompt',
        hidePrompt: 'Hide Prompt',
        promptUsed: 'Prompt Used to Generate Story:',
        createAnotherStory: 'Create Another Story',
        back: 'Back',
        next: 'Next',
        exportConfig: 'Export Configuration',
        exportStoryInfo: 'Export Story Info (MD)',
        importConfig: 'Import Configuration',
        charactersCreated: "You've created {count} character{s} so far.",
        mainCharacter: 'Main Character',
        apiKeyRequired: 'API Key Required',
        apiKeyPrompt: 'Please enter your Anthropic API key to generate stories:',
        apiKeyPlaceholder: 'sk-ant-...',
        saveApiKey: 'Save API Key',
        apiKeyNote: 'Your API key is stored locally in your browser and never sent anywhere except to Anthropic.',
        promptPreview: 'Prompt Preview',
        showPromptPreview: 'Show Prompt',
        hidePromptPreview: 'Hide Prompt',
        editPrompt: 'Edit Prompt',
        resetPrompt: 'Reset to Default',
        storyDetails: 'Additional Story Details (Optional)',
        storyDetailsPlaceholder: 'e.g., Location: Enchanted forest, Special elements: Magical talking animals, Time period: Medieval times...',
        generateOutline: 'Generate Outline',
        generatingOutline: 'Generating Outline...',
        outlineReady: 'Story Outline',
        editOutline: 'You can edit the outline below before generating the full story:',
        regenerateOutline: 'Regenerate Outline',
        createScenes: 'Create Scene Descriptions',
        creatingScenes: 'Creating Scene Descriptions...',
        scenesReady: 'Scene Descriptions',
        downloadScenes: 'Download Scenes',
        sceneForPage: 'Scene for Page',
        yourStory: 'Your Story',
        uploadStory: 'Upload Story',
        uploadStoryDesc: 'Upload an existing story text file to generate scene descriptions',
        generateImages: 'Generate Scene Images',
        generatingImages: 'Generating Images...',
        imagesReady: 'Scene Images',
        downloadImage: 'Download Image',
        geminiApiKey: 'Gemini API Key',
        geminiApiKeyPrompt: 'Enter your Google Gemini API key to generate images:',
        geminiApiKeyNote: 'Get your key from Google AI Studio',
        imageForPage: 'Image for Page',
        generateAvatar: 'Generate Pixar Avatar',
        generatingAvatar: 'Generating Avatar...',
        avatarGenerated: 'Avatar Generated!',
        useGeneratedAvatar: 'Use Generated Avatar',
        keepOriginal: 'Keep Original Photo',
        uploadType: 'What are you uploading?',
        uploadRealPhoto: 'Real Photo (will generate avatar)',
        uploadReadyAvatar: 'Ready Avatar (already stylized)',
        editStory: 'Edit Story',
        saveStory: 'Save Story',
        editScene: 'Edit Scene',
        saveScene: 'Save Scene',
        editImage: 'Edit Image',
        regenerateImage: 'Regenerate Image',
        showPrompt: 'Show Prompt',
        hidePrompt: 'Hide Prompt',
        editInstruction: 'What should be changed?',
        applyEdit: 'Apply Edit'
      },
      de: {
        title: 'Magical Story',
        subtitle: 'Personalisiere deine Geschichte fÃ¼r Magie',
        heroTitle: 'Werde zum Helden deiner Geschichte',
        heroSubtitle: '',
        heroDescription: 'Verwandle deine wildesten Ideen in eine atemberaubende personalisierte Geschichte.',
        bookText: 'Erhalte ein wunderschÃ¶n gedrucktes Buch und gib jemandem das GefÃ¼hl, die Legende zu sein, die er wirklich ist.',
        startJourney: 'Starte dein Abenteuer',
        selectLanguage: 'WÃ¤hle deine Sprache',
        login: 'Anmelden',
        register: 'Registrieren',
        logout: 'Abmelden',
        username: 'Benutzername',
        password: 'Passwort',
        email: 'E-Mail (optional)',
        welcomeBack: 'Willkommen zurÃ¼ck!',
        createAccount: 'Konto erstellen',
        noAccount: 'Noch kein Konto?',
        haveAccount: 'Bereits ein Konto?',
        signUp: 'Registrieren',
        signIn: 'Anmelden',
        loginRequired: 'Bitte melde dich an, um fortzufahren',
        chooseStoryType: 'WÃ¤hle deinen Geschichtentyp',
        chooseArtStyle: 'WÃ¤hle deinen Kunststil',
        artStyleDescription: 'WÃ¤hle den visuellen Stil fÃ¼r deine Geschichte',
        addCustomStoryType: 'Eigenen Geschichtentyp hinzufÃ¼gen',
        storyTypeName: 'Name des Geschichtentyps',
        storyTypeEmoji: 'Emoji',
        addStoryType: 'HinzufÃ¼gen',
        createCharacters: 'Erstelle deine Charaktere',
        characterCreated: 'Charakter erstellt!',
        createAnother: 'Weiteren Charakter erstellen',
        continueToRelationships: 'Weiter zu Beziehungen',
        yourCharacters: 'Deine Charaktere:',
        startCreating: 'Charakter erstellen beginnen',
        characterName: 'Charaktername',
        characterPhoto: 'Charakterfoto (Optional)',
        uploadPhoto: 'Foto hochladen',
        orDescribe: 'ODER Figur beschreiben',
        characterAge: 'Alter',
        hairColor: 'Haarfarbe',
        otherFeatures: 'Sonstige Merkmale',
        descriptionPlaceholder: 'z.B. Blaue Augen, trÃ¤gt Brille, hat Sommersprossen',
        gender: 'Geschlecht',
        male: 'MÃ¤nnlich',
        female: 'Weiblich',
        other: 'Unbekannt',
        age: 'Alter',
        strengths: 'StÃ¤rken',
        weaknesses: 'SchwÃ¤chen',
        selectAtLeast: 'WÃ¤hle mindestens',
        selected: 'AusgewÃ¤hlt',
        addCustomStrengths: 'Eigene StÃ¤rken hinzufÃ¼gen',
        addCustomWeaknesses: 'Eigene SchwÃ¤chen hinzufÃ¼gen',
        addCustomFears: 'Eigene Ã„ngste hinzufÃ¼gen',
        specialDetails: 'Hobbys, Hoffnungen & Ã„ngste, Lieblingstiere und andere Besonderheiten',
        specialDetailsPlaceholder: 'z.B. Malt gerne, trÃ¤umt davon Astronaut zu werden, hat Angst vor Spinnen, liebt Pferde',
        fears: 'Ã„ngste',
        addCustomRelationship: 'Eigene Beziehung hinzufÃ¼gen',
        cancel: 'Abbrechen',
        saveCharacter: 'Charakter speichern',
        editCharacter: 'Bearbeiten',
        deleteCharacter: 'LÃ¶schen',
        defineRelationships: 'Charakterbeziehungen definieren',
        defineRelationshipsDesc: 'Definiere, wie die Charaktere zueinander stehen.',
        is: 'ist',
        reverseRelationship: 'Umgekehrte Beziehung:',
        storySettings: 'Geschichten-Einstellungen',
        selectMainCharacters: 'Hauptfiguren auswÃ¤hlen (max 2)',
        numberOfPages: 'Anzahl der Seiten',
        readingLevel: 'Lesestufe',
        firstGrade: '1. Klasse',
        firstGradeDesc: 'Einfache WÃ¶rter und kurze SÃ¤tze',
        standard: 'Standard',
        standardDesc: 'Altersgerechter Wortschatz',
        advanced: 'Fortgeschritten',
        advancedDesc: 'Komplexe WÃ¶rter und SÃ¤tze',
        generateStory: 'Geschichte erstellen!',
        creating: 'Erstelle deine Geschichte...',
        storyReady: 'Deine Geschichte ist fertig!',
        downloadTXT: 'Als TXT herunterladen',
        downloadPDF: 'Als PDF herunterladen',
        downloadPrompt: 'Prompt herunterladen',
        viewPrompt: 'Prompt anzeigen',
        hidePrompt: 'Prompt ausblenden',
        promptUsed: 'Verwendeter Prompt:',
        createAnotherStory: 'Neue Geschichte erstellen',
        back: 'ZurÃ¼ck',
        next: 'Weiter',
        exportConfig: 'Konfiguration exportieren',
        exportStoryInfo: 'Story-Info exportieren (MD)',
        importConfig: 'Konfiguration importieren',
        charactersCreated: 'Du hast bisher {count} Charakter{s} erstellt.',
        mainCharacter: 'Hauptfigur',
        apiKeyRequired: 'API-SchlÃ¼ssel erforderlich',
        apiKeyPrompt: 'Bitte geben Sie Ihren Anthropic API-SchlÃ¼ssel ein:',
        apiKeyPlaceholder: 'sk-ant-...',
        saveApiKey: 'API-SchlÃ¼ssel speichern',
        apiKeyNote: 'Ihr API-SchlÃ¼ssel wird lokal im Browser gespeichert.',
        promptPreview: 'Prompt-Vorschau',
        showPromptPreview: 'Prompt anzeigen',
        hidePromptPreview: 'Prompt ausblenden',
        editPrompt: 'Prompt bearbeiten',
        resetPrompt: 'Auf Standard zurÃ¼cksetzen',
        storyDetails: 'ZusÃ¤tzliche Story-Details (Optional)',
        storyDetailsPlaceholder: 'z.B. Ort: Verzauberter Wald, Besondere Elemente: Magische sprechende Tiere, Zeitperiode: Mittelalter...',
        generateOutline: 'Gliederung erstellen',
        generatingOutline: 'Gliederung wird erstellt...',
        outlineReady: 'Story-Gliederung',
        editOutline: 'Sie kÃ¶nnen die Gliederung unten bearbeiten, bevor Sie die vollstÃ¤ndige Geschichte erstellen:',
        regenerateOutline: 'Gliederung neu erstellen',
        createScenes: 'Szenen-Beschreibungen erstellen',
        creatingScenes: 'Szenen-Beschreibungen werden erstellt...',
        scenesReady: 'Szenen-Beschreibungen',
        downloadScenes: 'Szenen herunterladen',
        sceneForPage: 'Szene fÃ¼r Seite',
        yourStory: 'Deine Geschichte',
        uploadStory: 'Geschichte hochladen',
        uploadStoryDesc: 'Laden Sie eine vorhandene Story-Textdatei hoch, um Szenenbeschreibungen zu generieren',
        generateImages: 'Szenenbilder generieren',
        generatingImages: 'Bilder werden generiert...',
        imagesReady: 'Szenenbilder',
        downloadImage: 'Bild herunterladen',
        geminiApiKey: 'Gemini API-SchlÃ¼ssel',
        geminiApiKeyPrompt: 'Geben Sie Ihren Google Gemini API-SchlÃ¼ssel ein:',
        geminiApiKeyNote: 'Holen Sie sich Ihren SchlÃ¼ssel von Google AI Studio',
        imageForPage: 'Bild fÃ¼r Seite',
        generateAvatar: 'Pixar-Avatar erstellen',
        generatingAvatar: 'Avatar wird erstellt...',
        avatarGenerated: 'Avatar erstellt!',
        useGeneratedAvatar: 'Generierten Avatar verwenden',
        keepOriginal: 'Originalfoto behalten',
        uploadType: 'Was laden Sie hoch?',
        uploadRealPhoto: 'Echtes Foto (Avatar wird generiert)',
        uploadReadyAvatar: 'Fertiger Avatar (bereits stilisiert)',
        editStory: 'Geschichte bearbeiten',
        saveStory: 'Geschichte speichern',
        editScene: 'Szene bearbeiten',
        saveScene: 'Szene speichern',
        editImage: 'Bild bearbeiten',
        regenerateImage: 'Bild neu generieren',
        showPrompt: 'Prompt anzeigen',
        hidePrompt: 'Prompt ausblenden',
        editInstruction: 'Was soll geÃ¤ndert werden?',
        applyEdit: 'Ã„nderung anwenden'
      },
      fr: {
        title: 'Magical Story',
        subtitle: 'Personnalisez votre histoire pour crÃ©er la magie',
        heroTitle: 'Devenez le hÃ©ros de votre histoire',
        heroSubtitle: '',
        heroDescription: 'Transformez vos idÃ©es les plus folles en un conte personnalisÃ© Ã©poustouflant.',
        bookText: 'Obtenez un livre magnifiquement imprimÃ© et donnez Ã  quelqu\'un le sentiment d\'Ãªtre la lÃ©gende qu\'il est vraiment.',
        startJourney: 'Commencez Votre Aventure',
        selectLanguage: 'Choisissez votre langue',
        login: 'Connexion',
        register: 'S\'inscrire',
        logout: 'DÃ©connexion',
        username: 'Nom d\'utilisateur',
        password: 'Mot de passe',
        email: 'Email (facultatif)',
        welcomeBack: 'Bon retour !',
        createAccount: 'CrÃ©er un compte',
        noAccount: 'Pas encore de compte ?',
        haveAccount: 'Vous avez dÃ©jÃ  un compte ?',
        signUp: 'S\'inscrire',
        signIn: 'Se connecter',
        loginRequired: 'Veuillez vous connecter pour continuer',
        chooseStoryType: 'Choisissez votre type d\'histoire',
        chooseArtStyle: 'Choisissez votre style artistique',
        artStyleDescription: 'SÃ©lectionnez le style visuel pour votre histoire',
        addCustomStoryType: 'Ajouter un type d\'histoire personnalisÃ©',
        storyTypeName: 'Nom du type d\'histoire',
        storyTypeEmoji: 'Emoji',
        addStoryType: 'Ajouter',
        createCharacters: 'CrÃ©ez vos personnages',
        characterCreated: 'Personnage crÃ©Ã©!',
        createAnother: 'CrÃ©er un autre personnage',
        continueToRelationships: 'Continuer vers les relations',
        yourCharacters: 'Vos personnages:',
        startCreating: 'Commencer Ã  crÃ©er un personnage',
        characterName: 'Nom du personnage',
        characterPhoto: 'Photo du personnage (Optionnel)',
        uploadPhoto: 'TÃ©lÃ©charger une photo',
        orDescribe: 'OU dÃ©crire le personnage',
        characterAge: 'Ã‚ge',
        hairColor: 'Couleur des cheveux',
        otherFeatures: 'Autres caractÃ©ristiques',
        descriptionPlaceholder: 'par ex. Yeux bleus, porte des lunettes, a des taches de rousseur',
        gender: 'Genre',
        male: 'Masculin',
        female: 'FÃ©minin',
        other: 'Inconnu',
        age: 'Ã‚ge',
        strengths: 'Forces',
        weaknesses: 'Faiblesses',
        selectAtLeast: 'SÃ©lectionnez au moins',
        selected: 'SÃ©lectionnÃ©',
        addCustomStrengths: 'Ajouter des forces personnalisÃ©es',
        addCustomWeaknesses: 'Ajouter des faiblesses personnalisÃ©es',
        addCustomFears: 'Ajouter des peurs personnalisÃ©es',
        specialDetails: 'Hobbies, Espoirs & Peurs, Animaux PrÃ©fÃ©rÃ©s et Autres DÃ©tails',
        specialDetailsPlaceholder: 'par ex. Aime peindre, rÃªve de devenir astronaute, peur des araignÃ©es, aime les chevaux',
        fears: 'Peurs',
        addCustomRelationship: 'Ajouter une relation personnalisÃ©e',
        cancel: 'Annuler',
        saveCharacter: 'Sauvegarder le personnage',
        editCharacter: 'Modifier',
        deleteCharacter: 'Supprimer',
        defineRelationships: 'DÃ©finir les relations entre personnages',
        defineRelationshipsDesc: 'DÃ©finissez comment chaque personnage est liÃ© aux autres.',
        is: 'est',
        reverseRelationship: 'Relation inverse:',
        storySettings: 'ParamÃ¨tres de l\'histoire',
        selectMainCharacters: 'SÃ©lectionner les personnages principaux (max 2)',
        numberOfPages: 'Nombre de pages',
        readingLevel: 'Niveau de lecture',
        firstGrade: '1Ã¨re annÃ©e',
        firstGradeDesc: 'Mots simples et phrases courtes',
        standard: 'Standard',
        standardDesc: 'Vocabulaire adaptÃ© Ã  l\'Ã¢ge',
        advanced: 'AvancÃ©',
        advancedDesc: 'Mots et phrases complexes',
        generateStory: 'GÃ©nÃ©rer l\'histoire!',
        creating: 'CrÃ©ation de votre histoire...',
        storyReady: 'Votre histoire est prÃªte!',
        downloadTXT: 'TÃ©lÃ©charger en TXT',
        downloadPDF: 'TÃ©lÃ©charger en PDF',
        downloadPrompt: 'TÃ©lÃ©charger le prompt',
        viewPrompt: 'Voir le prompt',
        hidePrompt: 'Masquer le prompt',
        promptUsed: 'Prompt utilisÃ© pour gÃ©nÃ©rer l\'histoire:',
        createAnotherStory: 'CrÃ©er une nouvelle histoire',
        back: 'Retour',
        next: 'Suivant',
        exportConfig: 'Exporter la configuration',
        exportStoryInfo: 'Exporter infos histoire (MD)',
        importConfig: 'Importer la configuration',
        charactersCreated: 'Vous avez crÃ©Ã© {count} personnage{s} jusqu\'Ã  prÃ©sent.',
        mainCharacter: 'Personnage principal',
        apiKeyRequired: 'ClÃ© API requise',
        apiKeyPrompt: 'Veuillez entrer votre clÃ© API Anthropic:',
        apiKeyPlaceholder: 'sk-ant-...',
        saveApiKey: 'Sauvegarder la clÃ© API',
        apiKeyNote: 'Votre clÃ© API est stockÃ©e localement dans votre navigateur.',
        promptPreview: 'AperÃ§u du prompt',
        showPromptPreview: 'Afficher le prompt',
        hidePromptPreview: 'Masquer le prompt',
        editPrompt: 'Modifier le prompt',
        resetPrompt: 'RÃ©initialiser',
        storyDetails: 'DÃ©tails supplÃ©mentaires de l\'histoire (Optionnel)',
        storyDetailsPlaceholder: 'ex: Lieu: ForÃªt enchantÃ©e, Ã‰lÃ©ments spÃ©ciaux: Animaux magiques qui parlent, PÃ©riode: Moyen Ã‚ge...',
        generateOutline: 'GÃ©nÃ©rer le plan',
        generatingOutline: 'GÃ©nÃ©ration du plan...',
        outlineReady: 'Plan de l\'histoire',
        editOutline: 'Vous pouvez modifier le plan ci-dessous avant de gÃ©nÃ©rer l\'histoire complÃ¨te:',
        regenerateOutline: 'RÃ©gÃ©nÃ©rer le plan',
        createScenes: 'CrÃ©er les descriptions de scÃ¨nes',
        creatingScenes: 'CrÃ©ation des descriptions de scÃ¨nes...',
        scenesReady: 'Descriptions de scÃ¨nes',
        downloadScenes: 'TÃ©lÃ©charger les scÃ¨nes',
        sceneForPage: 'ScÃ¨ne pour la page',
        yourStory: 'Votre Histoire',
        uploadStory: 'TÃ©lÃ©charger une histoire',
        uploadStoryDesc: 'TÃ©lÃ©chargez un fichier texte d\'histoire existant pour gÃ©nÃ©rer des descriptions de scÃ¨nes',
        generateImages: 'GÃ©nÃ©rer des images de scÃ¨ne',
        generatingImages: 'GÃ©nÃ©ration d\'images...',
        imagesReady: 'Images de scÃ¨ne',
        downloadImage: 'TÃ©lÃ©charger l\'image',
        geminiApiKey: 'ClÃ© API Gemini',
        geminiApiKeyPrompt: 'Entrez votre clÃ© API Google Gemini:',
        geminiApiKeyNote: 'Obtenez votre clÃ© depuis Google AI Studio',
        imageForPage: 'Image pour la page',
        generateAvatar: 'GÃ©nÃ©rer un avatar Pixar',
        generatingAvatar: 'GÃ©nÃ©ration de l\'avatar...',
        avatarGenerated: 'Avatar gÃ©nÃ©rÃ©!',
        useGeneratedAvatar: 'Utiliser l\'avatar gÃ©nÃ©rÃ©',
        keepOriginal: 'Conserver la photo originale',
        uploadType: 'Que tÃ©lÃ©chargez-vous?',
        uploadRealPhoto: 'Photo rÃ©elle (gÃ©nÃ©rera un avatar)',
        uploadReadyAvatar: 'Avatar prÃªt (dÃ©jÃ  stylisÃ©)',
        editStory: 'Modifier l\'histoire',
        saveStory: 'Sauvegarder l\'histoire',
        editScene: 'Modifier la scÃ¨ne',
        saveScene: 'Sauvegarder la scÃ¨ne',
        editImage: 'Modifier l\'image',
        regenerateImage: 'RÃ©gÃ©nÃ©rer l\'image',
        showPrompt: 'Afficher le prompt',
        hidePrompt: 'Masquer le prompt',
        editInstruction: 'Que doit Ãªtre modifiÃ©?',
        applyEdit: 'Appliquer la modification'
      }
    };

    function StoryCreator() {
      // Auto-detect browser language
      const detectBrowserLanguage = () => {
        const browserLang = navigator.language || navigator.userLanguage;
        if (browserLang.startsWith('de')) return 'de';
        if (browserLang.startsWith('fr')) return 'fr';
        return 'en'; // default to English
      };

      const [language, setLanguage] = useState(detectBrowserLanguage());
      const [developerMode, setDeveloperMode] = useState(false); // false = Auto Mode, true = Developer Mode
      // Skip landing page if already logged in
      const [step, setStep] = useState(() => {
        const savedToken = localStorage.getItem('auth_token');
        const savedUser = localStorage.getItem('current_user');
        return (savedToken && savedUser) ? 1 : 0;
      });
      const [storyType, setStoryType] = useState('');
      const [artStyle, setArtStyle] = useState('pixar'); // Art style for images
      const [storyDetails, setStoryDetails] = useState('');

      // Authentication state
      const [isAuthenticated, setIsAuthenticated] = useState(false);
      const [currentUser, setCurrentUser] = useState(null);
      const [authToken, setAuthToken] = useState(null);
      const [userQuota, setUserQuota] = useState(null);
      const [storyQuota, setStoryQuota] = useState(2);
      const [storiesGenerated, setStoriesGenerated] = useState(0);
      const [showAuthModal, setShowAuthModal] = useState(false);
      const [authMode, setAuthMode] = useState('login'); // 'login' or 'register'
      const [authForm, setAuthForm] = useState({ username: '', password: '', email: '' });
      const [authError, setAuthError] = useState('');
      const [characters, setCharacters] = useState([]);
      const [currentCharacter, setCurrentCharacter] = useState(null);
      const [characterBackup, setCharacterBackup] = useState(null); // Backup for cancel/language change
      const [showCharacterCreated, setShowCharacterCreated] = useState(false);
      const [customStrengths, setCustomStrengths] = useState([]);
      const [customWeaknesses, setCustomWeaknesses] = useState([]);
      const [customFears, setCustomFears] = useState([]);
      const [customRelationships, setCustomRelationships] = useState([]);
      const [newStrength, setNewStrength] = useState('');
      const [newWeakness, setNewWeakness] = useState('');
      const [newFear, setNewFear] = useState('');
      const [newRelationship, setNewRelationship] = useState('');
      const [relationships, setRelationships] = useState({});
      const [pages, setPages] = useState(5); // Default to 5 pages
      const [languageLevel, setLanguageLevel] = useState('standard');
      const [mainCharacters, setMainCharacters] = useState([]);
      const [generatedStory, setGeneratedStory] = useState('');
      const [isGenerating, setIsGenerating] = useState(false);
      const [savedStories, setSavedStories] = useState([]);
      const [showSavedStories, setShowSavedStories] = useState(false);
      const [loadingProgress, setLoadingProgress] = useState(0);
      const [loadingBytes, setLoadingBytes] = useState(0);
      const [loadingTotalBytes, setLoadingTotalBytes] = useState(0);
      const [showLoadingProgress, setShowLoadingProgress] = useState(false);
      const [showAdminPanel, setShowAdminPanel] = useState(false);
      const [showProductsPanel, setShowProductsPanel] = useState(false);
      const [adminUsers, setAdminUsers] = useState([]);
      const [orphanedData, setOrphanedData] = useState(null);
      const [isCheckingOrphaned, setIsCheckingOrphaned] = useState(false);
      const [apiKey, setApiKey] = useState('');
      const [showApiKeyPrompt, setShowApiKeyPrompt] = useState(false);
      const [tempApiKey, setTempApiKey] = useState('');
      const [generatedPrompt, setGeneratedPrompt] = useState('');
      const [showPrompt, setShowPrompt] = useState(false);
      const [customStoryTypes, setCustomStoryTypes] = useState([]);
      const [newStoryTypeName, setNewStoryTypeName] = useState('');
      const [newStoryTypeEmoji, setNewStoryTypeEmoji] = useState('ðŸŽ­');
      const [showLanguageDropdown, setShowLanguageDropdown] = useState(false);
      const [showMenu, setShowMenu] = useState(false);
      const [editablePrompt, setEditablePrompt] = useState('');
      const [showPromptPreview, setShowPromptPreview] = useState(false);
      const [generationProgress, setGenerationProgress] = useState({ current: 0, total: 0, message: '' });
      const [storyOutline, setStoryOutline] = useState('');
      const [editableOutline, setEditableOutline] = useState('');
      const [isGeneratingOutline, setIsGeneratingOutline] = useState(false);
      const [shortSceneDescriptions, setShortSceneDescriptions] = useState({}); // Map of pageNumber -> short description from outline
      const [sceneDescriptions, setSceneDescriptions] = useState([]);
      const [isGeneratingScenes, setIsGeneratingScenes] = useState(false);
      const [sceneImages, setSceneImages] = useState([]);
      const [isGeneratingImages, setIsGeneratingImages] = useState(false);
      const [coverImages, setCoverImages] = useState({
        frontCover: null,  // Also serves as title page
        page0: null,
        backCover: null
      });
      const [storyTitle, setStoryTitle] = useState('');
      const [coverSceneDescriptions, setCoverSceneDescriptions] = useState({
        titlePage: '',
        page0: '',
        backCover: ''
      });
      const [geminiApiKey, setGeminiApiKey] = useState('');
      const [showGeminiApiKeyPrompt, setShowGeminiApiKeyPrompt] = useState(false);
      const [tempGeminiApiKey, setTempGeminiApiKey] = useState('');
      const [generatedAvatar, setGeneratedAvatar] = useState(null);
      const [generatedAvatars, setGeneratedAvatars] = useState([]); // Array of {type, image, traits} for 3 variants
      const [isGeneratingAvatar, setIsGeneratingAvatar] = useState(false);
      const [uploadType, setUploadType] = useState('photo'); // 'photo' or 'avatar'
      const [editingStory, setEditingStory] = useState(false);
      const [editableStory, setEditableStory] = useState('');
      const [editingSceneIndex, setEditingSceneIndex] = useState(null);
      const [editableScene, setEditableScene] = useState('');
      const [imagePrompts, setImagePrompts] = useState({}); // Store prompts used for each image
      const [apiCalls, setApiCalls] = useState({}); // Store full API calls for admin debugging
      const [editingImageIndex, setEditingImageIndex] = useState(null);
      const [imageEditInstruction, setImageEditInstruction] = useState('');
      const [editingCoverImage, setEditingCoverImage] = useState(null); // 'frontCover', 'page0', 'backCover', or null
      const [coverEditInstruction, setCoverEditInstruction] = useState('');
      const [avatarPrompt, setAvatarPrompt] = useState('');
      const [showAvatarPrompt, setShowAvatarPrompt] = useState(false);
      const [analyzedTraitsText, setAnalyzedTraitsText] = useState(''); // Full analyzed description
      const [sceneDescriptionPrompts, setSceneDescriptionPrompts] = useState({}); // Map of pageNumber -> prompt
      const [showSceneDescriptionPrompt, setShowSceneDescriptionPrompt] = useState(false);
      const [relationshipTexts, setRelationshipTexts] = useState({}); // Custom text for each relationship
      const [coverImagePrompts, setCoverImagePrompts] = useState({}); // Store prompts for cover images
      const [coverImageApiCalls, setCoverImageApiCalls] = useState({}); // Store API calls for cover images
      const [storyOutlinePrompt, setStoryOutlinePrompt] = useState(''); // Store outline generation prompt
      const [storyOutlineApiCall, setStoryOutlineApiCall] = useState(null); // Store outline API call
      const [storyTextPrompt, setStoryTextPrompt] = useState(''); // Store story text generation prompt
      const [storyTextApiCall, setStoryTextApiCall] = useState(null); // Store story text API call

      // Character Consistency System
      const [characterManifest, setCharacterManifest] = useState(null); // Character manifest from story generation
      const [characterConsistencyGuide, setCharacterConsistencyGuide] = useState(''); // Text guide for image prompts
      const [baseCharacterImages, setBaseCharacterImages] = useState({}); // Map of character ID -> cartoon base64
      const [isGeneratingCartoons, setIsGeneratingCartoons] = useState(false);
      const [currentStoryId, setCurrentStoryId] = useState(null); // Track current story ID for print orders
      const [showShippingModal, setShowShippingModal] = useState(false);
      const [shippingForm, setShippingForm] = useState({
        firstName: '',
        lastName: '',
        addressLine1: '',
        city: '',
        postCode: '',
        country: '',
        email: ''
      });
      const [emailChanged, setEmailChanged] = useState(false);
      const [adminTab, setAdminTab] = useState('users'); // 'users' or 'products'
      const [gelatoProducts, setGelatoProducts] = useState([]);
      const [showProductForm, setShowProductForm] = useState(false);
      const [editingProduct, setEditingProduct] = useState(null);
      const [productForm, setProductForm] = useState({
        product_uid: '',
        product_name: '',
        description: '',
        size: '',
        cover_type: '',
        min_pages: 24,
        max_pages: 24,
        available_page_counts: '[24]',
        is_active: true
      });
      const [showOrderModal, setShowOrderModal] = useState(false);
      const [orderData, setOrderData] = useState(null); // { orderId, dashboardUrl, pdfUrl, pdfFilename, isDraft, previewUrls }

      const characterFormRef = React.useRef(null);

      useEffect(() => {
        // Check for saved authentication token
        const savedToken = localStorage.getItem('auth_token');
        const savedUser = localStorage.getItem('current_user');

        console.log('ðŸ” Checking saved auth:', {
          hasToken: !!savedToken,
          hasUser: !!savedUser,
          token: savedToken ? savedToken.substring(0, 20) + '...' : 'none'
        });

        if (savedToken && savedUser) {
          const user = JSON.parse(savedUser);
          setAuthToken(savedToken);
          setCurrentUser(user);
          setIsAuthenticated(true);
          console.log('âœ… Auto-login successful - data will be loaded by useEffect');
        } else {
          console.log('âŒ No saved auth found');
        }
        // Don't show auth modal automatically - user needs to click "Start Your Adventure"

        // Keep API key loading for backwards compatibility (will be deprecated)
        const savedApiKey = localStorage.getItem('anthropic_api_key');
        if (savedApiKey) {
          setApiKey(savedApiKey);
        }
        const savedGeminiKey = localStorage.getItem('gemini_api_key');
        if (savedGeminiKey) {
          setGeminiApiKey(savedGeminiKey);
        }
        if (window.lucide) {
          window.lucide.createIcons();
        }
      }, []); // Run only once on mount - don't re-run when step changes!

      // Set up browser error tracking - send errors to server
      useEffect(() => {
        const logErrorToServer = async (errorData) => {
          try {
            await fetch(`${API_URL}/api/log-error`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                ...errorData,
                userId: currentUser?.id || 'anonymous',
                userAgent: navigator.userAgent,
                timestamp: new Date().toISOString()
              })
            });
          } catch (err) {
            // Silently fail if logging fails - don't want to create error loops
            console.warn('Failed to log error to server:', err);
          }
        };

        // Capture global JavaScript errors
        const handleError = (event) => {
          logErrorToServer({
            errorType: 'JavaScript Error',
            message: event.message || 'Unknown error',
            url: event.filename || window.location.href,
            line: event.lineno,
            column: event.colno,
            stack: event.error?.stack || 'No stack trace'
          });
        };

        // Capture unhandled promise rejections
        const handleUnhandledRejection = (event) => {
          logErrorToServer({
            errorType: 'Unhandled Promise Rejection',
            message: event.reason?.message || String(event.reason) || 'Unknown rejection',
            url: window.location.href,
            stack: event.reason?.stack || 'No stack trace'
          });
        };

        // Capture console errors
        const originalConsoleError = console.error;
        console.error = function(...args) {
          // Call original console.error
          originalConsoleError.apply(console, args);

          // Log to server (but skip if it's our own error logging to avoid loops)
          if (!args[0]?.toString().includes('BROWSER ERROR:')) {
            logErrorToServer({
              errorType: 'Console Error',
              message: args.map(arg => String(arg)).join(' '),
              url: window.location.href,
              stack: new Error().stack
            });
          }
        };

        // Attach event listeners
        window.addEventListener('error', handleError);
        window.addEventListener('unhandledrejection', handleUnhandledRejection);

        // Cleanup on unmount
        return () => {
          window.removeEventListener('error', handleError);
          window.removeEventListener('unhandledrejection', handleUnhandledRejection);
          console.error = originalConsoleError;
        };
      }, [currentUser]);

      // Load characters and stories when user logs in
      useEffect(() => {
        if (authToken && isAuthenticated) {
          console.log('ðŸ”„ Loading user data (characters, stories, quota)...');
          loadCharacters();
          loadStories().then(stories => {
            console.log('ðŸ“š Loaded stories:', stories.length);
            setSavedStories(stories);
          }).catch(err => {
            console.error('âŒ Error loading stories:', err);
          });
          fetchUserQuota();
        }
      }, [authToken, isAuthenticated]);

      // Always load stories when user opens the stories modal
      useEffect(() => {
        if (showSavedStories && authToken) {
          console.log('ðŸ“– Refreshing stories when opening modal...');
          loadStories().then(stories => {
            console.log('ðŸ“š Stories refreshed:', stories.length, stories);
            setSavedStories(stories);
          }).catch(err => {
            console.error('âŒ Error refreshing stories:', err);
          });
        }
      }, [showSavedStories]);

      // Load users when admin panel is opened
      useEffect(() => {
        if (showAdminPanel && currentUser && currentUser.role === 'admin') {
          fetchAllUsers();
        }
      }, [showAdminPanel]);

      // Track previous language for translation
      const prevLanguageRef = React.useRef(language);

      // Translate character data when language changes
      useEffect(() => {
        const prevLang = prevLanguageRef.current;

        if (prevLang && prevLang !== language) {
          console.log(`ðŸŒ Language changed from ${prevLang} to ${language}, translating character data...`);

          // Helper to translate relationship value
          const translateRelationship = (relValue) => {
            if (!relValue) return relValue;

            // Find matching relationship type
            for (const relType of relationshipTypes) {
              if (relType.value[prevLang] === relValue) {
                return relType.value[language];
              }
              if (relType.inverse[prevLang] === relValue) {
                return relType.inverse[language];
              }
            }
            // Custom relationship - keep as is
            return relValue;
          };

          // Translate current character being edited
          if (currentCharacter) {
            setCurrentCharacter(prev => ({
              ...prev,
              strengths: translateArray(prev.strengths || [], prevLang, language, defaultStrengths),
              weaknesses: translateArray(prev.weaknesses || [], prevLang, language, defaultWeaknesses),
              fears: translateArray(prev.fears || [], prevLang, language, fearOptions)
            }));
          }

          // Translate character backup if exists
          if (characterBackup) {
            setCharacterBackup(prev => ({
              ...prev,
              strengths: translateArray(prev.strengths || [], prevLang, language, defaultStrengths),
              weaknesses: translateArray(prev.weaknesses || [], prevLang, language, defaultWeaknesses),
              fears: translateArray(prev.fears || [], prevLang, language, fearOptions)
            }));
          }

          // Translate all existing characters
          if (characters.length > 0) {
            setCharacters(prevChars => prevChars.map(char => ({
              ...char,
              strengths: translateArray(char.strengths || [], prevLang, language, defaultStrengths),
              weaknesses: translateArray(char.weaknesses || [], prevLang, language, defaultWeaknesses),
              fears: translateArray(char.fears || [], prevLang, language, fearOptions)
            })));
          }

          // Translate relationships
          if (Object.keys(relationships).length > 0) {
            const translatedRelationships = {};
            for (const [key, value] of Object.entries(relationships)) {
              translatedRelationships[key] = translateRelationship(value);
            }
            setRelationships(translatedRelationships);
          }
        }

        // Update previous language ref
        prevLanguageRef.current = language;
      }, [language]);

      // Initialize character when entering step 2
      useEffect(() => {
        console.log('ðŸ“ Step changed:', {
          step,
          isAuthenticated,
          hasCurrentCharacter: !!currentCharacter,
          existingCharactersCount: characters.length
        });

        if (step === 2) {
          // If there are existing characters and we're navigating TO step 2, clear currentCharacter to show the list
          if (characters.length > 0 && currentCharacter) {
            console.log('ðŸŽ­ Clearing current character to show character list');
            setCurrentCharacter(null);
          }
          // Only auto-create new character if there are NO characters at all
          else if (characters.length === 0 && !currentCharacter) {
            console.log('ðŸŽ­ No characters exist - initializing new character for step 2');
            startNewCharacter();
          }
        }
      }, [step]);

      // Save characters and relationships whenever they change (with debounce)
      useEffect(() => {
        if (authToken && characters.length > 0) {
          const timeoutId = setTimeout(() => {
            saveCharacters(characters);
          }, 1000); // Debounce for 1 second

          return () => clearTimeout(timeoutId);
        }
      }, [characters, relationships, relationshipTexts, customRelationships, customStrengths, customWeaknesses, customFears, authToken]);

      // Update prompt when returning to step 4 with prompt visible
      useEffect(() => {
        if (step === 4 && showPromptPreview && storyType && characters.length > 0) {
          try {
            const newPrompt = buildOutlinePrompt();
            setEditablePrompt(newPrompt);
          } catch (error) {
            console.error('Error building prompt:', error);
          }
        }
      }, [step, showPromptPreview]);

      const t = translations[language];
      const allStrengths = [...defaultStrengths[language], ...customStrengths];
      const allWeaknesses = [...defaultWeaknesses[language], ...customWeaknesses];
      const allFears = [...fearOptions[language], ...customFears];
      const allRelationships = [...relationshipTypes, ...customRelationships.map(rel => ({
        value: { en: rel, de: rel, fr: rel },
        inverse: { en: rel, de: rel, fr: rel }
      }))];

      // Helper function to translate values between languages
      const translateValue = (value, fromLang, toLang, options) => {
        if (!value || !fromLang || !toLang || fromLang === toLang) return value;

        // Try to find the value in the source language array
        const sourceArray = options[fromLang];
        const targetArray = options[toLang];

        if (!sourceArray || !targetArray) return value;

        const index = sourceArray.indexOf(value);
        if (index !== -1 && index < targetArray.length) {
          return targetArray[index];
        }

        // If not found in predefined options, keep original (custom value)
        return value;
      };

      // Helper to translate array of values
      const translateArray = (values, fromLang, toLang, options) => {
        if (!values || !Array.isArray(values)) return [];
        return values.map(val => translateValue(val, fromLang, toLang, options));
      };
      const allStoryTypes = [...storyTypes, ...customStoryTypes];

      const detectGender = (name) => {
        const femaleSuffixes = ['a', 'e', 'ie', 'ine', 'elle'];
        const femaleNames = ['sophia', 'emma', 'olivia', 'ava', 'isabella', 'mia', 'charlotte', 'amelia', 'marie', 'anna', 'lisa', 'julia', 'sarah', 'laura', 'lena'];
        const maleNames = ['liam', 'noah', 'oliver', 'james', 'lucas', 'max', 'leon', 'paul', 'ben', 'tom', 'felix', 'lukas', 'tim', 'jan', 'finn'];

        const lowerName = name.toLowerCase();

        if (femaleNames.some(n => lowerName.includes(n))) return 'female';
        if (maleNames.some(n => lowerName.includes(n))) return 'male';
        if (femaleSuffixes.some(suffix => lowerName.endsWith(suffix))) return 'female';

        return 'other';
      };

      const getInverseRelationship = (relationship) => {
        const rel = relationshipTypes.find(r => r.value[language] === relationship);
        return rel ? rel.inverse[language] : relationship;
      };

      const saveApiKeyToStorage = () => {
        if (tempApiKey.trim()) {
          localStorage.setItem('anthropic_api_key', tempApiKey.trim());
          setApiKey(tempApiKey.trim());
          setShowApiKeyPrompt(false);
          setTempApiKey('');
        }
      };

      const buildPrompt = () => {
        const characterDescriptions = characters.map(char => {
          const isMain = mainCharacters.includes(char.id) ? ' (MAIN CHARACTER)' : '';
          let desc = `${char.name}${isMain} (${char.gender}, ${char.age} years old)`;

          // Only add fields that have values (exclude physical features - only personality traits)
          const details = [];
          if (char.strengths && char.strengths.length > 0) {
            details.push(`${t.strengths}: ${char.strengths.join(', ')}`);
          }
          if (char.weaknesses && char.weaknesses.length > 0) {
            details.push(`${t.weaknesses}: ${char.weaknesses.join(', ')}`);
          }
          if (char.fears && char.fears.length > 0) {
            details.push(`${t.fears}: ${char.fears.join(', ')}`);
          }
          // Do NOT include hairColor, otherFeatures, height, build in story prompt
          if (char.specialDetails) {
            details.push(`${t.specialDetails}: ${char.specialDetails}`);
          }

          if (details.length > 0) {
            desc += `: ${details.join(', ')}`;
          }

          return desc;
        }).join('\n');

        const relationshipDescriptions = Object.entries(relationships)
          .filter(([key, type]) => {
            const [char1Id, _] = key.split('-').map(Number);
            const char1Index = characters.findIndex(c => c.id === char1Id);
            const char2Index = characters.findIndex(c => c.id === parseInt(key.split('-')[1]));
            return type !== 'Not Known to' && char1Index < char2Index;
          })
          .map(([key, type]) => {
            const [char1Id, char2Id] = key.split('-').map(Number);
            const char1 = characters.find(c => c.id === char1Id);
            const char2 = characters.find(c => c.id === char2Id);
            const relationshipText = relationshipTexts[key] || ''; // Get custom text if exists
            const baseRelationship = `${char1?.name} ${t.is} ${type} ${char2?.name}`;
            return relationshipText ? `${baseRelationship}. ${relationshipText}` : baseRelationship;
          }).join('\n');

        const languageInstructions = {
          'en': {
            '1st-grade': 'Use very simple words and short sentences suitable for 1st graders who are just learning to read.',
            'standard': 'Use age-appropriate vocabulary and sentence structure for elementary school children.',
            'advanced': 'Use more complex vocabulary and varied sentence structure for advanced readers.'
          },
          'de': {
            '1st-grade': 'Verwende sehr einfache WÃ¶rter und kurze SÃ¤tze, die fÃ¼r ErstklÃ¤ssler geeignet sind, die gerade lesen lernen.',
            'standard': 'Verwende altersgerechtes Vokabular und Satzstruktur fÃ¼r Grundschulkinder.',
            'advanced': 'Verwende komplexeres Vokabular und abwechslungsreiche Satzstruktur fÃ¼r fortgeschrittene Leser.'
          },
          'fr': {
            '1st-grade': 'Utilisez des mots trÃ¨s simples et des phrases courtes adaptÃ©es aux Ã©lÃ¨ves de 1Ã¨re annÃ©e qui apprennent Ã  lire.',
            'standard': 'Utilisez un vocabulaire et une structure de phrase adaptÃ©s Ã  l\'Ã¢ge pour les enfants de l\'Ã©cole primaire.',
            'advanced': 'Utilisez un vocabulaire plus complexe et une structure de phrase variÃ©e pour les lecteurs avancÃ©s.'
          }
        };

        const storyTypeName = allStoryTypes.find(t => t.id === storyType)?.name[language] || 'adventure';

        let prompt = `Create a ${pages}-page children's story about a ${storyTypeName} in ${language === 'de' ? 'German (always use "ss" instead of "ÃŸ")' : language === 'fr' ? 'French' : 'English'}.\n\n`;

        if (storyDetails) {
          prompt += `Additional Story Requirements:\n${storyDetails}\n\n`;
        }

        prompt += `Characters:\n${characterDescriptions}\n\n`;

        if (relationshipDescriptions && relationshipDescriptions.length > 0) {
          prompt += `Relationships:\n${relationshipDescriptions}\n\n`;
        }

        prompt += `Language Level: ${languageInstructions[language][languageLevel]}\n\n`;
        prompt += `IMPORTANT INSTRUCTIONS:\n`;
        prompt += `- Only use the character names provided above. Do NOT invent any new names.\n`;
        prompt += `- You may create additional characters (like grandfather, shopkeeper, teacher, etc.) but they must remain UNNAMED.\n`;
        prompt += `- Refer to additional characters only by their role or relationship (e.g., "the grandfather", "the shopkeeper", "her teacher") - NEVER give them names like "Grandfather Steve" or "Shopkeeper Paul".\n`;
        prompt += `- Use the characters' ages and traits to inform their personality and behavior, but DO NOT explicitly state their age or characteristics in the story.\n`;
        prompt += `- SHOW the characteristics through actions and dialogue instead of stating them. For example, instead of "Sophie was brave", show Sophie doing something brave. Instead of "Max, who was 8 years old", just use "Max" and let his behavior reflect his age.\n\n`;
        prompt += `Please write an engaging, age-appropriate story that incorporates all the characters, their traits, and relationships. Focus especially on the main character(s). Structure it with clear page breaks (use "--- Page X ---" markers). Make it exciting, positive, and include a meaningful lesson or resolution. Each page should be a distinct scene or moment in the story. Write the complete story without truncation. The story should be written entirely in ${language === 'de' ? 'German (always use "ss" instead of "ÃŸ")' : language === 'fr' ? 'French' : 'English'}.`;

        return prompt;
      };

      // Build the full outline prompt with Role/Context and structured sections
      const buildOutlinePrompt = () => {
        const basePrompt = buildPrompt();

        return `# Role and Context

You are an expert children's book writer with deep understanding of age-appropriate storytelling, narrative structure, and visual storytelling for illustrated books. Your expertise includes:

- Creating engaging, age-appropriate narratives that captivate young readers
- Crafting clear story arcs with proper setup, conflict, and resolution
- Writing vivid scene descriptions that translate beautifully to illustrations
- Balancing text and visual elements for maximum impact
- Understanding pacing and page turns in illustrated books
- Creating memorable characters and meaningful moments

Your task is to create a compelling, well-structured story outline that will guide both the narrative text and visual illustrations.

${basePrompt}

# Part 1: Story Title

Create an engaging, age-appropriate title for this story. The title should:
- Capture the essence of the story
- Be appealing to the target age group
- Be memorable and creative
- Reflect the main theme or adventure

Format:
Title: [Your creative title here]

# Part 2: Story Outline

Create a detailed outline for this ${pages}-page story. Include:
- Brief summary of each page (what happens on that page)
- Key events and character moments
- Story arc and progression (clear beginning, middle, and end)
- How the story builds tension and resolves satisfyingly

For EACH of the ${pages} story pages, provide a SHORT SCENE DESCRIPTION (1-2 sentences) that describes the visual scene - what the characters are doing, where they are, and the setting. This will be used for illustration purposes.

# Part 3: Cover Scene Descriptions

In addition to the ${pages} story pages, provide scene descriptions for these 3 cover elements:

**Title Page Scene**: A captivating cover illustration that features the main characters and sets the tone for the story. This should be visually striking and focus on the protagonist(s) in a way that draws readers in.

**Page 0 Scene**: A dedication/introduction page illustration that creates a warm, inviting entry into the story world. This sets the mood and welcomes readers.

**Back Cover Scene**: A satisfying concluding illustration that provides closure and leaves readers with a positive feeling. This should feel like a natural ending to the visual journey.

# Format Your Response

Title: [Story title]

Page 1: [Summary]
Scene: [Short visual description]

Page 2: [Summary]
Scene: [Short visual description]

...and so on for all ${pages} pages.

Title Page: [Summary of title page concept]
Scene: [Visual description focusing on main characters]

Page 0: [Summary of dedication/intro concept]
Scene: [Visual description for welcoming scene]

Back Cover: [Summary of back cover concept]
Scene: [Visual description for concluding scene]

Be specific and creative. Each scene description should paint a clear picture for the illustrator.`;
      };

      // API URL Configuration
      // Smart detection: use relative URLs when on same domain (faster, no CORS preflight)
      const API_URL = window.location.hostname === 'localhost'
        ? 'http://localhost:3000'  // Local development
        : window.location.hostname.includes('railway.app')
          ? ''  // Same domain (Railway) - use relative URLs (no CORS preflight)
          : 'https://magicalstory-production.up.railway.app';  // Cross-origin (IONOS frontend)

      // Authentication functions
      const handleLogin = async (e) => {
        e?.preventDefault();
        setAuthError('');

        try {
          const response = await fetch(`${API_URL}/api/auth/login`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              username: authForm.username,
              password: authForm.password
            })
          });

          const data = await response.json();

          if (!response.ok) {
            throw new Error(data.error || 'Login failed');
          }

          // Save token and user info
          localStorage.setItem('auth_token', data.token);
          localStorage.setItem('current_user', JSON.stringify(data.user));

          setAuthToken(data.token);
          setCurrentUser(data.user);
          setIsAuthenticated(true);
          setShowAuthModal(false);
          setAuthForm({ username: '', password: '', email: '' });
          setStep(1); // Go to first step after login
        } catch (err) {
          setAuthError(err.message);
        }
      };

      const handleRegister = async (e) => {
        e?.preventDefault();
        setAuthError('');

        try {
          const response = await fetch(`${API_URL}/api/auth/register`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              username: authForm.username,
              password: authForm.password,
              email: authForm.email
            })
          });

          const data = await response.json();

          if (!response.ok) {
            throw new Error(data.error || 'Registration failed');
          }

          // Save token and user info
          localStorage.setItem('auth_token', data.token);
          localStorage.setItem('current_user', JSON.stringify(data.user));

          setAuthToken(data.token);
          setCurrentUser(data.user);
          setIsAuthenticated(true);
          setShowAuthModal(false);
          setAuthForm({ username: '', password: '', email: '' });
          setStep(1); // Go to first step after login
        } catch (err) {
          setAuthError(err.message);
        }
      };

      const handleLogout = () => {
        localStorage.removeItem('auth_token');
        localStorage.removeItem('current_user');
        setAuthToken(null);
        setCurrentUser(null);
        setUserQuota(null);
        setIsAuthenticated(false);
        setShowAuthModal(true);
      };

      const fetchUserQuota = async () => {
        if (!authToken) return;

        try {
          const response = await fetch(`${API_URL}/api/user/quota`, {
            headers: {
              'Authorization': `Bearer ${authToken}`
            }
          });

          if (response.ok) {
            const data = await response.json();
            setUserQuota(data);
          }
        } catch (err) {
          console.error('Error fetching quota:', err);
        }
      };

      const fetchAllUsers = async () => {
        if (!authToken || !currentUser || currentUser.role !== 'admin') {
          setAdminUsers([]);
          return;
        }

        try {
          const response = await fetch(`${API_URL}/api/admin/users`, {
            headers: {
              'Authorization': `Bearer ${authToken}`
            }
          });

          if (response.ok) {
            const users = await response.json();
            setAdminUsers(users || []);
          } else {
            console.error('Failed to fetch users:', response.status);
            setAdminUsers([]);
          }
        } catch (err) {
          console.error('Error fetching users:', err);
          setAdminUsers([]);
        }
      };

      const updateUserQuota = async (userId, newQuota) => {
        if (!authToken || !currentUser || currentUser.role !== 'admin') return;

        try {
          const response = await fetch(`${API_URL}/api/admin/users/${userId}/quota`, {
            method: 'PATCH',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${authToken}`
            },
            body: JSON.stringify({ storyQuota: newQuota })
          });

          if (response.ok) {
            // Refresh user list
            await fetchAllUsers();
            return true;
          }
          return false;
        } catch (err) {
          console.error('Error updating user quota:', err);
          return false;
        }
      };

      // Orphaned Data Management Functions
      const checkOrphanedData = async () => {
        if (!authToken || !currentUser || currentUser.role !== 'admin') return;

        setIsCheckingOrphaned(true);
        try {
          const response = await fetch(`${API_URL}/api/admin/cleanup-orphaned-data`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${authToken}`
            },
            body: JSON.stringify({ action: 'check' })
          });

          if (response.ok) {
            const data = await response.json();
            setOrphanedData(data.found);
          } else {
            console.error('Failed to check orphaned data');
            setOrphanedData(null);
          }
        } catch (err) {
          console.error('Error checking orphaned data:', err);
          setOrphanedData(null);
        } finally {
          setIsCheckingOrphaned(false);
        }
      };

      const deleteOrphanedData = async () => {
        if (!authToken || !currentUser || currentUser.role !== 'admin') return;

        const confirmMsg = language === 'de'
          ? 'MÃ¶chten Sie wirklich alle verwaisten Charaktere und Geschichten lÃ¶schen?'
          : language === 'fr'
          ? 'Voulez-vous vraiment supprimer tous les personnages et histoires orphelins ?'
          : 'Are you sure you want to delete all orphaned characters and stories?';

        if (!confirm(confirmMsg)) return;

        setIsCheckingOrphaned(true);
        try {
          const response = await fetch(`${API_URL}/api/admin/cleanup-orphaned-data`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${authToken}`
            },
            body: JSON.stringify({ action: 'delete' })
          });

          if (response.ok) {
            const data = await response.json();
            alert(language === 'de'
              ? `GelÃ¶scht: ${data.deleted.characters} Charaktere, ${data.deleted.stories} Geschichten`
              : language === 'fr'
              ? `SupprimÃ©: ${data.deleted.characters} personnages, ${data.deleted.stories} histoires`
              : `Deleted: ${data.deleted.characters} characters, ${data.deleted.stories} stories`);
            // Re-check after deletion
            await checkOrphanedData();
          } else {
            alert('Failed to delete orphaned data');
          }
        } catch (err) {
          console.error('Error deleting orphaned data:', err);
          alert('Error deleting orphaned data');
        } finally {
          setIsCheckingOrphaned(false);
        }
      };

      // Gelato Products Management Functions
      const fetchGelatoProducts = async () => {
        if (!authToken || !currentUser || currentUser.role !== 'admin') return;

        try {
          const response = await fetch(`${API_URL}/api/admin/gelato-products`, {
            headers: { 'Authorization': `Bearer ${authToken}` }
          });

          if (response.ok) {
            const data = await response.json();
            setGelatoProducts(data.products || []);
          }
        } catch (err) {
          console.error('Error fetching Gelato products:', err);
        }
      };

      const fetchGelatoApiProducts = async () => {
        if (!authToken || !currentUser || currentUser.role !== 'admin') return;

        const confirmMsg = language === 'de'
          ? 'MÃ¶chten Sie verfÃ¼gbare Produkte von Gelato API abrufen? Dies kann einen Moment dauern.'
          : language === 'fr'
          ? 'Voulez-vous rÃ©cupÃ©rer les produits disponibles depuis l\'API Gelato ? Cela peut prendre un moment.'
          : 'Fetch available products from Gelato API? This may take a moment.';

        if (!confirm(confirmMsg)) return;

        try {
          setGenerationProgress({ current: 0, total: 1, message: 'Fetching products from Gelato...' });

          const response = await fetch(`${API_URL}/api/admin/gelato/fetch-products`, {
            headers: { 'Authorization': `Bearer ${authToken}` }
          });

          setGenerationProgress({ current: 0, total: 0, message: '' });

          if (response.ok) {
            const data = await response.json();

            if (data.products && data.products.length > 0) {
              // Show products in a selection dialog
              const msg = language === 'de'
                ? `${data.count} Fotobuch-Produkte gefunden. MÃ¶chten Sie diese zur Datenbank hinzufÃ¼gen?`
                : language === 'fr'
                ? `${data.count} produits de livre photo trouvÃ©s. Voulez-vous les ajouter Ã  la base de donnÃ©es ?`
                : `Found ${data.count} photobook products. Would you like to add them to the database?`;

              if (confirm(msg)) {
                // Add products to database
                let added = 0;
                for (const product of data.products) {
                  try {
                    const addResponse = await fetch(`${API_URL}/api/admin/gelato-products`, {
                      method: 'POST',
                      headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`
                      },
                      body: JSON.stringify({
                        product_uid: product.productUid,
                        product_name: product.name || product.productUid,
                        description: product.description || 'Imported from Gelato API',
                        size: product.size || '',
                        cover_type: product.coverType || '',
                        min_pages: product.minPages || 24,
                        max_pages: product.maxPages || 24,
                        available_page_counts: JSON.stringify(product.availablePageCounts || [24]),
                        is_active: false // Set inactive by default for review
                      })
                    });

                    if (addResponse.ok) added++;
                  } catch (err) {
                    console.error('Error adding product:', err);
                  }
                }

                await fetchGelatoProducts();
                const successMsg = language === 'de'
                  ? `${added} Produkte erfolgreich hinzugefÃ¼gt!`
                  : language === 'fr'
                  ? `${added} produits ajoutÃ©s avec succÃ¨s !`
                  : `Successfully added ${added} products!`;
                alert(successMsg);
              }
            } else {
              const noProductsMsg = language === 'de'
                ? 'Keine Fotobuch-Produkte gefunden'
                : language === 'fr'
                ? 'Aucun produit de livre photo trouvÃ©'
                : 'No photobook products found';
              alert(noProductsMsg);
            }
          } else {
            const error = await response.json();
            alert(`Error: ${error.error || 'Failed to fetch from Gelato API'}`);
          }
        } catch (err) {
          setGenerationProgress({ current: 0, total: 0, message: '' });
          console.error('Error fetching from Gelato API:', err);
          alert('Error fetching from Gelato API. Please check your API key.');
        }
      };

      const saveGelatoProduct = async () => {
        if (!authToken || !currentUser || currentUser.role !== 'admin') return;

        try {
          const url = editingProduct
            ? `${API_URL}/api/admin/gelato-products/${editingProduct.id}`
            : `${API_URL}/api/admin/gelato-products`;

          const response = await fetch(url, {
            method: editingProduct ? 'PUT' : 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${authToken}`
            },
            body: JSON.stringify(productForm)
          });

          if (response.ok) {
            await fetchGelatoProducts();
            setShowProductForm(false);
            setEditingProduct(null);
            setProductForm({
              product_uid: '',
              product_name: '',
              description: '',
              size: '',
              cover_type: '',
              min_pages: 24,
              max_pages: 24,
              available_page_counts: '[24]',
              is_active: true
            });
            alert('Product saved successfully!');
          } else {
            const error = await response.json();
            alert(`Failed to save product: ${error.error || 'Unknown error'}`);
          }
        } catch (err) {
          console.error('Error saving product:', err);
          alert('Error saving product');
        }
      };

      const deleteGelatoProduct = async (productId) => {
        if (!authToken || !currentUser || currentUser.role !== 'admin') return;
        if (!confirm('Delete this product?')) return;

        try {
          const response = await fetch(`${API_URL}/api/admin/gelato-products/${productId}`, {
            method: 'DELETE',
            headers: { 'Authorization': `Bearer ${authToken}` }
          });

          if (response.ok) {
            await fetchGelatoProducts();
            alert('Product deleted successfully!');
          } else {
            alert('Failed to delete product');
          }
        } catch (err) {
          console.error('Error deleting product:', err);
          alert('Error deleting product');
        }
      };

      const toggleProductActive = async (productId, currentStatus) => {
        if (!authToken || !currentUser || currentUser.role !== 'admin') return;

        try {
          const response = await fetch(`${API_URL}/api/admin/gelato-products/${productId}`, {
            method: 'PUT',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${authToken}`
            },
            body: JSON.stringify({ is_active: !currentStatus })
          });

          if (response.ok) {
            await fetchGelatoProducts();
          }
        } catch (err) {
          console.error('Error toggling product status:', err);
        }
      };

      const makeApiCall = async (prompt, maxTokens = 4096) => {
        if (!authToken) {
          throw new Error('Authentication required');
        }

        const response = await fetch(`${API_URL}/api/claude`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${authToken}`
          },
          body: JSON.stringify({
            prompt: prompt,
            max_tokens: maxTokens
          })
        });

        if (!response.ok) {
          let errorMessage = 'Unknown error';
          const errorText = await response.text();
          console.error('API Error Response:', errorText);

          try {
            const errorData = JSON.parse(errorText);
            // Handle both error formats: {error: "msg"} and {error: {message: "msg"}}
            if (typeof errorData.error === 'string') {
              errorMessage = errorData.error;
            } else {
              errorMessage = errorData.error?.message || errorData.message || 'Unknown error';
            }
          } catch (parseError) {
            if (errorText.includes('524') || errorText.includes('timeout')) {
              errorMessage = 'Request timeout - try reducing the number of pages or characters';
            } else {
              errorMessage = errorText || 'Server error';
            }
          }
          throw new Error(`API Error: ${errorMessage}`);
        }

        const data = await response.json();

        if (!data.content || data.content.length === 0) {
          throw new Error('No content received from API');
        }

        // Log token usage
        if (data.usage) {
          console.log('ðŸ“Š Token Usage:');
          console.log(`  Input tokens:  ${data.usage.input_tokens.toLocaleString()}`);
          console.log(`  Output tokens: ${data.usage.output_tokens.toLocaleString()}`);
          console.log(`  Total tokens:  ${(data.usage.input_tokens + data.usage.output_tokens).toLocaleString()}`);
          console.log(`  Max requested: ${maxTokens.toLocaleString()}`);

          // Warn if output limit was reached
          if (data.stop_reason === 'max_tokens') {
            console.warn('âš ï¸  WARNING: Output was truncated - max_tokens limit reached!');
            console.warn(`  You requested ${maxTokens.toLocaleString()} tokens but the response was cut off.`);
          }
        }

        const text = data.content
          .filter(block => block.type === 'text')
          .map(block => block.text)
          .join('\n');

        if (!text) {
          throw new Error('Response text is empty');
        }

        return text;
      };

      // Character persistence functions
      const saveCharacters = async (charactersToSave) => {
        if (!authToken) return;

        try {
          const response = await fetch(`${API_URL}/api/characters`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${authToken}`
            },
            body: JSON.stringify({
              characters: charactersToSave,
              relationships: relationships,
              relationshipTexts: relationshipTexts,
              customRelationships: customRelationships,
              customStrengths: customStrengths,
              customWeaknesses: customWeaknesses,
              customFears: customFears
            })
          });

          if (!response.ok) {
            console.error('Failed to save characters');
          }
        } catch (err) {
          console.error('Error saving characters:', err);
        }
      };

      // Auto-select main characters based on age
      const autoSelectMainCharacters = (charactersList) => {
        if (charactersList.length === 0) return;

        // Find characters aged 1-10
        const youngCharacters = charactersList.filter(char => {
          const age = parseInt(char.age);
          return age >= 1 && age <= 10;
        });

        if (youngCharacters.length > 0) {
          // Select all characters aged 1-10 as main characters
          const mainCharIds = youngCharacters.map(char => char.id);
          setMainCharacters(mainCharIds);
          console.log(`âœ¨ Auto-selected ${youngCharacters.length} main character(s) aged 1-10`);
        } else {
          // No characters aged 1-10, select the youngest one
          const youngest = charactersList.reduce((min, char) => {
            const age = parseInt(char.age);
            const minAge = parseInt(min.age);
            return age < minAge ? char : min;
          });
          setMainCharacters([youngest.id]);
          console.log(`âœ¨ Auto-selected youngest character as main: ${youngest.name} (age ${youngest.age})`);
        }
      };

      const loadCharacters = async () => {
        if (!authToken) return;

        try {
          const response = await fetch(`${API_URL}/api/characters`, {
            headers: {
              'Authorization': `Bearer ${authToken}`
            }
          });

          if (response.ok) {
            const data = await response.json();
            console.log('ðŸ‘¥ Characters API response:', data);

            // Normalize characters - ensure all fields exist with defaults
            const normalizeCharacter = (char) => ({
              ...char,
              specialDetails: char.specialDetails || '',
              strengths: char.strengths || [],
              weaknesses: char.weaknesses || [],
              fears: char.fears || [],
              photoUrl: char.photoUrl || null
            });

            let loadedCharacters = [];

            // Handle both old format (array) and new format (object with characters and relationships)
            if (Array.isArray(data)) {
              console.log('ðŸ‘¥ Setting characters (array format):', data.length, data);
              loadedCharacters = data.map(normalizeCharacter);
              setCharacters(loadedCharacters);
            } else {
              console.log('ðŸ‘¥ Setting characters (object format):', data.characters?.length, data.characters);
              console.log('ðŸ‘¥ First character details:', data.characters?.[0]);
              loadedCharacters = (data.characters || []).map(normalizeCharacter);
              setCharacters(loadedCharacters);
              if (data.relationships) {
                setRelationships(data.relationships);
              }
              if (data.relationshipTexts) {
                setRelationshipTexts(data.relationshipTexts);
              }
              if (data.customRelationships) {
                setCustomRelationships(data.customRelationships);
              }
              if (data.customStrengths) {
                setCustomStrengths(data.customStrengths);
              }
              if (data.customWeaknesses) {
                setCustomWeaknesses(data.customWeaknesses);
              }
              if (data.customFears) {
                setCustomFears(data.customFears);
              }
            }

            // Auto-select main characters based on age
            autoSelectMainCharacters(loadedCharacters);
          }
        } catch (err) {
          console.error('Error loading characters:', err);
        }
      };

      // Story persistence functions
      const saveStory = async (storyData) => {
        if (!authToken) return;

        try {
          const response = await fetch(`${API_URL}/api/stories`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${authToken}`
            },
            body: JSON.stringify({ story: storyData })
          });

          // Handle 413 Payload Too Large error
          if (response.status === 413) {
            throw new Error('Story is too large to save. Try reducing the number of pages or image quality.');
          }

          // Check if response is JSON or HTML error page
          const contentType = response.headers.get('content-type');
          if (!contentType || !contentType.includes('application/json')) {
            const text = await response.text();
            console.error('Non-JSON response:', text.substring(0, 200));
            throw new Error(`Server error (${response.status}): The story may be too large. Try reducing pages.`);
          }

          const result = await response.json();

          if (!response.ok) {
            if (response.status === 403 && result.error === 'Story quota exceeded') {
              // Refresh quota to show updated numbers
              await fetchUserQuota();
              throw new Error(`Story quota exceeded! You have used all ${result.quota} of your free stories. Contact admin for more credits.`);
            }
            throw new Error(result.error || 'Failed to save story');
          }

          // Refresh quota after successful story save
          await fetchUserQuota();
          return result.id;
        } catch (err) {
          console.error('Error saving story:', err);
          throw err; // Re-throw so caller can handle it
        }
      };

      // Helper function to fetch with progress tracking
      const fetchWithProgress = (url, options = {}) => {
        return new Promise((resolve, reject) => {
          const xhr = new XMLHttpRequest();
          xhr.open(options.method || 'GET', url);

          // Set headers
          if (options.headers) {
            Object.keys(options.headers).forEach(key => {
              xhr.setRequestHeader(key, options.headers[key]);
            });
          }

          // Track download progress
          xhr.onprogress = (event) => {
            if (event.lengthComputable) {
              const percentComplete = (event.loaded / event.total) * 100;
              setLoadingProgress(Math.round(percentComplete));
              setLoadingBytes(event.loaded);
              setLoadingTotalBytes(event.total);
            }
          };

          xhr.onload = () => {
            if (xhr.status >= 200 && xhr.status < 300) {
              try {
                const data = JSON.parse(xhr.responseText);
                resolve(data);
              } catch (err) {
                reject(new Error('Failed to parse JSON response'));
              }
            } else {
              reject(new Error(`HTTP ${xhr.status}: ${xhr.statusText}`));
            }
          };

          xhr.onerror = () => reject(new Error('Network error'));
          xhr.ontimeout = () => reject(new Error('Request timeout'));

          xhr.send(options.body);
        });
      };

      const loadStories = async () => {
        console.log('ðŸ“š loadStories() called', { hasAuthToken: !!authToken, apiUrl: API_URL });

        if (!authToken) {
          console.warn('âš ï¸  No auth token - cannot load stories');
          return [];
        }

        try {
          console.log('ðŸ“š Fetching stories from:', `${API_URL}/api/stories`);
          const response = await fetch(`${API_URL}/api/stories`, {
            headers: {
              'Authorization': `Bearer ${authToken}`
            }
          });

          console.log('ðŸ“š Stories response:', { ok: response.ok, status: response.status, statusText: response.statusText });

          if (response.ok) {
            console.log('ðŸ“š About to parse JSON...');
            try {
              const stories = await response.json();
              console.log('ðŸ“š JSON parsed successfully');
              console.log('ðŸ“š Stories loaded successfully:', { count: stories.length, stories: stories });
              console.log('ðŸ“š Returning stories:', stories);
              return stories;
            } catch (jsonErr) {
              console.error('âŒ Failed to parse JSON:', jsonErr);
              console.error('This usually means the server returned invalid JSON or the connection failed');
              return [];
            }
          } else {
            const errorText = await response.text();
            console.error('âŒ Stories API error:', { status: response.status, error: errorText });
            return [];
          }
        } catch (err) {
          console.error('âŒ Error loading stories:', err);
          console.error('Error details:', { message: err.message, stack: err.stack });
          return [];
        }
      };

      const generateOutline = async () => {
        // Backend now handles API key - no need to check locally
        // if (!apiKey) {
        //   setShowApiKeyPrompt(true);
        //   return;
        // }

        setIsGeneratingOutline(true);

        try {
          // Get list of non-main characters (secondary characters)
          const secondaryCharacters = characters.filter(c => !mainCharacters.includes(c.id));

          // Character manifest removed - will be generated during scene generation phase

          // If user edited the prompt in preview, use it directly
          // Otherwise, build the full outline prompt with structure
          let outlinePrompt;
          if (editablePrompt) {
            // User edited the preview - use their edited version directly
            outlinePrompt = editablePrompt;
          } else {
            // No edits - build the full structured prompt
            const basePrompt = buildPrompt();
            outlinePrompt = `# Role and Context

You are an expert children's book writer with deep understanding of age-appropriate storytelling, narrative structure, and visual storytelling for illustrated books. Your expertise includes:

- Creating engaging, age-appropriate narratives that captivate young readers
- Crafting clear story arcs with proper setup, conflict, and resolution
- Writing vivid scene descriptions that translate beautifully to illustrations
- Balancing text and visual elements for maximum impact
- Understanding pacing and page turns in illustrated books
- Creating memorable characters and meaningful moments

Your task is to create a compelling, well-structured story outline that will guide both the narrative text and visual illustrations.

${basePrompt}

# Part 1: Story Title

Create an engaging, age-appropriate title for this story. The title should:
- Capture the essence of the story
- Be appealing to the target age group
- Be memorable and creative
- Reflect the main theme or adventure

Format:
Title: [Your creative title here]

# Part 2: Story Outline

Create a detailed outline for this ${pages}-page story. Include:
- Brief summary of each page (what happens on that page)
- Key events and character moments
- Story arc and progression (clear beginning, middle, and end)
- How the story builds tension and resolves satisfyingly

For EACH of the ${pages} story pages, provide a SHORT SCENE DESCRIPTION (1-2 sentences) that describes the visual scene - what the characters are doing, where they are, and the setting. This will be used for illustration purposes.

# Part 3: Cover Scene Descriptions

In addition to the ${pages} story pages, provide scene descriptions for these 3 cover elements:

**Title Page Scene**: A captivating cover illustration that features the main characters and sets the tone for the story. This should be visually striking and focus on the protagonist(s) in a way that draws readers in.

**Page 0 Scene**: A dedication/introduction page illustration that creates a warm, inviting entry into the story world. This sets the mood and welcomes readers.

**Back Cover Scene**: A satisfying concluding illustration that provides closure and leaves readers with a positive feeling. This should feel like a natural ending to the visual journey.

# Format Your Response

Title: [Story title]

Page 1: [Summary]
Scene: [Short visual description]

Page 2: [Summary]
Scene: [Short visual description]

...and so on for all ${pages} pages.

Title Page: [Summary of title page concept]
Scene: [Visual description focusing on main characters]

Page 0: [Summary of dedication/intro concept]
Scene: [Visual description for welcoming scene]

Back Cover: [Summary of back cover concept]
Scene: [Visual description for concluding scene]

Be specific and creative. Each scene description should paint a clear picture for the illustrator.`;
          }

          // Store the prompt for debugging/display
          setGeneratedPrompt(outlinePrompt);

          const response = await makeApiCall(outlinePrompt, 8192);  // Max for Sonnet 4.5

          // Store outline prompt and API call for debugging
          setStoryOutlinePrompt(outlinePrompt);
          setStoryOutlineApiCall({
            type: 'text',
            model: 'claude-sonnet-4-5-20250929',
            prompt: outlinePrompt,
            maxTokens: 8192,
            timestamp: new Date().toISOString()
          });

          // Parse the response to extract title, cover scenes, and page scenes
          let outline = response;

          // Extract title
          const titleMatch = response.match(/Title:\s*(.+)/i);
          if (titleMatch) {
            const extractedTitle = titleMatch[1].trim();
            setStoryTitle(extractedTitle);
            console.log('Extracted title:', extractedTitle);
          }

          setStoryOutline(outline);
          setEditableOutline(outline);

          // Parse outline to extract scene descriptions
          if (currentUser?.role === 'admin') {
            console.log('ðŸ“‹ Outline generated successfully');
            console.log('Full outline (first 1000 chars):\n', outline.substring(0, 1000));
            console.log('\n=== END OUTLINE PREVIEW ===\n');
          }

          const sceneDescMap = {};
          const coverScenes = {
            titlePage: '',
            page0: '',
            backCover: ''
          };

          const lines = outline.split('\n');
          let currentPage = null;
          let currentCoverType = null;
          let collectingScene = false;
          let sceneBuffer = '';

          for (let i = 0; i < lines.length; i++) {
            const line = lines[i].trim();

            // Look for "Page X:" pattern (story pages) - handles **Page X:** too
            const pageMatch = line.match(/^(?:\*\*)?Page\s+(\d+)(?:\*\*)?[\s:]/i);
            if (pageMatch) {
              // Save any buffered scene before switching context
              if (collectingScene && sceneBuffer && (currentPage !== null || currentCoverType)) {
                if (currentPage !== null) {
                  sceneDescMap[currentPage] = sceneBuffer.trim();
                  console.log(`Stored scene for page ${currentPage}:`, sceneBuffer.substring(0, 50) + '...');
                } else if (currentCoverType) {
                  coverScenes[currentCoverType] = sceneBuffer.trim();
                  console.log(`Stored ${currentCoverType} scene:`, sceneBuffer.substring(0, 50) + '...');
                }
              }

              currentPage = parseInt(pageMatch[1]);
              currentCoverType = null;
              collectingScene = false;
              sceneBuffer = '';
            }

            // Look for cover page patterns - more flexible matching
            // Matches: "Title Page:", "**Title Page:**", "Title Page Scene:", etc.
            const titlePageMatch = line.match(/(?:\*\*)?Title\s+Page(?:\s+Scene)?(?:\*\*)?:\s*(.+)/i);
            if (titlePageMatch) {
              // Save any buffered scene before switching context
              if (collectingScene && sceneBuffer && (currentPage !== null || currentCoverType)) {
                if (currentPage !== null) {
                  sceneDescMap[currentPage] = sceneBuffer.trim();
                } else if (currentCoverType) {
                  coverScenes[currentCoverType] = sceneBuffer.trim();
                }
              }

              currentCoverType = 'titlePage';
              currentPage = null;
              collectingScene = true;
              sceneBuffer = titlePageMatch[1].trim();
              console.log('Found Title Page scene:', sceneBuffer.substring(0, 50) + '...');
            }

            const page0Match = line.match(/(?:\*\*)?Page\s+0(?:\s+Scene)?(?:\*\*)?:\s*(.+)/i);
            if (page0Match) {
              // Save any buffered scene before switching context
              if (collectingScene && sceneBuffer && (currentPage !== null || currentCoverType)) {
                if (currentPage !== null) {
                  sceneDescMap[currentPage] = sceneBuffer.trim();
                } else if (currentCoverType) {
                  coverScenes[currentCoverType] = sceneBuffer.trim();
                }
              }

              currentCoverType = 'page0';
              currentPage = null;
              collectingScene = true;
              sceneBuffer = page0Match[1].trim();
              console.log('Found Page 0 scene:', sceneBuffer.substring(0, 50) + '...');
            }

            const backCoverMatch = line.match(/(?:\*\*)?Back\s+Cover(?:\s+Scene)?(?:\*\*)?:\s*(.+)/i);
            if (backCoverMatch) {
              // Save any buffered scene before switching context
              if (collectingScene && sceneBuffer && (currentPage !== null || currentCoverType)) {
                if (currentPage !== null) {
                  sceneDescMap[currentPage] = sceneBuffer.trim();
                } else if (currentCoverType) {
                  coverScenes[currentCoverType] = sceneBuffer.trim();
                }
              }

              currentCoverType = 'backCover';
              currentPage = null;
              collectingScene = true;
              sceneBuffer = backCoverMatch[1].trim();
              console.log('Found Back Cover scene:', sceneBuffer.substring(0, 50) + '...');
            }

            // Look for "Scene:" pattern - start collecting scene description (handles **Scene:** too)
            const sceneMatch = line.match(/^(?:\*\*)?Scene(?:\*\*)?:\s*(.+)/i);
            if (sceneMatch) {
              collectingScene = true;
              sceneBuffer = sceneMatch[1].trim();
            } else if (collectingScene && line.length > 0 && !line.match(/^(Page|Title|Back\s+Cover)/i)) {
              // Continue collecting multi-line scene descriptions
              sceneBuffer += ' ' + line;
            } else if (collectingScene && line.length === 0) {
              // Empty line ends scene collection
              if (sceneBuffer && (currentPage !== null || currentCoverType)) {
                if (currentPage !== null) {
                  sceneDescMap[currentPage] = sceneBuffer.trim();
                  console.log(`Stored scene for page ${currentPage}:`, sceneBuffer.substring(0, 50) + '...');
                } else if (currentCoverType) {
                  coverScenes[currentCoverType] = sceneBuffer.trim();
                  console.log(`Stored ${currentCoverType} scene:`, sceneBuffer.substring(0, 50) + '...');
                }
              }
              collectingScene = false;
              sceneBuffer = '';
            }
          }

          // Save any remaining buffered scene at the end
          if (collectingScene && sceneBuffer && (currentPage !== null || currentCoverType)) {
            if (currentPage !== null) {
              sceneDescMap[currentPage] = sceneBuffer.trim();
              console.log(`Stored scene for page ${currentPage}:`, sceneBuffer.substring(0, 50) + '...');
            } else if (currentCoverType) {
              coverScenes[currentCoverType] = sceneBuffer.trim();
              console.log(`Stored ${currentCoverType} scene:`, sceneBuffer.substring(0, 50) + '...');
            }
          }

          setShortSceneDescriptions(sceneDescMap);
          setCoverSceneDescriptions(coverScenes);
          if (currentUser?.role === 'admin') {
            console.log('âœ… Parsing complete -', Object.keys(sceneDescMap).length, 'scenes');
          }

          // Warning if cover scenes are empty
          if (!coverScenes.titlePage || !coverScenes.page0 || !coverScenes.backCover) {
            console.warn('âš ï¸ WARNING: Some cover scene descriptions are empty!');
            console.warn('Missing:', {
              titlePage: !coverScenes.titlePage,
              page0: !coverScenes.page0,
              backCover: !coverScenes.backCover
            });
          }
        } catch (error) {
          console.error('Error generating outline:', error);
          alert(`Error generating outline: ${error.message}\n\nPlease check your API key and try again!`);
        } finally {
          setIsGeneratingOutline(false);
        }
      };

      // Character Consistency System Functions

      /**
       * Generate detailed text description from character for consistency
       * This avoids Gemini's child safety blocks by not sending images
       */
      const generateCharacterDescription = (character) => {
        const age = parseInt(character.age) || 10;
        const gender = character.gender || 'neutral';

        // Build comprehensive description
        let description = `${character.name} is a ${age}-year-old ${gender === 'male' ? 'boy' : gender === 'female' ? 'girl' : 'child'}`;

        // Add physical attributes if available
        if (character.height) {
          description += `, ${character.height}`;
        }
        if (character.build) {
          description += `, ${character.build} build`;
        }
        if (character.hairColor) {
          description += `, with ${character.hairColor} hair`;
        }
        if (character.otherFeatures) {
          description += `, ${character.otherFeatures}`;
        }

        // Add personality traits for character-appropriate expressions
        if (character.strengths && character.strengths.length > 0) {
          description += `. Personality: ${character.strengths.slice(0, 2).join(', ')}`;
        }

        return description;
      };

      /**
       * Generate cartoon illustration from character photo (for display only)
       * Returns base64 image data
       * NOTE: This cartoon is for DISPLAY purposes only, NOT used as API reference
       * Uses backend /api/gemini endpoint with Railway-stored API keys
       */
      const generateCharacterCartoon = async (character) => {
        if (!character.photoUrl) {
          throw new Error(`Character ${character.name} has no photo to convert`);
        }

        const cartoonPrompt = `CHILDREN'S BOOK CHARACTER ILLUSTRATION - Safe, family-friendly content.

Create a VERTICAL PORTRAIT-ORIENTED colorful cartoon illustration of this child named ${character.name} for a children's storybook. The illustration should be in 3:4 aspect ratio (portrait orientation). Make it friendly and cheerful with bright, vibrant colors and a simple background. Focus on capturing their distinctive features. No text or words on the image.

This is for a children's book illustration - wholesome, innocent, and appropriate for all ages.`;

        // Extract base64 data from photoUrl
        const base64Data = character.photoUrl.replace(/^data:image\/\w+;base64,/, '');
        const mimeType = character.photoUrl.match(/^data:(image\/\w+);base64,/) ?
          character.photoUrl.match(/^data:(image\/\w+);base64,/)[1] : 'image/png';

        // Call backend API endpoint which has the Gemini API key
        const response = await fetch(`${API_URL}/api/gemini`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${localStorage.getItem('auth_token')}`
          },
          body: JSON.stringify({
            model: 'gemini-2.5-flash-image',
            contents: [{
              parts: [
                { text: cartoonPrompt },
                {
                  inlineData: {
                    mimeType: mimeType,
                    data: base64Data
                  }
                }
              ]
            }],
            safetySettings: [
              { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_ONLY_HIGH" },
              { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_ONLY_HIGH" },
              { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_ONLY_HIGH" },
              { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_ONLY_HIGH" }
            ]
          })
        });

        if (!response.ok) {
          const errorData = await response.json();
          throw new Error(errorData.error || `API Error: ${response.status}`);
        }

        const data = await response.json();

        if (!data.candidates || data.candidates.length === 0) {
          throw new Error('No response from Gemini for cartoon generation');
        }

        const candidate = data.candidates[0];
        if (candidate.finishReason && candidate.finishReason !== 'STOP') {
          throw new Error(`Cartoon generation blocked: ${candidate.finishReason}`);
        }

        const responseParts = candidate.content.parts;
        for (const part of responseParts) {
          if (part.inlineData && part.inlineData.data) {
            return `data:image/png;base64,${part.inlineData.data}`;
          }
        }

        throw new Error('No image data in cartoon generation response');
      };

      /**
       * Generate cartoon illustrations for main characters
       */
      const generateMainCharacterCartoons = async () => {
        if (mainCharacters.length === 0) {
          return {};
        }

        setIsGeneratingCartoons(true);
        const cartoons = {};

        try {
          for (const charId of mainCharacters) {
            const character = characters.find(c => c.id === charId);
            if (character && character.photoUrl) {
              console.log(`Generating cartoon for ${character.name}...`);
              const cartoonImage = await generateCharacterCartoon(character);
              cartoons[charId] = cartoonImage;
            }
          }
        } finally {
          setIsGeneratingCartoons(false);
        }

        return cartoons;
      };

      /**
       * Build character consistency guide from manifest
       * Converts structured manifest into readable text guide for prompts
       */
      const buildCharacterConsistencyGuide = (manifest) => {
        if (!manifest || !manifest.characters || manifest.characters.length === 0) {
          return '';
        }

        let guide = '\n\n=== CHARACTER CONSISTENCY GUIDE ===\nUse these EXACT descriptions for secondary characters:\n\n';

        manifest.characters.forEach((char, idx) => {
          const app = char.appearance;
          guide += `[${char.name.toUpperCase()}] (${char.role})\n`;
          if (app.ageDescription) guide += `â€¢ Age: ${app.ageDescription}\n`;
          if (app.hairDescription) guide += `â€¢ Hair: ${app.hairDescription}\n`;
          if (app.faceDescription) guide += `â€¢ Face: ${app.faceDescription}\n`;
          if (app.buildDescription) guide += `â€¢ Build: ${app.buildDescription}\n`;
          if (app.clothingDescription) guide += `â€¢ Clothing: ${app.clothingDescription}\n`;
          if (app.accessoriesDescription) guide += `â€¢ Accessories: ${app.accessoriesDescription}\n`;
          if (app.distinctiveFeatures) guide += `â€¢ Distinctive: ${app.distinctiveFeatures}\n`;
          guide += '\n';
        });

        guide += 'CRITICAL: These characters MUST look IDENTICAL on every page. Do not change their appearance.\n';
        guide += '=== END CHARACTER GUIDE ===\n';

        return guide;
      };

      const generateStoryMultiPart = async () => {
        // Backend now handles API key - no need to check locally
        // if (!apiKey) {
        //   setShowApiKeyPrompt(true);
        //   return;
        // }

        setIsGenerating(true);

        // Extract and set story title
        const title = storyTypes.find(t => t.id === storyType)?.name[language] || 'My Story';
        setStoryTitle(title);

        const basePrompt = editablePrompt || buildPrompt();
        setGeneratedPrompt(basePrompt);

        try {
          // Determine chunk size (5 pages per chunk to avoid timeouts)
          const pagesPerChunk = 5;
          const totalChunks = Math.ceil(pages / pagesPerChunk);

          // Use the edited outline if available
          const outline = editableOutline || storyOutline;

          if (!outline) {
            throw new Error('No outline available. Please generate an outline first.');
          }

          // Generate story in chunks
          let fullStory = '';

          for (let i = 0; i < totalChunks; i++) {
            const startPage = i * pagesPerChunk + 1;
            const endPage = Math.min((i + 1) * pagesPerChunk, pages);

            setGenerationProgress({
              current: i + 1,
              total: totalChunks,
              message: `Generating pages ${startPage}-${endPage}...`
            });

            const chunkPrompt = `${basePrompt}\n\nHere is the story outline:\n${outline}\n\nIMPORTANT: Now write ONLY pages ${startPage} to ${endPage} of the story. Follow the outline above. Use "--- Page X ---" markers for each page. Write the complete content for these pages.\n\nFORMATTING: Format dialogues inline within paragraphs. Do not add extra line breaks between dialogue lines. Keep conversations flowing in continuous prose like a traditional novel.${i > 0 ? `\n\nPrevious story context:\n${fullStory.slice(-500)}` : ''}`;

            const chunk = await makeApiCall(chunkPrompt, 3072);
            fullStory += (i > 0 ? '\n\n' : '') + chunk;
          }

          setGeneratedStory(fullStory);
          setGenerationProgress({ current: totalChunks, total: totalChunks, message: 'Story complete!' });
          setStep(5);
        } catch (error) {
          console.error('Error generating story:', error);
          setGeneratedStory(`Sorry, there was an error generating your story: ${error.message}\n\nPlease check your API key and try again!`);
          setStep(5);
        } finally {
          setIsGenerating(false);
          setTimeout(() => setGenerationProgress({ current: 0, total: 0, message: '' }), 2000);
        }
      };

      const generateStory = async () => {
        // Backend now handles API key - no need to check locally
        // if (!apiKey) {
        //   setShowApiKeyPrompt(true);
        //   return;
        // }

        // Generate full story in one shot (no chunking)
        setIsGenerating(true);

        // Extract and set story title
        const title = storyTypes.find(t => t.id === storyType)?.name[language] || 'My Story';
        setStoryTitle(title);

        // Use the editable prompt if it exists, otherwise build a new one
        const basePrompt = editablePrompt || buildPrompt();

        // Save the prompt for display/download
        setGeneratedPrompt(basePrompt);

        try {
          // Include the outline in the story generation prompt
          const outline = editableOutline || storyOutline;
          const fullPrompt = outline
            ? `${basePrompt}\n\nHere is the story outline:\n${outline}\n\nIMPORTANT: Now write the complete story following the outline above. You MUST write exactly ${pages} pages (Pages 1 through ${pages}). Do NOT stop until all ${pages} pages are complete. Use "--- Page X ---" markers for each page. Write engaging, age-appropriate content for each page.\n\nFORMATTING: Format dialogues inline within paragraphs. Do not add extra line breaks between dialogue lines. Keep conversations flowing in continuous prose like a traditional novel.`
            : basePrompt;

          const storyText = await makeApiCall(fullPrompt, 64000);

          // Store story text prompt and API call for debugging
          setStoryTextPrompt(fullPrompt);
          setStoryTextApiCall({
            type: 'text',
            model: 'claude-sonnet-4-5-20250929',
            prompt: fullPrompt,
            maxTokens: 64000,
            timestamp: new Date().toISOString()
          });

          setGeneratedStory(storyText);
          setStep(5);
        } catch (error) {
          console.error('Error generating story:', error);
          setGeneratedStory(`Sorry, there was an error generating your story: ${error.message}\n\nPlease check your API key and try again!`);
          setStep(5);
        } finally {
          setIsGenerating(false);
        }
      };

      const generateScenes = async () => {
        // Backend now handles API key - no need to check locally
        // if (!apiKey) {
        //   setShowApiKeyPrompt(true);
        //   return;
        // }

        if (!generatedStory) {
          alert('Please generate a story first!');
          return;
        }

        setIsGeneratingScenes(true);
        setGenerationProgress({ current: 0, total: pages, message: 'Analyzing story pages...' });

        try {
          // Split story into pages
          const pageMatches = generatedStory.split(/---\s*Page\s+\d+\s*---/i);
          // Remove first element if it's just intro/empty text before "--- Page 1 ---"
          // Don't filter out empty pages - we need to maintain the page count
          const storyPages = pageMatches.slice(1);

          // Log warning if page count doesn't match
          if (storyPages.length < pages) {
            console.warn(`âš ï¸  Story has only ${storyPages.length} pages, expected ${pages} pages`);
          }

          const scenes = [];
          const prompts = {};

          // Generate scene description for each page (always generate for all requested pages)
          for (let i = 0; i < pages; i++) {
            setGenerationProgress({
              current: i + 1,
              total: pages,
              message: `Creating scene description for page ${i + 1}...`
            });

            const pageContent = storyPages[i] || '';
            const pageNumber = i + 1;

            // Warn if page content is missing
            if (!pageContent || pageContent.trim().length === 0) {
              console.warn(`âš ï¸  Page ${pageNumber}: No story text found, generating scene from outline only`);
            }

            // Get character names for reference
            const characterNames = characters.map(c => c.name).join(', ');

            // Get short scene description from outline if available
            const shortSceneDesc = shortSceneDescriptions[pageNumber];

            const scenePrompt = `**ROLE:**
You are an expert Art Director creating an illustration brief for a children's book.

**SCENE CONTEXT:**
${shortSceneDesc ? `Scene Summary: ${shortSceneDesc}\n\n` : ''}Story Text (Page ${pageNumber}):
${pageContent}

**AVAILABLE CHARACTERS & VISUAL REFERENCES:**
${characters.map(c => {
  const details = [];
  if (c.age) details.push(`Age ${c.age}`);
  if (c.gender) details.push(c.gender === 'male' ? 'Male' : c.gender === 'female' ? 'Female' : 'Non-binary');
  if (c.hairColor) details.push(c.hairColor);
  if (c.clothing) details.push(c.clothing);
  if (c.otherFeatures) details.push(c.otherFeatures);
  return `* **${c.name}:** ${details.join(', ')}`;
}).join('\n')}

**TASK:**
Create a detailed visual description of ONE key moment from the scene context provided.

Focus on essential characters only (1-2 maximum unless the story specifically requires more). Choose the most impactful visual moment that captures the essence of the scene.

**OUTPUT FORMAT:**
1. **Setting & Atmosphere:** Describe the background, time of day, lighting, and mood.
2. **Composition:** Describe the camera angle (e.g., low angle, wide shot) and framing.
3. **Characters:**
   * **[Character Name]:** Exact action, body language, facial expression, and location in the frame.
   (Repeat for each character present in this specific scene)

**CONSTRAINTS:**
- Do not include dialogue or speech
- Focus purely on visual elements
- Use simple, clear language
- Only include characters essential to this scene`;

            // Store the prompt for this specific scene
            prompts[pageNumber] = scenePrompt;

            const sceneDescription = await makeApiCall(scenePrompt, 384);

            scenes.push({
              pageNumber: pageNumber,
              description: sceneDescription
            });
          }

          setSceneDescriptions(scenes);
          setSceneDescriptionPrompts(prompts);

          // Validate that we have scenes for all pages
          if (scenes.length < pages) {
            console.warn(`Warning: Only ${scenes.length} scenes generated for ${pages} pages. Story may be incomplete.`);
            console.log('Generated page numbers:', scenes.map(s => s.pageNumber));
          }

          setGenerationProgress({ current: pages, total: pages, message: 'All scenes created!' });
        } catch (error) {
          console.error('Error generating scenes:', error);
          alert(`Error generating scenes: ${error.message}\n\nPlease try again!`);
        } finally {
          setIsGeneratingScenes(false);
          setTimeout(() => setGenerationProgress({ current: 0, total: 0, message: '' }), 2000);
        }
      };

      const downloadScenes = () => {
        if (sceneDescriptions.length === 0) {
          alert('No scenes to download. Please create scenes first!');
          return;
        }

        try {
          let content = `# Scene Descriptions\n`;
          content += `# ${allStoryTypes.find(t => t.id === storyType)?.name[language] || 'Story'}\n\n`;
          content += `Generated: ${new Date().toLocaleString()}\n\n`;
          content += `---\n\n`;

          sceneDescriptions.forEach(scene => {
            content += `## Page ${scene.pageNumber}\n\n`;
            content += `${scene.description}\n\n`;
            content += `---\n\n`;
          });

          const blob = new Blob([content], { type: 'text/markdown;charset=utf-8' });
          const url = URL.createObjectURL(blob);
          const link = document.createElement('a');
          link.href = url;
          link.download = `scene-descriptions-${Date.now()}.md`;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          URL.revokeObjectURL(url);
        } catch (error) {
          console.error('Download error:', error);
          alert('Download error: ' + error.message);
        }
      };

      const uploadStory = (e) => {
        const file = e.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = (event) => {
            try {
              const content = event.target.result;
              setGeneratedStory(content);

              // Extract page count from uploaded story
              const pageMatches = content.match(/---\s*Page\s+\d+\s*---/gi);
              if (pageMatches && pageMatches.length > 0) {
                setPages(pageMatches.length);
              }

              // Clear scene descriptions when uploading new story
              setSceneDescriptions([]);

              // Navigate to story view
              setStep(5);

              alert('Story uploaded successfully! You can now generate scene descriptions.');
            } catch (error) {
              console.error('Upload error:', error);
              alert('Error uploading story: ' + error.message);
            }
          };
          reader.readAsText(file);
        }
      };

      const saveGeminiApiKey = () => {
        if (tempGeminiApiKey.trim()) {
          localStorage.setItem('gemini_api_key', tempGeminiApiKey);
          setGeminiApiKey(tempGeminiApiKey);
          setShowGeminiApiKeyPrompt(false);
          setTempGeminiApiKey('');
        }
      };

      // Auto-Run Mode: Execute all steps automatically
      const runAutoMode = async () => {
        // Backend now handles API key - no need to check locally
        // if (!apiKey) {
        //   setShowApiKeyPrompt(true);
        //   return;
        // }

        try {
          // Step 1: Generate Outline
          setGenerationProgress({ current: 1, total: 4, message: 'Step 1/4: Generating story outline...' });
          setIsGeneratingOutline(true);

          // Build base prompt for later use in story generation
          const basePrompt = buildPrompt();

          // If user edited the prompt in preview, use it directly
          // Otherwise, build the full outline prompt with structure
          let outlinePrompt;
          if (editablePrompt) {
            // User edited the preview - use their edited version directly
            outlinePrompt = editablePrompt;
          } else {
            // No edits - build the full structured prompt
            outlinePrompt = `# Role and Context

You are an expert children's book writer with deep understanding of age-appropriate storytelling, narrative structure, and visual storytelling for illustrated books. Your expertise includes:

- Creating engaging, age-appropriate narratives that captivate young readers
- Crafting clear story arcs with proper setup, conflict, and resolution
- Writing vivid scene descriptions that translate beautifully to illustrations
- Balancing text and visual elements for maximum impact
- Understanding pacing and page turns in illustrated books
- Creating memorable characters and meaningful moments

Your task is to create a compelling, well-structured story outline that will guide both the narrative text and visual illustrations.

${basePrompt}

# Part 1: Story Title

Create an engaging, age-appropriate title for this story. The title should:
- Capture the essence of the story
- Be appealing to the target age group
- Be memorable and creative
- Reflect the main theme or adventure

Format:
Title: [Your creative title here]

# Part 2: Story Outline

Create a detailed outline for this ${pages}-page story. Include:
- Brief summary of each page (what happens on that page)
- Key events and character moments
- Story arc and progression (clear beginning, middle, and end)
- How the story builds tension and resolves satisfyingly

For EACH of the ${pages} story pages, provide a SHORT SCENE DESCRIPTION (1-2 sentences) that describes the visual scene - what the characters are doing, where they are, and the setting. This will be used for illustration purposes.

# Part 3: Cover Scene Descriptions

In addition to the ${pages} story pages, provide scene descriptions for these 3 cover elements:

**Title Page Scene**: A captivating cover illustration that features the main characters and sets the tone for the story. This should be visually striking and focus on the protagonist(s) in a way that draws readers in.

**Page 0 Scene**: A dedication/introduction page illustration that creates a warm, inviting entry into the story world. This sets the mood and welcomes readers.

**Back Cover Scene**: A satisfying concluding illustration that provides closure and leaves readers with a positive feeling. This should feel like a natural ending to the visual journey.

# Format Your Response

Title: [Story title]

Page 1: [Summary]
Scene: [Short visual description]

Page 2: [Summary]
Scene: [Short visual description]

...and so on for all ${pages} pages.

Title Page: [Summary of title page concept]
Scene: [Visual description focusing on main characters]

Page 0: [Summary of dedication/intro concept]
Scene: [Visual description for welcoming scene]

Back Cover: [Summary of back cover concept]
Scene: [Visual description for concluding scene]

Be specific and creative. Each scene description should paint a clear picture for the illustrator.`;
          }

          // Store the prompt for debugging/display
          setGeneratedPrompt(outlinePrompt);

          const outline = await makeApiCall(outlinePrompt, 8192);  // Max for Sonnet 4.5

          // Store outline prompt and API call for debugging
          setStoryOutlinePrompt(outlinePrompt);
          setStoryOutlineApiCall({
            type: 'text',
            model: 'claude-sonnet-4-5-20250929',
            prompt: outlinePrompt,
            maxTokens: 8192,
            timestamp: new Date().toISOString()
          });

          // Extract title
          const titleMatch = outline.match(/Title:\s*(.+)/i);
          if (titleMatch) {
            const extractedTitle = titleMatch[1].trim();
            setStoryTitle(extractedTitle);
            console.log('Extracted title:', extractedTitle);
          }

          setStoryOutline(outline);
          setEditableOutline(outline);

          // Parse outline to extract scene descriptions
          if (currentUser?.role === 'admin') {
            console.log('ðŸ“‹ Outline generated successfully');
            console.log('Full outline (first 1000 chars):\n', outline.substring(0, 1000));
            console.log('\n=== END OUTLINE PREVIEW ===\n');
          }

          const sceneDescMap = {};
          const coverScenes = {
            titlePage: '',
            page0: '',
            backCover: ''
          };

          const lines = outline.split('\n');
          let currentPage = null;
          let currentCoverType = null;
          let collectingScene = false;
          let sceneBuffer = '';

          for (let i = 0; i < lines.length; i++) {
            const line = lines[i].trim();

            // Look for "Page X:" pattern (story pages) - handles **Page X:** too
            const pageMatch = line.match(/^(?:\*\*)?Page\s+(\d+)(?:\*\*)?[\s:]/i);
            if (pageMatch) {
              // Save any buffered scene before switching context
              if (collectingScene && sceneBuffer && (currentPage !== null || currentCoverType)) {
                if (currentPage !== null) {
                  sceneDescMap[currentPage] = sceneBuffer.trim();
                  console.log(`Stored scene for page ${currentPage}:`, sceneBuffer.substring(0, 50) + '...');
                } else if (currentCoverType) {
                  coverScenes[currentCoverType] = sceneBuffer.trim();
                  console.log(`Stored ${currentCoverType} scene:`, sceneBuffer.substring(0, 50) + '...');
                }
              }

              currentPage = parseInt(pageMatch[1]);
              currentCoverType = null;
              collectingScene = false;
              sceneBuffer = '';
            }

            // Look for cover page patterns - more flexible matching
            // Matches: "Title Page:", "**Title Page:**", "Title Page Scene:", etc.
            const titlePageMatch = line.match(/(?:\*\*)?Title\s+Page(?:\s+Scene)?(?:\*\*)?:\s*(.+)/i);
            if (titlePageMatch) {
              // Save any buffered scene before switching context
              if (collectingScene && sceneBuffer && (currentPage !== null || currentCoverType)) {
                if (currentPage !== null) {
                  sceneDescMap[currentPage] = sceneBuffer.trim();
                } else if (currentCoverType) {
                  coverScenes[currentCoverType] = sceneBuffer.trim();
                }
              }

              currentCoverType = 'titlePage';
              currentPage = null;
              collectingScene = true;
              sceneBuffer = titlePageMatch[1].trim();
              console.log('Found Title Page scene:', sceneBuffer.substring(0, 50) + '...');
            }

            const page0Match = line.match(/(?:\*\*)?Page\s+0(?:\s+Scene)?(?:\*\*)?:\s*(.+)/i);
            if (page0Match) {
              // Save any buffered scene before switching context
              if (collectingScene && sceneBuffer && (currentPage !== null || currentCoverType)) {
                if (currentPage !== null) {
                  sceneDescMap[currentPage] = sceneBuffer.trim();
                } else if (currentCoverType) {
                  coverScenes[currentCoverType] = sceneBuffer.trim();
                }
              }

              currentCoverType = 'page0';
              currentPage = null;
              collectingScene = true;
              sceneBuffer = page0Match[1].trim();
              console.log('Found Page 0 scene:', sceneBuffer.substring(0, 50) + '...');
            }

            const backCoverMatch = line.match(/(?:\*\*)?Back\s+Cover(?:\s+Scene)?(?:\*\*)?:\s*(.+)/i);
            if (backCoverMatch) {
              // Save any buffered scene before switching context
              if (collectingScene && sceneBuffer && (currentPage !== null || currentCoverType)) {
                if (currentPage !== null) {
                  sceneDescMap[currentPage] = sceneBuffer.trim();
                } else if (currentCoverType) {
                  coverScenes[currentCoverType] = sceneBuffer.trim();
                }
              }

              currentCoverType = 'backCover';
              currentPage = null;
              collectingScene = true;
              sceneBuffer = backCoverMatch[1].trim();
              console.log('Found Back Cover scene:', sceneBuffer.substring(0, 50) + '...');
            }

            // Look for "Scene:" pattern - start collecting scene description (handles **Scene:** too)
            const sceneMatch = line.match(/^(?:\*\*)?Scene(?:\*\*)?:\s*(.+)/i);
            if (sceneMatch) {
              collectingScene = true;
              sceneBuffer = sceneMatch[1].trim();
            } else if (collectingScene && line.length > 0 && !line.match(/^(Page|Title|Back\s+Cover)/i)) {
              // Continue collecting multi-line scene descriptions
              sceneBuffer += ' ' + line;
            } else if (collectingScene && line.length === 0) {
              // Empty line ends scene collection
              if (sceneBuffer && (currentPage !== null || currentCoverType)) {
                if (currentPage !== null) {
                  sceneDescMap[currentPage] = sceneBuffer.trim();
                  console.log(`Stored scene for page ${currentPage}:`, sceneBuffer.substring(0, 50) + '...');
                } else if (currentCoverType) {
                  coverScenes[currentCoverType] = sceneBuffer.trim();
                  console.log(`Stored ${currentCoverType} scene:`, sceneBuffer.substring(0, 50) + '...');
                }
              }
              collectingScene = false;
              sceneBuffer = '';
            }
          }

          // Save any remaining buffered scene at the end
          if (collectingScene && sceneBuffer && (currentPage !== null || currentCoverType)) {
            if (currentPage !== null) {
              sceneDescMap[currentPage] = sceneBuffer.trim();
              console.log(`Stored scene for page ${currentPage}:`, sceneBuffer.substring(0, 50) + '...');
            } else if (currentCoverType) {
              coverScenes[currentCoverType] = sceneBuffer.trim();
              console.log(`Stored ${currentCoverType} scene:`, sceneBuffer.substring(0, 50) + '...');
            }
          }

          setShortSceneDescriptions(sceneDescMap);
          setCoverSceneDescriptions(coverScenes);
          if (currentUser?.role === 'admin') {
            console.log('âœ… Parsing complete -', Object.keys(sceneDescMap).length, 'scenes');
          }

          // Warning if cover scenes are empty
          if (!coverScenes.titlePage || !coverScenes.page0 || !coverScenes.backCover) {
            console.warn('âš ï¸ WARNING: Some cover scene descriptions are empty!');
            console.warn('Missing:', {
              titlePage: !coverScenes.titlePage,
              page0: !coverScenes.page0,
              backCover: !coverScenes.backCover
            });
          }

          setIsGeneratingOutline(false);
          await new Promise(resolve => setTimeout(resolve, 500));

          // Step 2: Generate Story
          setGenerationProgress({ current: 2, total: 4, message: 'Step 2/4: Generating full story...' });
          setIsGenerating(true);

          // Generate full story in one shot with Claude Sonnet 4.5's 64K output limit
          const fullPrompt = `${basePrompt}\n\nHere is the story outline:\n${outline}\n\nIMPORTANT: Now write the complete story following the outline above. You MUST write exactly ${pages} pages (Pages 1 through ${pages}). Do NOT stop until all ${pages} pages are complete. Use "--- Page X ---" markers for each page. Write engaging, age-appropriate content for each page.\n\nFORMATTING: Format dialogues inline within paragraphs. Do not add extra line breaks between dialogue lines. Keep conversations flowing in continuous prose like a traditional novel.`;
          const storyText = await makeApiCall(fullPrompt, 64000);

          setGeneratedStory(storyText);
          setStep(5);
          setIsGenerating(false);
          await new Promise(resolve => setTimeout(resolve, 500));

          // Step 3: Generate Scene Descriptions (IN PARALLEL - much faster!)
          setGenerationProgress({ current: 3, total: 4, message: 'Step 3/4: Creating scene descriptions in parallel...' });
          setIsGeneratingScenes(true);

          const pageMatches = storyText.split(/---\s*Page\s+\d+\s*---/i);
          // Remove first element if it's just intro/empty text before "--- Page 1 ---"
          const storyPages = pageMatches.slice(1).filter(p => p.trim().length > 0);
          const scenePrompts = {};

          // Create all scene generation promises at once
          const scenePromises = Array.from({ length: Math.min(pages, storyPages.length) }, async (_, i) => {
            const pageContent = storyPages[i] || '';
            const pageNumber = i + 1;
            const characterNames = characters.map(c => c.name).join(', ');

            // Get short scene description from outline if available
            const shortSceneDesc = sceneDescMap[pageNumber];

            const scenePrompt = `**ROLE:**
You are an expert Art Director creating an illustration brief for a children's book.

**SCENE CONTEXT:**
${shortSceneDesc ? `Scene Summary: ${shortSceneDesc}\n\n` : ''}Story Text (Page ${pageNumber}):
${pageContent}

**AVAILABLE CHARACTERS & VISUAL REFERENCES:**
${characters.map(c => {
  const details = [];
  if (c.age) details.push(`Age ${c.age}`);
  if (c.gender) details.push(c.gender === 'male' ? 'Male' : c.gender === 'female' ? 'Female' : 'Non-binary');
  if (c.hairColor) details.push(c.hairColor);
  if (c.clothing) details.push(c.clothing);
  if (c.otherFeatures) details.push(c.otherFeatures);
  return `* **${c.name}:** ${details.join(', ')}`;
}).join('\n')}

**TASK:**
Create a detailed visual description of ONE key moment from the scene context provided.

Focus on essential characters only (1-2 maximum unless the story specifically requires more). Choose the most impactful visual moment that captures the essence of the scene.

**OUTPUT FORMAT:**
1. **Setting & Atmosphere:** Describe the background, time of day, lighting, and mood.
2. **Composition:** Describe the camera angle (e.g., low angle, wide shot) and framing.
3. **Characters:**
   * **[Character Name]:** Exact action, body language, facial expression, and location in the frame.
   (Repeat for each character present in this specific scene)

**CONSTRAINTS:**
- Do not include dialogue or speech
- Focus purely on visual elements
- Use simple, clear language
- Only include characters essential to this scene`;

            // Store the prompt for this specific scene
            scenePrompts[pageNumber] = scenePrompt;

            const sceneDescription = await makeApiCall(scenePrompt, 384);
            return { pageNumber: pageNumber, description: sceneDescription };
          });

          // Wait for all scene descriptions to complete in parallel
          const scenes = await Promise.all(scenePromises);

          setSceneDescriptions(scenes);
          setSceneDescriptionPrompts(scenePrompts);

          // Validate that we have scenes for all pages
          if (scenes.length < pages) {
            console.warn(`Auto-mode: Only ${scenes.length} scenes generated for ${pages} pages. Story may be incomplete.`);
            console.log('Auto-mode: Generated page numbers:', scenes.map(s => s.pageNumber));
            console.log('Auto-mode: Story pages array length:', storyPages.length);
          }

          setIsGeneratingScenes(false);
          await new Promise(resolve => setTimeout(resolve, 500));

          // Step 4: Generate Scene Images (IN PARALLEL - much faster!)
          setGenerationProgress({ current: 4, total: 4, message: 'Step 4/4: Generating scene images in parallel...' });
          setIsGeneratingImages(true);

          const prompts = {};
          const characterClothing = {};

          // Ensure we have scenes for all pages
          const scenesToGenerate = scenes.slice(0, pages);
          console.log(`Auto-mode: Generating images for ${scenesToGenerate.length} scenes in parallel (pages: ${pages}, total scenes: ${scenes.length})`);

          // Create all image generation promises at once
          const imagePromises = scenesToGenerate.map(async (scene) => {
            console.log(`Auto-mode: Generating image for page ${scene.pageNumber}`);

            const charactersInScene = characters.filter(char =>
              scene.description.toLowerCase().includes(char.name.toLowerCase())
            );

            const sceneText = scene.description.toLowerCase();
            const isOutdoor = sceneText.includes('outside') || sceneText.includes('outdoor') ||
                            sceneText.includes('forest') || sceneText.includes('park') ||
                            sceneText.includes('garden') || sceneText.includes('street') ||
                            sceneText.includes('playground');
            const isIndoor = sceneText.includes('inside') || sceneText.includes('indoor') ||
                           sceneText.includes('room') || sceneText.includes('house') ||
                           sceneText.includes('kitchen') || sceneText.includes('bedroom');

            let characterPrompts = '';
            const characterImages = [];
            const characterImageMap = []; // Track which image belongs to which character

            if (charactersInScene.length > 0) {
              characterPrompts = '\n\nThe scene MUST feature the following characters with strict adherence to their physical description (Age, Height, Build):\n';

              charactersInScene.forEach((char, idx) => {
                const age = parseInt(char.age) || 10;

                // Use clothing from avatar analysis if available, otherwise use default
                if (!characterClothing[char.name]) {
                  if (char.clothing) {
                    // Use clothing extracted from avatar
                    characterClothing[char.name] = char.clothing;
                    characterClothing[char.name + '_base'] = char.clothing;
                  } else {
                    // Fallback to default clothing
                    if (isOutdoor) {
                      characterClothing[char.name] = age < 13 ? 'blue jacket, jeans, red sneakers' : 'gray jacket, dark pants, brown shoes';
                    } else {
                      characterClothing[char.name] = age < 13 ? 'casual outdoor clothes' : 'casual indoor clothes';
                    }
                    characterClothing[char.name + '_base'] = characterClothing[char.name];
                  }
                } else {
                  // Adjust clothing for indoor/outdoor if needed
                  const baseClothing = characterClothing[char.name + '_base'] || characterClothing[char.name];
                  if (isOutdoor && baseClothing && !characterClothing[char.name].includes('jacket')) {
                    characterClothing[char.name] = `jacket over ${baseClothing}`;
                  } else if (isIndoor && characterClothing[char.name].includes('jacket')) {
                    characterClothing[char.name] = baseClothing;
                  }
                }

                // Build comprehensive physical description
                let physicalDesc = '';
                if (char.height) physicalDesc += `Height: ${char.height}, `;
                if (char.build) physicalDesc += `Build: ${char.build}, `;
                if (char.otherFeatures) physicalDesc += char.otherFeatures;
                if (!physicalDesc) physicalDesc = '3D character';

                // Track if this character has a reference image
                const hasImage = char.photoUrl ? true : false;
                const imageRef = hasImage ? ` [Reference Image ${characterImages.length + 1}]` : '';

                characterPrompts += `Character ${idx + 1} (${char.name})${imageRef}: Age ${char.age}, ${physicalDesc.trim()}. Wearing: ${characterClothing[char.name]}. Eyes must be correctly aligned, not cross-eyed, with a natural gaze.\n`;

                // Use avatar (photoUrl) for better character consistency
                if (char.photoUrl) {
                  characterImages.push(char.photoUrl);
                  characterImageMap.push({ name: char.name, imageIndex: characterImages.length });
                }
              });

              // Add image reference explanation if we have character images
              if (characterImageMap.length > 0) {
                characterPrompts += '\n**CHARACTER REFERENCE IMAGES:**\n';
                characterImageMap.forEach((mapping) => {
                  characterPrompts += `- Image ${mapping.imageIndex}: ${mapping.name}'s portrait (use for facial features, appearance consistency)\n`;
                });
              }

              characterPrompts += '\nMaintain their visual identity, relative heights, and ages as described.';
            }

            const shortSceneDesc = sceneDescMap[scene.pageNumber];

            // Get the selected art style's prompt
            const selectedStyle = artStyles.find(s => s.id === artStyle) || artStyles[0];
            const styleDescription = selectedStyle.prompt;

            const imagePrompt = `Create a cinematic scene in ${styleDescription}.\n\nScene Description: ${scene.description}\n${characterPrompts}\n\nImportant:\n- Show only the emotions visible on faces (happy, sad, surprised, worried, excited)\n- Keep clothing exactly as described\n- Maintain consistent character appearance\n- Clean, clear composition`;

            prompts[scene.pageNumber] = imagePrompt;

            try {
              let imageData;
              if (characterImages.length > 0) {
                // Call backend API endpoint which has the Gemini API key
                const parts = [{ text: imagePrompt }];

                characterImages.forEach(charImage => {
                  const base64Data = charImage.replace(/^data:image\/\w+;base64,/, '');
                  const mimeType = charImage.match(/^data:(image\/\w+);base64,/) ?
                    charImage.match(/^data:(image\/\w+);base64,/)[1] : 'image/png';

                  parts.push({
                    inlineData: {
                      mimeType: mimeType,
                      data: base64Data
                    }
                  });
                });

                const apiPayload = {
                  model: 'gemini-2.5-flash-image',
                  contents: [{ parts }],
                  safetySettings: [
                    { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_ONLY_HIGH" },
                    { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_ONLY_HIGH" },
                    { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_ONLY_HIGH" },
                    { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_ONLY_HIGH" }
                  ]
                };

                // Log full API call for admin debugging
                const apiCallLog = {
                  endpoint: `${API_URL}/api/gemini`,
                  method: 'POST',
                  payload: JSON.parse(JSON.stringify(apiPayload)), // Deep copy without image data
                  timestamp: new Date().toISOString()
                };
                // Remove base64 image data from log to keep it readable
                if (apiCallLog.payload.contents && apiCallLog.payload.contents[0].parts) {
                  apiCallLog.payload.contents[0].parts = apiCallLog.payload.contents[0].parts.map(part => {
                    if (part.inlineData) {
                      return { inlineData: { mimeType: part.inlineData.mimeType, data: '[base64 image data]' } };
                    }
                    return part;
                  });
                }
                setApiCalls(prev => ({ ...prev, [scene.pageNumber]: apiCallLog }));

                const response = await fetch(`${API_URL}/api/gemini`, {
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${localStorage.getItem('auth_token')}`
                  },
                  body: JSON.stringify(apiPayload)
                });

                if (!response.ok) throw new Error(`API Error: ${response.status}`);

                const data = await response.json();
                if (!data.candidates || data.candidates.length === 0) {
                  throw new Error("No response from Gemini.");
                }

                const candidate = data.candidates[0];
                if (candidate.finishReason && candidate.finishReason !== 'STOP') {
                  throw new Error(`Content blocked: ${candidate.finishReason}.`);
                }

                if (!candidate.content || !candidate.content.parts) {
                  throw new Error("Invalid response from Gemini.");
                }

                const responseParts = candidate.content.parts;
                for (const part of responseParts) {
                  if (part.inlineData && part.inlineData.data) {
                    imageData = `data:image/png;base64,${part.inlineData.data}`;
                    break;
                  }
                }

                if (!imageData) throw new Error("No image data found in response.");
              } else {
                imageData = await callGeminiAPI(imagePrompt);
              }

              return { pageNumber: scene.pageNumber, imageData: imageData };
            } catch (error) {
              console.error(`Error generating image for page ${scene.pageNumber}:`, error);
              return {
                pageNumber: scene.pageNumber,
                imageData: null,
                error: error.message
              };
            }
          });

          // Wait for all images to complete in parallel
          const images = await Promise.all(imagePromises);

          setSceneImages(images);
          setImagePrompts(prompts);

          // Generate cover images in parallel
          console.log('Generating 3 cover images...');
          const selectedStyle = artStyles.find(s => s.id === artStyle) || artStyles[0];
          const styleDescription = selectedStyle.prompt;

          // Build character information for cover images
          const coverCharacterImages = [];
          const coverCharacterImageMap = [];
          let characterInfo = '';

          if (characters.length > 0) {
            characterInfo = '\n\nThe cover MUST feature the following characters:\n';

            characters.forEach((char, idx) => {
              const imageRef = char.photoUrl ? ` [Reference Image ${coverCharacterImages.length + 1}]` : '';
              characterInfo += `Character ${idx + 1} (${char.name})${imageRef}: ${char.age} years old, ${char.height}, ${char.build}. ${char.traits}.\n`;

              // Collect character images
              if (char.photoUrl) {
                coverCharacterImages.push(char.photoUrl);
                coverCharacterImageMap.push({ name: char.name, imageIndex: coverCharacterImages.length });
              }
            });

            // Add image reference explanation if we have character images
            if (coverCharacterImageMap.length > 0) {
              characterInfo += '\n**CHARACTER REFERENCE IMAGES:**\n';
              coverCharacterImageMap.forEach((mapping) => {
                characterInfo += `- Image ${mapping.imageIndex}: ${mapping.name}'s portrait (use for facial features, appearance consistency)\n`;
              });
            }
          }

          // Use scene descriptions from outline if available, otherwise use defaults
          // NOTE: Use local 'coverScenes' variable instead of state to avoid async timing issues
          const titlePageScene = coverScenes.titlePage || `A beautiful, magical title page featuring the main characters. Decorative elements that reflect the story's theme with space for the title text.`;
          const page0Scene = coverScenes.page0 || `A warm, inviting dedication/introduction page that sets the mood and welcomes readers.`;
          const backCoverScene = coverScenes.backCover || `A satisfying, conclusive ending scene that provides closure and leaves readers with a warm feeling.`;

          // Define cover image prompts with scene descriptions from outline
          const frontCoverPrompt = `${titlePageScene}\n\nStyle: ${styleDescription}.${characterInfo}\n\nCreate this as a beautiful title page for the children's book "${storyTitle}". Magical and inviting.`;
          const page0Prompt = `${page0Scene}\n\nStyle: ${styleDescription}.${characterInfo}\n\nCreate this as the dedication/introduction page for "${storyTitle}".`;
          const backCoverPrompt = `${backCoverScene}\n\nStyle: ${styleDescription}.${characterInfo}\n\nCreate this as the back cover illustration for "${storyTitle}".\n\nIMPORTANT: Include the text "magicalstory.ch" in small, elegant letters in the bottom left corner of the image.`;

          // Define detailed cover scene descriptions for display
          const coverDescriptions = {
            frontCover: `**Title Page / Front Cover**\n\n${titlePageScene}`,
            page0: `**Page 0 - Dedication/Introduction**\n\n${page0Scene}`,
            backCover: `**Back Cover**\n\n${backCoverScene}`
          };

          const generateCoverImage = async (coverType, prompt, charImages = []) => {
            try {
              let imageData = null;

              // If we have character images, use multi-part API call
              if (charImages.length > 0) {
                const parts = [{ text: prompt }];

                charImages.forEach(charImage => {
                  const base64Data = charImage.replace(/^data:image\/\w+;base64,/, '');
                  const mimeType = charImage.match(/^data:(image\/\w+);base64,/) ?
                    charImage.match(/^data:(image\/\w+);base64,/)[1] : 'image/png';

                  parts.push({
                    inlineData: {
                      mimeType: mimeType,
                      data: base64Data
                    }
                  });
                });

                const apiPayload = {
                  model: 'gemini-2.5-flash-image',
                  contents: [{ parts }],
                  safetySettings: [
                    { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_ONLY_HIGH" },
                    { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_ONLY_HIGH" },
                    { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_ONLY_HIGH" },
                    { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_ONLY_HIGH" }
                  ]
                };

                const response = await fetch(`${API_URL}/api/gemini`, {
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${localStorage.getItem('auth_token')}`
                  },
                  body: JSON.stringify(apiPayload)
                });

                if (!response.ok) throw new Error(`API Error: ${response.status}`);

                const data = await response.json();
                if (!data.candidates || data.candidates.length === 0) {
                  throw new Error("No response from Gemini.");
                }

                const candidate = data.candidates[0];
                if (candidate.finishReason && candidate.finishReason !== 'STOP') {
                  throw new Error(`Content blocked: ${candidate.finishReason}.`);
                }

                if (!candidate.content || !candidate.content.parts) {
                  throw new Error("Invalid response from Gemini.");
                }

                const responseParts = candidate.content.parts;
                for (const part of responseParts) {
                  if (part.inlineData && part.inlineData.data) {
                    imageData = `data:image/png;base64,${part.inlineData.data}`;
                    break;
                  }
                }

                if (!imageData) throw new Error("No image data found in response.");
              } else {
                // No character images, use simple text-only API call
                imageData = await callGeminiAPI(prompt);
              }

              return imageData;
            } catch (error) {
              console.error(`Error generating ${coverType} cover:`, error);
              return null;
            }
          };

          const coverPromises = [
            generateCoverImage('frontCover', frontCoverPrompt, coverCharacterImages),
            generateCoverImage('page0', page0Prompt, coverCharacterImages),
            generateCoverImage('backCover', backCoverPrompt, coverCharacterImages)
          ];

          const [frontCover, page0, backCover] = await Promise.all(coverPromises);

          // Store cover image prompts
          setCoverImagePrompts({
            frontCover: frontCoverPrompt,
            page0: page0Prompt,
            backCover: backCoverPrompt
          });

          // Store cover image API calls for debugging
          setCoverImageApiCalls({
            frontCover: { type: 'image', model: 'gemini-2.0-flash-exp', prompt: frontCoverPrompt },
            page0: { type: 'image', model: 'gemini-2.0-flash-exp', prompt: page0Prompt },
            backCover: { type: 'image', model: 'gemini-2.0-flash-exp', prompt: backCoverPrompt }
          });

          setCoverImages({
            frontCover,
            page0,
            backCover,
            descriptions: coverDescriptions
          });
          console.log('Cover images generated with full scene descriptions and prompts stored');

          setIsGeneratingImages(false);

          // Save the complete story
          const storyToSave = {
            title: storyTitle || `${storyType} Story - ${new Date().toLocaleDateString()}`,
            storyType,
            artStyle,
            pages,
            characters,
            outline: storyOutline,
            story: storyText,
            sceneDescriptions: scenes,
            sceneImages: images,
            coverImages: coverImages,
            thumbnail: coverImages.frontCover, // Use front cover as thumbnail
            createdAt: new Date().toISOString()
          };

          const savedId = await saveStory(storyToSave);
          if (savedId) {
            // Store the current story ID for print orders
            setCurrentStoryId(savedId);
            // Reload saved stories
            const updatedStories = await loadStories();
            setSavedStories(updatedStories);
          }

          setGenerationProgress({ current: 4, total: 4, message: 'Complete! Story and images ready!' });
          setTimeout(() => setGenerationProgress({ current: 0, total: 0, message: '' }), 3000);
        } catch (error) {
          console.error('Auto-run error:', error);
          alert(`Auto-run failed: ${error.message}\n\nYou can continue manually from where it stopped.`);
          setGenerationProgress({ current: 0, total: 0, message: '' });
          setIsGeneratingOutline(false);
          setIsGenerating(false);
          setIsGeneratingScenes(false);
          setIsGeneratingImages(false);
        }
      };

      // Gemini API Helper Functions
      const callGeminiAPI = async (prompt, imageData = null) => {
        if (!authToken) {
          throw new Error('Authentication required');
        }

        const parts = [{ text: prompt }];

        if (imageData) {
          // Add image data if provided
          const base64Data = imageData.replace(/^data:image\/\w+;base64,/, '');
          const mimeType = imageData.match(/^data:(image\/\w+);base64,/) ?
            imageData.match(/^data:(image\/\w+);base64,/)[1] : 'image/png';

          parts.push({
            inlineData: {
              mimeType: mimeType,
              data: base64Data
            }
          });
        }

        const apiPayload = {
          model: 'gemini-2.5-flash-image',
          contents: [{ parts: parts }],
          safetySettings: [
            { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_ONLY_HIGH" },
            { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_ONLY_HIGH" },
            { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_ONLY_HIGH" },
            { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_ONLY_HIGH" }
          ]
        };

        const response = await fetch(`${API_URL}/api/gemini`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${authToken}`
          },
          body: JSON.stringify(apiPayload)
        });

        if (!response.ok) {
          const errorText = await response.text();
          throw new Error(`Gemini API Error: ${errorText}`);
        }

        const data = await response.json();

        if (!data.candidates || data.candidates.length === 0) {
          console.error('Gemini API response:', data);
          throw new Error('No response from Gemini API. The content may have been blocked for safety reasons.');
        }

        // Check for safety blocks or other finish reasons
        const candidate = data.candidates[0];
        if (candidate.finishReason && candidate.finishReason !== 'STOP') {
          console.error('Gemini blocked content:', candidate);
          throw new Error(`Content generation blocked: ${candidate.finishReason}. Try adjusting your prompt or image.`);
        }

        if (!candidate.content || !candidate.content.parts) {
          console.error('Invalid response structure:', candidate);
          throw new Error('Invalid response structure from Gemini API. The content may have been filtered.');
        }

        const responseParts = candidate.content.parts;
        for (const part of responseParts) {
          if (part.inlineData && part.inlineData.data) {
            return `data:image/png;base64,${part.inlineData.data}`;
          }
        }

        throw new Error('No image data found in Gemini response');
      };

      // Helper function to call Gemini API with logging
      const callGeminiAPIWithLogging = async (prompt, imageData = null, pageNumber = null) => {
        if (!authToken) {
          throw new Error('Authentication required');
        }

        const parts = [{ text: prompt }];

        if (imageData) {
          const base64Data = imageData.replace(/^data:image\/\w+;base64,/, '');
          const mimeType = imageData.match(/^data:(image\/\w+);base64,/) ?
            imageData.match(/^data:(image\/\w+);base64,/)[1] : 'image/png';

          parts.push({
            inlineData: {
              mimeType: mimeType,
              data: base64Data
            }
          });
        }

        const apiPayload = {
          model: 'gemini-2.5-flash-image',
          contents: [{ parts: parts }],
          safetySettings: [
            { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_ONLY_HIGH" },
            { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_ONLY_HIGH" },
            { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_ONLY_HIGH" },
            { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_ONLY_HIGH" }
          ]
        };

        // Log API call for admin debugging
        if (pageNumber !== null) {
          const apiCallLog = {
            endpoint: `${API_URL}/api/gemini`,
            method: 'POST',
            payload: JSON.parse(JSON.stringify(apiPayload)),
            timestamp: new Date().toISOString()
          };
          // Remove base64 data from log
          if (apiCallLog.payload.contents && apiCallLog.payload.contents[0].parts) {
            apiCallLog.payload.contents[0].parts = apiCallLog.payload.contents[0].parts.map(part => {
              if (part.inlineData) {
                return { inlineData: { mimeType: part.inlineData.mimeType, data: '[base64 image data]' } };
              }
              return part;
            });
          }
          setApiCalls(prev => ({ ...prev, [pageNumber]: apiCallLog }));
        }

        const response = await fetch(`${API_URL}/api/gemini`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${authToken}`
          },
          body: JSON.stringify(apiPayload)
        });

        if (!response.ok) {
          const errorText = await response.text();
          throw new Error(`Gemini API Error: ${errorText}`);
        }

        const data = await response.json();

        if (!data.candidates || data.candidates.length === 0) {
          throw new Error('No response from Gemini API.');
        }

        const candidate = data.candidates[0];
        if (candidate.finishReason && candidate.finishReason !== 'STOP') {
          throw new Error(`Content generation blocked: ${candidate.finishReason}.`);
        }

        if (!candidate.content || !candidate.content.parts) {
          throw new Error('Invalid response structure from Gemini API.');
        }

        const responseParts = candidate.content.parts;
        for (const part of responseParts) {
          if (part.inlineData && part.inlineData.data) {
            return `data:image/png;base64,${part.inlineData.data}`;
          }
        }

        throw new Error('No image data found in Gemini response');
      };

      // Helper function to call Gemini API with multiple images
      const callGeminiAPIWithImages = async (prompt, imageDataArray, pageNumber = null) => {
        if (!authToken) {
          throw new Error('Authentication required');
        }

        const parts = [{ text: prompt }];

        // Add all images
        imageDataArray.forEach(imageData => {
          const base64Data = imageData.replace(/^data:image\/\w+;base64,/, '');
          const mimeType = imageData.match(/^data:(image\/\w+);base64,/) ?
            imageData.match(/^data:(image\/\w+);base64,/)[1] : 'image/png';

          parts.push({
            inlineData: {
              mimeType: mimeType,
              data: base64Data
            }
          });
        });

        const apiPayload = {
          model: 'gemini-2.5-flash-image',
          contents: [{ parts: parts }],
          safetySettings: [
            { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_ONLY_HIGH" },
            { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_ONLY_HIGH" },
            { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_ONLY_HIGH" },
            { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_ONLY_HIGH" }
          ]
        };

        // Log API call for admin debugging
        if (pageNumber !== null) {
          const apiCallLog = {
            endpoint: `${API_URL}/api/gemini`,
            method: 'POST',
            payload: JSON.parse(JSON.stringify(apiPayload)),
            timestamp: new Date().toISOString()
          };
          // Remove base64 data from log
          if (apiCallLog.payload.contents && apiCallLog.payload.contents[0].parts) {
            apiCallLog.payload.contents[0].parts = apiCallLog.payload.contents[0].parts.map(part => {
              if (part.inlineData) {
                return { inlineData: { mimeType: part.inlineData.mimeType, data: '[base64 image data]' } };
              }
              return part;
            });
          }
          setApiCalls(prev => ({ ...prev, [pageNumber]: apiCallLog }));
        }

        const response = await fetch(`${API_URL}/api/gemini`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${authToken}`
          },
          body: JSON.stringify(apiPayload)
        });

        if (!response.ok) {
          const errorText = await response.text();
          throw new Error(`Gemini API Error: ${errorText}`);
        }

        const data = await response.json();

        if (!data.candidates || data.candidates.length === 0) {
          throw new Error('No response from Gemini API.');
        }

        const candidate = data.candidates[0];
        if (candidate.finishReason && candidate.finishReason !== 'STOP') {
          throw new Error(`Content generation blocked: ${candidate.finishReason}.`);
        }

        if (!candidate.content || !candidate.content.parts) {
          throw new Error('Invalid response structure from Gemini API.');
        }

        const responseParts = candidate.content.parts;
        for (const part of responseParts) {
          if (part.inlineData && part.inlineData.data) {
            return `data:image/png;base64,${part.inlineData.data}`;
          }
        }

        throw new Error('No image data found in Gemini response');
      };

      const generateSceneImages = async () => {
        if (sceneDescriptions.length === 0) {
          alert('Please create scene descriptions first!');
          return;
        }

        setIsGeneratingImages(true);
        setGenerationProgress({ current: 0, total: sceneDescriptions.length + mainCharacters.length, message: 'Generating character cartoons...' });

        try {
          // STEP 1: Generate base character cartoons for main characters (if not already generated)
          let cartoons = baseCharacterImages;
          if (mainCharacters.length > 0 && Object.keys(baseCharacterImages).length === 0) {
            console.log('Generating base character cartoons for main characters...');
            cartoons = await generateMainCharacterCartoons();
            setBaseCharacterImages(cartoons);
          }

          setGenerationProgress({ current: mainCharacters.length, total: sceneDescriptions.length + mainCharacters.length, message: 'Generating images in parallel...' });

          const prompts = {}; // Store prompts for each image
          const characterClothing = {}; // Track clothing for consistency

          // Only generate images for the current number of pages
          const scenesToGenerate = sceneDescriptions.slice(0, pages);
          console.log(`Generating images for ${scenesToGenerate.length} scenes in parallel (pages: ${pages}, total scenes: ${sceneDescriptions.length})`);

          // Create all image generation promises at once
          const imagePromises = scenesToGenerate.map(async (scene) => {
            console.log(`Generating image for page ${scene.pageNumber}, scene description exists: ${!!scene.description}`);

            // Identify which characters are in THIS scene
            const charactersInScene = characters.filter(char =>
              scene.description.toLowerCase().includes(char.name.toLowerCase())
            );

            // Detect scene setting
            const sceneText = scene.description.toLowerCase();
            const isOutdoor = sceneText.includes('outside') || sceneText.includes('outdoor') ||
                            sceneText.includes('forest') || sceneText.includes('park') ||
                            sceneText.includes('garden') || sceneText.includes('street') ||
                            sceneText.includes('playground');
            const isIndoor = sceneText.includes('inside') || sceneText.includes('indoor') ||
                           sceneText.includes('room') || sceneText.includes('house') ||
                           sceneText.includes('kitchen') || sceneText.includes('bedroom');

            // Build character context - ONLY for characters in this scene
            // NOTE: We do NOT send character images to avoid Gemini's child safety blocks
            // Instead, we use detailed text descriptions for consistency
            let characterPrompts = '';

            if (charactersInScene.length > 0) {
              characterPrompts = '\n\nCHARACTER APPEARANCE GUIDE - Maintain EXACT consistency across all pages:\n\n';

              charactersInScene.forEach((char, idx) => {
                const age = parseInt(char.age) || 10;
                const isMainCharacter = mainCharacters.includes(char.id);

                // Initialize or update clothing based on scene setting
                if (!characterClothing[char.name]) {
                  // First appearance - use clothing from avatar if available
                  if (char.clothing) {
                    characterClothing[char.name] = char.clothing;
                    characterClothing[char.name + '_base'] = char.clothing;
                  } else {
                    // Fallback to default clothing
                    if (isOutdoor) {
                      characterClothing[char.name] = age < 13
                        ? 'blue jacket, jeans, red sneakers'
                        : 'gray jacket, dark pants, brown shoes';
                    } else {
                      characterClothing[char.name] = age < 13
                        ? 'casual outdoor clothes'
                        : 'casual indoor clothes';
                    }
                    characterClothing[char.name + '_base'] = characterClothing[char.name];
                  }
                } else {
                  // Character appeared before - check if clothing needs to change
                  const baseClothing = characterClothing[char.name + '_base'] || characterClothing[char.name];

                  if (isOutdoor && !characterClothing[char.name].includes('jacket') && !characterClothing[char.name].includes('coat')) {
                    // Going outside - add jacket/coat
                    characterClothing[char.name] = age < 13
                      ? `jacket over ${baseClothing}`
                      : `warm coat over ${baseClothing}`;
                  } else if (isIndoor && (characterClothing[char.name].includes('jacket') || characterClothing[char.name].includes('coat'))) {
                    // Going inside - remove jacket/coat (back to base)
                    characterClothing[char.name] = baseClothing;
                  }
                }

                // Build comprehensive character description
                const baseDescription = generateCharacterDescription(char);

                // Enhanced description with more detail
                characterPrompts += `[${char.name}] - ${isMainCharacter ? 'MAIN CHARACTER' : 'Supporting Character'}\n`;
                characterPrompts += `  â†’ ${baseDescription}\n`;
                characterPrompts += `  â†’ Wearing: ${characterClothing[char.name]}\n`;
                characterPrompts += `  â†’ This character must look IDENTICAL in every scene\n\n`;
              });

              characterPrompts += `\nCRITICAL: These characters must maintain PERFECT visual consistency across ALL pages. Use the exact same facial features, hair style, body proportions, and identifying characteristics every single time.`;
            }

            // Get short scene description from outline if available
            const shortSceneDesc = shortSceneDescriptions[scene.pageNumber];

            // Get the selected art style's prompt
            const selectedStyle = artStyles.find(s => s.id === artStyle) || artStyles[0];
            const styleDescription = selectedStyle.prompt;

            // Build image prompt with character consistency guide - ONLY use the detailed scene description
            let imagePrompt = `Create a cinematic scene in ${styleDescription}.

Scene Description: ${scene.description}
${characterPrompts}`;

            // Add character consistency guide if available
            if (characterConsistencyGuide) {
              imagePrompt += characterConsistencyGuide;
            }

            imagePrompt += `\n\nImportant:
- Show only the emotions visible on faces (happy, sad, surprised, worried, excited)
- Keep clothing exactly as described
- Maintain consistent character appearance across ALL pages
- Clean, clear composition`;

            // Store the prompt for this image
            prompts[scene.pageNumber] = imagePrompt;

            try {
              // Collect avatar images for characters in this scene
              const characterAvatars = charactersInScene
                .filter(char => char.photoUrl)
                .map(char => char.photoUrl);

              const safePrompt = `CHILDREN'S BOOK ILLUSTRATION - Safe, family-friendly content.

${imagePrompt}

IMPORTANT: This is a wholesome children's storybook illustration. All content is innocent and age-appropriate.`;

              let imageData;
              if (characterAvatars.length > 0) {
                // Send with avatar images for better consistency
                console.log(`Page ${scene.pageNumber}: Generating with ${characterAvatars.length} avatar(s) for consistency...`);
                imageData = await callGeminiAPIWithImages(safePrompt, characterAvatars, scene.pageNumber);
              } else {
                // Text-only if no avatars available
                console.log(`Page ${scene.pageNumber}: Generating with text-only prompt...`);
                imageData = await callGeminiAPIWithLogging(safePrompt, null, scene.pageNumber);
              }
              console.log(`Page ${scene.pageNumber}: Success!`);

              return {
                pageNumber: scene.pageNumber,
                imageData: imageData,
                description: scene.description
              };
            } catch (error) {
              console.error(`Error generating image for page ${scene.pageNumber}:`, error);
              // Continue with other images even if one fails
              return {
                pageNumber: scene.pageNumber,
                imageData: null,
                error: error.message
              };
            }
          });

          // Wait for all images to complete in parallel
          const images = await Promise.all(imagePromises);

          setSceneImages(images);
          setImagePrompts(prompts); // Save the prompts

          // Generate cover images in parallel
          console.log('Generating 3 cover images...');
          const selectedStyle = artStyles.find(s => s.id === artStyle) || artStyles[0];
          const styleDescription = selectedStyle.prompt;

          // Build character information for cover images
          const coverCharacterImages = [];
          const coverCharacterImageMap = [];
          let characterInfo = '';

          if (characters.length > 0) {
            characterInfo = '\n\nThe cover MUST feature the following characters:\n';

            characters.forEach((char, idx) => {
              const imageRef = char.photoUrl ? ` [Reference Image ${coverCharacterImages.length + 1}]` : '';
              characterInfo += `Character ${idx + 1} (${char.name})${imageRef}: ${char.age} years old, ${char.height}, ${char.build}. ${char.traits}.\n`;

              // Collect character images
              if (char.photoUrl) {
                coverCharacterImages.push(char.photoUrl);
                coverCharacterImageMap.push({ name: char.name, imageIndex: coverCharacterImages.length });
              }
            });

            // Add image reference explanation if we have character images
            if (coverCharacterImageMap.length > 0) {
              characterInfo += '\n**CHARACTER REFERENCE IMAGES:**\n';
              coverCharacterImageMap.forEach((mapping) => {
                characterInfo += `- Image ${mapping.imageIndex}: ${mapping.name}'s portrait (use for facial features, appearance consistency)\n`;
              });
            }
          }

          // Use scene descriptions from outline if available, otherwise use defaults
          // NOTE: Use local 'coverScenes' variable instead of state to avoid async timing issues
          const titlePageScene = coverScenes.titlePage || `A beautiful, magical title page featuring the main characters. Decorative elements that reflect the story's theme with space for the title text.`;
          const page0Scene = coverScenes.page0 || `A warm, inviting dedication/introduction page that sets the mood and welcomes readers.`;
          const backCoverScene = coverScenes.backCover || `A satisfying, conclusive ending scene that provides closure and leaves readers with a warm feeling.`;

          // Define cover image prompts with scene descriptions from outline
          const frontCoverPrompt = `${titlePageScene}\n\nStyle: ${styleDescription}.${characterInfo}\n\nCreate this as a beautiful title page for the children's book "${storyTitle}". Magical and inviting.`;
          const page0Prompt = `${page0Scene}\n\nStyle: ${styleDescription}.${characterInfo}\n\nCreate this as the dedication/introduction page for "${storyTitle}".`;
          const backCoverPrompt = `${backCoverScene}\n\nStyle: ${styleDescription}.${characterInfo}\n\nCreate this as the back cover illustration for "${storyTitle}".\n\nIMPORTANT: Include the text "magicalstory.ch" in small, elegant letters in the bottom left corner of the image.`;

          // Define detailed cover scene descriptions for display
          const coverDescriptions = {
            frontCover: `**Title Page / Front Cover**\n\n${titlePageScene}`,
            page0: `**Page 0 - Dedication/Introduction**\n\n${page0Scene}`,
            backCover: `**Back Cover**\n\n${backCoverScene}`
          };

          const generateCoverImage = async (coverType, prompt, charImages = []) => {
            try {
              let imageData = null;

              // If we have character images, use multi-part API call
              if (charImages.length > 0) {
                const parts = [{ text: prompt }];

                charImages.forEach(charImage => {
                  const base64Data = charImage.replace(/^data:image\/\w+;base64,/, '');
                  const mimeType = charImage.match(/^data:(image\/\w+);base64,/) ?
                    charImage.match(/^data:(image\/\w+);base64,/)[1] : 'image/png';

                  parts.push({
                    inlineData: {
                      mimeType: mimeType,
                      data: base64Data
                    }
                  });
                });

                const apiPayload = {
                  model: 'gemini-2.5-flash-image',
                  contents: [{ parts }],
                  safetySettings: [
                    { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_ONLY_HIGH" },
                    { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_ONLY_HIGH" },
                    { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_ONLY_HIGH" },
                    { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_ONLY_HIGH" }
                  ]
                };

                const response = await fetch(`${API_URL}/api/gemini`, {
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${localStorage.getItem('auth_token')}`
                  },
                  body: JSON.stringify(apiPayload)
                });

                if (!response.ok) throw new Error(`API Error: ${response.status}`);

                const data = await response.json();
                if (!data.candidates || data.candidates.length === 0) {
                  throw new Error("No response from Gemini.");
                }

                const candidate = data.candidates[0];
                if (candidate.finishReason && candidate.finishReason !== 'STOP') {
                  throw new Error(`Content blocked: ${candidate.finishReason}.`);
                }

                if (!candidate.content || !candidate.content.parts) {
                  throw new Error("Invalid response from Gemini.");
                }

                const responseParts = candidate.content.parts;
                for (const part of responseParts) {
                  if (part.inlineData && part.inlineData.data) {
                    imageData = `data:image/png;base64,${part.inlineData.data}`;
                    break;
                  }
                }

                if (!imageData) throw new Error("No image data found in response.");
              } else {
                // No character images, use simple text-only API call
                imageData = await callGeminiAPI(prompt);
              }

              return imageData;
            } catch (error) {
              console.error(`Error generating ${coverType} cover:`, error);
              return null;
            }
          };

          const coverPromises = [
            generateCoverImage('frontCover', frontCoverPrompt, coverCharacterImages),
            generateCoverImage('page0', page0Prompt, coverCharacterImages),
            generateCoverImage('backCover', backCoverPrompt, coverCharacterImages)
          ];

          const [frontCover, page0, backCover] = await Promise.all(coverPromises);

          // Store cover image prompts
          setCoverImagePrompts({
            frontCover: frontCoverPrompt,
            page0: page0Prompt,
            backCover: backCoverPrompt
          });

          // Store cover image API calls for debugging
          setCoverImageApiCalls({
            frontCover: { type: 'image', model: 'gemini-2.0-flash-exp', prompt: frontCoverPrompt },
            page0: { type: 'image', model: 'gemini-2.0-flash-exp', prompt: page0Prompt },
            backCover: { type: 'image', model: 'gemini-2.0-flash-exp', prompt: backCoverPrompt }
          });

          setCoverImages({
            frontCover,
            page0,
            backCover,
            descriptions: coverDescriptions
          });
          console.log('Cover images generated with full scene descriptions and prompts stored');

          setGenerationProgress({ current: scenesToGenerate.length, total: scenesToGenerate.length, message: 'All images generated!' });
        } catch (error) {
          console.error('Error generating images:', error);
          alert(`Error generating images: ${error.message}\n\nPlease check your Gemini API key and try again!`);
        } finally {
          setIsGeneratingImages(false);
          setTimeout(() => setGenerationProgress({ current: 0, total: 0, message: '' }), 2000);
        }
      };

      // Helper function to generate a single avatar variant
      const generateSingleAvatar = async (referenceImage, prompt) => {
        const base64Data = referenceImage.replace(/^data:image\/\w+;base64,/, '');
        const mimeType = referenceImage.match(/^data:(image\/\w+);base64,/) ?
          referenceImage.match(/^data:(image\/\w+);base64,/)[1] : 'image/png';

        // Call backend API endpoint which has the Gemini API key
        const response = await fetch(`${API_URL}/api/gemini`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${localStorage.getItem('auth_token')}`
          },
          body: JSON.stringify({
            model: 'gemini-2.5-flash-image',
            contents: [{
              parts: [
                { text: prompt },
                { inlineData: { mimeType: mimeType, data: base64Data } }
              ]
            }],
            safetySettings: [
              { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_ONLY_HIGH" },
              { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_ONLY_HIGH" },
              { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_ONLY_HIGH" },
              { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_ONLY_HIGH" }
            ]
          })
        });

        if (!response.ok) {
          const errorText = await response.text();
          throw new Error(`Gemini API Error: ${response.status} - ${errorText}`);
        }

        const data = await response.json();

        if (!data.candidates || data.candidates.length === 0) {
          console.error('Gemini API response:', data);
          throw new Error("No response from Gemini.");
        }

        const candidate = data.candidates[0];
        if (candidate.finishReason && candidate.finishReason !== 'STOP') {
          console.error('Gemini blocked content:', candidate);
          throw new Error(`Content blocked: ${candidate.finishReason}.`);
        }

        if (!candidate.content || !candidate.content.parts) {
          console.error('Invalid response structure:', candidate);
          throw new Error("Invalid response from Gemini.");
        }

        const parts = candidate.content.parts;
        for (const part of parts) {
          if (part.inlineData && part.inlineData.data) {
            return `data:image/png;base64,${part.inlineData.data}`;
          }
        }

        throw new Error("No image data found in response.");
      };

      const generateAvatar = async (referenceImage) => {
        setIsGeneratingAvatar(true);
        setGeneratedAvatar(null);
        setGeneratedAvatars([]);

        try {
          // Get the selected art style's prompt
          const selectedStyle = artStyles.find(s => s.id === artStyle) || artStyles[0];
          const baseStyle = selectedStyle.prompt;

          // Use same prompt for all 3 variants - AI will naturally create variations
          const avatarPromptText = `Create an upper body portrait of this person in ${baseStyle}. Show the person from waist up, including their clothing and upper body, with a friendly, pleasant expression. Maintain their age, gender, distinctive facial features, and clothing style.`;

          // Generate all 3 variants in parallel (much faster!)
          setGenerationProgress({
            current: 1,
            total: 3,
            message: `Generating 3 avatar variants in parallel...`
          });

          // Create 3 promises for parallel generation
          const generationPromises = Array.from({ length: 3 }, async (_, i) => {
            const avatarImage = await generateSingleAvatar(referenceImage, avatarPromptText);
            const traits = await analyzeImageForTraits(avatarImage);

            return {
              type: `Variant ${i + 1}`,
              image: avatarImage,
              traits: traits,
              prompt: avatarPromptText
            };
          });

          // Wait for all 3 to complete
          const generatedVariants = await Promise.all(generationPromises);

          setGeneratedAvatars(generatedVariants);
          setAvatarPrompt(avatarPromptText); // Store prompt for reference
          setGenerationProgress({ current: 3, total: 3, message: 'All avatars generated!' });

        } catch (error) {
          console.error('Avatar Generation Error:', error);
          alert(`Error generating avatar: ${error.message}`);
          setGeneratedAvatars([]);
        } finally {
          setIsGeneratingAvatar(false);
          setTimeout(() => setGenerationProgress({ current: 0, total: 0, message: '' }), 2000);
        }
      };

      const editImage = async (currentImage, editInstruction) => {
        try {
          const base64Data = currentImage.replace(/^data:image\/\w+;base64,/, '');
          const mimeType = currentImage.match(/^data:(image\/\w+);base64,/) ?
            currentImage.match(/^data:(image\/\w+);base64,/)[1] : 'image/png';

          const finalPrompt = `Edit this scene: ${editInstruction}. Maintain the same 3D Pixar/Disney animation style, character appearances, and overall art style.`;

          // Call backend API endpoint which has the Gemini API key
          const response = await fetch(`${API_URL}/api/gemini`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${localStorage.getItem('auth_token')}`
            },
            body: JSON.stringify({
              model: 'gemini-2.5-flash-image',
              contents: [{
                parts: [
                  {
                    text: finalPrompt,
                  },
                  {
                    inlineData: {
                      mimeType: mimeType,
                      data: base64Data,
                    },
                  },
                ],
              }],
              safetySettings: [
                { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_ONLY_HIGH" },
                { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_ONLY_HIGH" },
                { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_ONLY_HIGH" },
                { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_ONLY_HIGH" }
              ]
            })
          });

          if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Image editing failed: ${response.status} - ${errorText}`);
          }

          const data = await response.json();

          if (!data.candidates || data.candidates.length === 0) {
            console.error('Gemini API response:', data);
            throw new Error("No response from Gemini. The content may have been blocked for safety reasons.");
          }

          // Check for safety blocks or other finish reasons
          const candidate = data.candidates[0];
          if (candidate.finishReason && candidate.finishReason !== 'STOP') {
            console.error('Gemini blocked content:', candidate);
            throw new Error(`Content blocked: ${candidate.finishReason}. Try adjusting your edit instruction.`);
          }

          if (!candidate.content || !candidate.content.parts) {
            console.error('Invalid response structure:', candidate);
            throw new Error("Invalid response from Gemini. Content may have been filtered.");
          }

          const parts = candidate.content.parts;
          for (const part of parts) {
            if (part.inlineData && part.inlineData.data) {
              return `data:image/png;base64,${part.inlineData.data}`;
            }
          }

          throw new Error("No image data found in response.");
        } catch (error) {
          console.error('Image Editing Error:', error);
          throw error;
        }
      };

      const analyzeImageForTraits = async (imageData) => {
        try {
          console.log('ðŸ” Analyzing photo with Gemini API...');

          // Use Gemini API directly for feature extraction
          return await analyzeImageForTraitsGemini(imageData);
        } catch (error) {
          console.error('Error analyzing image:', error);
          return null;
        }
      };

      // Gemini-based character photo analysis
      const analyzeImageForTraitsGemini = async (imageData) => {
        try {
          const base64Data = imageData.replace(/^data:image\/\w+;base64,/, '');
          const mimeType = imageData.match(/^data:(image\/\w+);base64,/) ?
            imageData.match(/^data:(image\/\w+);base64,/)[1] : 'image/png';

          // Call backend API endpoint which has the Gemini API key
          const response = await fetch(`${API_URL}/api/gemini`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${localStorage.getItem('auth_token')}`
            },
            body: JSON.stringify({
              model: 'gemini-2.5-flash',
              contents: [{
                parts: [
                  {
                    text: `Analyze this character image and provide a concise set of physical attributes.
                    Specifically list:
                    1. Age (just a number)
                    2. Estimated Height in centimeters
                    3. Build (slim/average/athletic/chubby/overweight/heavily overweight)
                    4. Hair style/color
                    5. Clothing style (describe what they're wearing: type of garment, colors, style)
                    6. Other distinctive features (eye color, glasses, facial features, etc.)
                    Return the response in this exact format:
                    Age: [number]
                    Height: [number] cm
                    Build: [description]
                    Hair: [description]
                    Clothing: [description]
                    Features: [description]`
                  },
                  {
                    inlineData: {
                      mimeType: mimeType,
                      data: base64Data,
                    },
                  },
                ],
              }]
            })
          });

          if (!response.ok) {
            console.error('Image analysis failed');
            return null;
          }

          const data = await response.json();

          if (data.candidates && data.candidates[0]) {
            const analysisText = data.candidates[0].content.parts[0].text;
            console.log('Image analysis:', analysisText);

            // Parse the analysis to extract age, height, build, hair, clothing, and features
            const traits = {
              age: '',
              height: '',
              build: '',
              hairColor: '',
              clothing: '',
              otherFeatures: '',
              fullText: analysisText
            };

            const ageMatch = analysisText.match(/Age:\s*(\d+)/i);
            if (ageMatch) traits.age = ageMatch[1];

            const heightMatch = analysisText.match(/Height:\s*(\d+)\s*cm/i);
            if (heightMatch) traits.height = heightMatch[1];

            const buildMatch = analysisText.match(/Build:\s*([^\n]+)/i);
            if (buildMatch) traits.build = buildMatch[1].trim().toLowerCase();

            const hairMatch = analysisText.match(/Hair:\s*([^\n]+)/i);
            if (hairMatch) traits.hairColor = hairMatch[1].trim();

            const clothingMatch = analysisText.match(/Clothing:\s*([^\n]+)/i);
            if (clothingMatch) traits.clothing = clothingMatch[1].trim();

            const featuresMatch = analysisText.match(/Features:\s*([^\n]+)/i);
            if (featuresMatch) traits.otherFeatures = featuresMatch[1].trim();

            return traits;
          }

          return null;
        } catch (error) {
          console.error('Error analyzing image:', error);
          return null;
        }
      };

      const downloadImage = (imageData, pageNumber) => {
        try {
          const link = document.createElement('a');
          link.href = imageData;
          link.download = `scene-page-${pageNumber}-${Date.now()}.png`;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
        } catch (error) {
          console.error('Download error:', error);
          alert('Download error: ' + error.message);
        }
      };

      const downloadPrompt = () => {
        try {
          const promptTitle = `Prompt - ${storyTypes.find(t => t.id === storyType)?.name[language] || 'Story'} - ${new Date().toLocaleDateString()}`;
          const blob = new Blob([generatedPrompt], { type: 'text/plain;charset=utf-8' });
          const url = URL.createObjectURL(blob);
          const link = document.createElement('a');
          link.href = url;
          link.download = `${promptTitle}.txt`;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          URL.revokeObjectURL(url);
        } catch (error) {
          console.error('Download error:', error);
          alert('Download error: ' + error.message);
        }
      };

      const downloadStory = (format) => {
        try {
          const storyTitle = `${storyTypes.find(t => t.id === storyType)?.name[language] || 'Story'} - ${new Date().toLocaleDateString()}`;

          if (format === 'txt') {
            const blob = new Blob([generatedStory], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `${storyTitle}.txt`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
          } else if (format === 'pdf') {
            const printWindow = window.open('', '_blank', 'width=800,height=600');
            if (printWindow) {
              const htmlContent = `<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>${storyTitle}</title>
    <style>
      body { font-family: Arial, sans-serif; padding: 40px; line-height: 1.6; }
      h1 { color: #7c3aed; margin-bottom: 20px; }
      p { margin-bottom: 10px; white-space: pre-wrap; }
    </style>
  </head>
  <body>
    <h1>${storyTitle}</h1>
    <p>${generatedStory.replace(/\n/g, '<br>')}</p>
  </body>
</html>`;
              printWindow.document.write(htmlContent);
              printWindow.document.close();
              setTimeout(() => {
                printWindow.print();
              }, 500);
            } else {
              alert('Popup blocked. Please allow popups.');
            }
          }
        } catch (error) {
          console.error('Download error:', error);
          alert('Download error: ' + error.message);
        }
      };

      const downloadPrintablePDF = async () => {
        try {
          const storyTitle = `${storyTypes.find(t => t.id === storyType)?.name[language] || 'Story'}`;
          const pageMatches = generatedStory ? generatedStory.split(/---\s*Page\s+\d+\s*---/i) : [];
          const storyPages = pageMatches.slice(1).filter(p => p.trim().length > 0);

          // Create a temporary container for PDF generation
          const tempContainer = document.createElement('div');
          tempContainer.style.position = 'absolute';
          tempContainer.style.left = '-9999px';
          tempContainer.style.top = '0';
          document.body.appendChild(tempContainer);

          // Build HTML content for PDF
          let htmlContent = `
            <div style="font-family: 'Georgia', 'Times New Roman', serif; font-size: 14pt; line-height: 1.6;">
          `;

          // Alternate between text and images
          storyPages.forEach((pageText, index) => {
            const pageNumber = index + 1;
            const image = sceneImages.find(img => img.pageNumber === pageNumber);

            // Text page
            htmlContent += `
              <div style="width: 210mm; height: 210mm; display: flex; justify-content: center; align-items: center; padding: 20mm; background: #fffef8; page-break-after: always;">
                <div style="text-align: center; white-space: pre-wrap; max-width: 100%; font-size: 14pt; line-height: 1.8; color: #333;">
                  ${pageText.trim()}
                </div>
              </div>
            `;

            // Image page
            if (image && image.imageData) {
              htmlContent += `
                <div style="width: 210mm; height: 210mm; display: flex; justify-content: center; align-items: center; background: white; page-break-after: always; padding: 10mm;">
                  <img src="${image.imageData}" style="width: 100%; height: 100%; object-fit: contain; border-radius: 8px;" />
                </div>
              `;
            }
          });

          htmlContent += '</div>';
          tempContainer.innerHTML = htmlContent;

          // Configure PDF options
          const opt = {
            margin: 0,
            filename: `${storyTitle}.pdf`,
            image: { type: 'jpeg', quality: 0.98 },
            html2canvas: { scale: 2, useCORS: true },
            jsPDF: { unit: 'mm', format: [210, 210], orientation: 'portrait' }
          };

          // Generate and download PDF
          await html2pdf().set(opt).from(tempContainer).save();

          // Clean up
          document.body.removeChild(tempContainer);
        } catch (error) {
          console.error('PDF export error:', error);
          alert('PDF export error: ' + error.message);
        }
      };

      const orderPrintedBook = async () => {
        try {
          // Check if story has all required content
          if (!generatedStory || sceneImages.length === 0) {
            alert(language === 'de'
              ? 'Bitte generieren Sie zuerst die Geschichte und Bilder'
              : language === 'fr'
              ? 'Veuillez d\'abord gÃ©nÃ©rer l\'histoire et les images'
              : 'Please generate the story and images first');
            return;
          }

          // Check minimum page count for Gelato printing
          // Minimum 28 Gelato pages = 14 scenes * 2 (covers NOT counted by Gelato)
          const minimumScenes = 14;
          const gelatoPages = pages * 2;

          if (pages < minimumScenes) {
            alert(language === 'de'
              ? `Gedruckte BÃ¼cher benÃ¶tigen mindestens ${minimumScenes} Szenen (${minimumScenes * 2} Gelato-Seiten). Ihre Geschichte hat ${pages} Szenen (${gelatoPages} Gelato-Seiten).\n\nBitte erstellen Sie eine neue Geschichte mit mindestens ${minimumScenes} Szenen oder laden Sie die Geschichte als PDF herunter.`
              : language === 'fr'
              ? `Les livres imprimÃ©s nÃ©cessitent au moins ${minimumScenes} scÃ¨nes (${minimumScenes * 2} pages Gelato). Votre histoire a ${pages} scÃ¨nes (${gelatoPages} pages Gelato).\n\nVeuillez crÃ©er une nouvelle histoire avec au moins ${minimumScenes} scÃ¨nes ou tÃ©lÃ©charger l'histoire en PDF.`
              : `Printed books require at least ${minimumScenes} scenes (${minimumScenes * 2} Gelato pages). Your story has ${pages} scenes (${gelatoPages} Gelato pages).\n\nPlease create a new story with at least ${minimumScenes} scenes or download the story as PDF.`);
            return;
          }

          // Load saved shipping info from database
          try {
            const response = await fetch(`${API_URL}/api/user/shipping-address`, {
              headers: { 'Authorization': `Bearer ${authToken}` }
            });

            if (response.ok) {
              const savedShipping = await response.json();
              if (savedShipping) {
                setShippingForm({
                  firstName: savedShipping.firstName || '',
                  lastName: savedShipping.lastName || '',
                  addressLine1: savedShipping.addressLine1 || '',
                  city: savedShipping.city || '',
                  postCode: savedShipping.postCode || '',
                  country: savedShipping.country || '',
                  email: savedShipping.email || currentUser?.username || ''
                });
              } else {
                // No saved shipping info, just pre-fill email
                setShippingForm(prev => ({
                  ...prev,
                  email: currentUser?.username || currentUser?.email || ''
                }));
              }
            } else {
              // Error loading, just pre-fill email
              setShippingForm(prev => ({
                ...prev,
                email: currentUser?.username || currentUser?.email || ''
              }));
            }
          } catch (err) {
            console.error('Error loading shipping address:', err);
            // Just pre-fill email on error
            setShippingForm(prev => ({
              ...prev,
              email: currentUser?.username || currentUser?.email || ''
            }));
          }

          setEmailChanged(false);
          setShowShippingModal(true);
        } catch (error) {
          console.error('Print book error:', error);
          alert(language === 'de'
            ? 'Fehler beim Erstellen der Druckbestellung'
            : language === 'fr'
            ? 'Erreur lors de la crÃ©ation de la commande d\'impression'
            : 'Error creating print order');
        }
      };

      const submitPrintOrder = async () => {
        try {
          const shippingAddress = {
            firstName: shippingForm.firstName,
            lastName: shippingForm.lastName,
            addressLine1: shippingForm.addressLine1,
            city: shippingForm.city,
            postCode: shippingForm.postCode,
            country: shippingForm.country.toUpperCase(),
            email: shippingForm.email
          };

          // Save shipping address to database for future orders
          try {
            await fetch(`${API_URL}/api/user/shipping-address`, {
              method: 'PUT',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${authToken}`
              },
              body: JSON.stringify(shippingAddress)
            });
          } catch (err) {
            console.error('Error saving shipping address:', err);
            // Continue even if save fails
          }

          // If email changed, update user account
          if (emailChanged && shippingForm.email !== currentUser?.username) {
            const updateResponse = await fetch(`${API_URL}/api/user/update-email`, {
              method: 'PUT',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${authToken}`
              },
              body: JSON.stringify({ newEmail: shippingForm.email })
            });

            if (updateResponse.ok) {
              const updatedUser = await updateResponse.json();
              setCurrentUser(prev => ({ ...prev, username: updatedUser.username }));
              alert(language === 'de'
                ? `E-Mail-Adresse auf ${shippingForm.email} aktualisiert`
                : language === 'fr'
                ? `Adresse e-mail mise Ã  jour en ${shippingForm.email}`
                : `Email address updated to ${shippingForm.email}`);
            } else {
              const errorData = await updateResponse.json();
              console.error('Failed to update email:', errorData);
              // Continue with order even if email update fails
            }
          }

          setShowShippingModal(false);

          // Step 1: Generate PDF on server
          alert(language === 'de'
            ? 'PDF wird generiert, bitte warten...'
            : language === 'fr'
            ? 'GÃ©nÃ©ration du PDF, veuillez patienter...'
            : 'Generating PDF, please wait...'
          );

          // Parse story pages from generatedStory
          const pageMatches = generatedStory.split(/---\s*Page\s+\d+\s*---/i);
          const storyPages = pageMatches.slice(1).filter(p => p.trim().length > 0).map((text, index) => ({
            pageNumber: index + 1,
            text: text.trim()
          }));

          const storyTitle = storyTypes.find(t => t.id === storyType)?.name[language] || 'Story';

          const pdfResponse = await fetch('/api/generate-pdf', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${authToken}`
            },
            body: JSON.stringify({
              storyId: currentStoryId || `story-${Date.now()}`,
              storyTitle: storyTitle,
              storyPages: storyPages,
              sceneImages: sceneImages,
              coverImages: coverImages
            })
          });

          const pdfData = await pdfResponse.json();

          if (!pdfResponse.ok) {
            throw new Error(pdfData.error || 'Failed to generate PDF');
          }

          console.log('PDF generated:', pdfData);

          // Step 2: Get product UID from backend (with fallback to default)
          // IMPORTANT: Gelato only counts story content pages (not covers)
          // - Each scene = 2 pages (1 text page + 1 image page)
          // - Covers (back, front, page 0) are NOT counted by Gelato
          const actualPdfPages = pages * 2;  // Gelato page count (story content only)
          let productUid;

          try {
            const productsResponse = await fetch(`${API_URL}/api/gelato/products`, {
              headers: { 'Authorization': `Bearer ${authToken}` }
            });

            if (productsResponse.ok) {
              const productsData = await productsResponse.json();
              const products = productsData.products || [];
              console.log('ðŸ“¦ Fetched Gelato products:', products.length, products);
              console.log('ðŸ“„ Story scenes:', pages, '(PDF pages:', actualPdfPages, ')');

              if (products.length > 0) {
                // Find product matching the ACTUAL PDF page count (scenes * 2)
                const matchingProduct = products.find(p => {
                  console.log(`ðŸ” Checking product: ${p.product_name}, min: ${p.min_pages}, max: ${p.max_pages}, available: ${p.available_page_counts}`);
                  // Check if available_page_counts array includes our page count
                  if (p.available_page_counts) {
                    const availableCounts = JSON.parse(p.available_page_counts || '[]');
                    console.log(`  Available counts:`, availableCounts, `Looking for: ${actualPdfPages}`, `Match: ${availableCounts.includes(actualPdfPages)}`);
                    return availableCounts.includes(actualPdfPages);
                  }
                  // Fallback: check min/max range
                  const inRange = actualPdfPages >= (p.min_pages || 0) && actualPdfPages <= (p.max_pages || 999);
                  console.log(`  Range check: ${inRange}`);
                  return inRange;
                });

                productUid = matchingProduct?.product_uid;
                console.log('âœ… Selected product:', matchingProduct?.product_name, 'UID:', productUid);
                if (!matchingProduct) {
                  console.error('âŒ No product matches PDF page count:', actualPdfPages);
                }
              } else {
                console.error('âŒ No products in database!');
              }
            }
          } catch (err) {
            console.warn('Failed to fetch products, will use default:', err.message);
          }

          // Fallback to default Gelato product UID from environment
          if (!productUid) {
            // Get default product UID from backend
            try {
              const configResponse = await fetch(`${API_URL}/api/config/gelato-product-uid`, {
                headers: { 'Authorization': `Bearer ${authToken}` }
              });

              if (configResponse.ok) {
                const configData = await configResponse.json();
                productUid = configData.productUid;
                console.log('Using default product UID from config:', productUid);
              }
            } catch (err) {
              console.error('Failed to get default product UID:', err);
            }
          }

          // Final check - error if still no product UID
          if (!productUid) {
            throw new Error(language === 'de'
              ? `Kein Gelato-Produkt konfiguriert. Bitte kontaktieren Sie den Support.`
              : language === 'fr'
              ? `Aucun produit Gelato configurÃ©. Veuillez contacter le support.`
              : `No Gelato product configured. Please contact support.`);
          }

          // Step 3: Create Gelato order with PDF URL
          const gelatoResponse = await fetch('/api/gelato/order', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${authToken}`
            },
            body: JSON.stringify({
              pdfUrl: pdfData.fileUrl,
              shippingAddress: shippingAddress,
              orderReference: `story-${Date.now()}`,
              productUid: productUid,
              pageCount: actualPdfPages  // Use actual PDF pages (scenes * 2)
            })
          });

          const gelatoData = await gelatoResponse.json();

          if (gelatoResponse.ok) {
            // Show custom modal instead of alert
            setOrderData({
              orderId: gelatoData.orderId,
              dashboardUrl: gelatoData.dashboardUrl,
              pdfUrl: pdfData.fileUrl,
              pdfFilename: pdfData.filename,
              isDraft: gelatoData.isDraft,
              previewUrls: gelatoData.previewUrls || [],
              email: shippingAddress.email
            });
            setShowOrderModal(true);
          } else {
            // PDF was generated but Gelato order failed
            if (gelatoData.setupUrl) {
              alert(language === 'de'
                ? `PDF wurde erstellt, aber Gelato ist nicht konfiguriert.\n\nPDF-Link: ${pdfData.fileUrl}\n\nBitte konfigurieren Sie Gelato unter: ${gelatoData.setupUrl}`
                : language === 'fr'
                ? `PDF crÃ©Ã©, mais Gelato n'est pas configurÃ©.\n\nLien PDF: ${pdfData.fileUrl}\n\nVeuillez configurer Gelato sur: ${gelatoData.setupUrl}`
                : `PDF generated, but Gelato is not configured.\n\nPDF URL: ${pdfData.fileUrl}\n\nPlease configure Gelato at: ${gelatoData.setupUrl}`
              );
            } else {
              throw new Error(gelatoData.error || 'Failed to create Gelato order');
            }
          }

        } catch (error) {
          console.error('Print book error:', error);
          alert(language === 'de'
            ? 'Fehler beim Erstellen der Druckbestellung: ' + error.message
            : language === 'fr'
            ? 'Erreur lors de la crÃ©ation de la commande d\'impression: ' + error.message
            : 'Error creating print order: ' + error.message
          );
        }
      };

      const exportStoryInfoAsMarkdown = () => {
        try {
          const storyTypeName = allStoryTypes.find(t => t.id === storyType);
          const storyTypeLabel = storyTypeName ? storyTypeName.name[language] : 'Unknown';
          const storyEmoji = storyTypeName ? storyTypeName.emoji : '';

          let markdown = `# Story Configuration\n\n`;
          markdown += `## Story Type\n`;
          markdown += `- **Type**: ${storyEmoji} ${storyTypeLabel}\n\n`;

          if (storyDetails) {
            markdown += `## Additional Story Details\n\n`;
            markdown += `${storyDetails}\n\n`;
          }

          markdown += `## Characters\n\n`;
          characters.forEach((char, index) => {
            const isMain = mainCharacters.includes(char.id);
            markdown += `### ${index + 1}. ${char.name}${isMain ? ' â­ (Main Character)' : ''}\n\n`;
            markdown += `- **Gender**: ${char.gender === 'male' ? t.male : char.gender === 'female' ? t.female : t.other}\n`;
            markdown += `- **Age**: ${char.age} ${language === 'de' ? 'Jahre' : language === 'fr' ? 'ans' : 'years'}\n`;
            if (char.hairColor) {
              markdown += `- **Hair Color**: ${char.hairColor}\n`;
            }
            if (char.otherFeatures) {
              markdown += `- **Other Features**: ${char.otherFeatures}\n`;
            }
            markdown += `- **Strengths**: ${char.strengths.join(', ')}\n`;
            markdown += `- **Weaknesses**: ${char.weaknesses.join(', ')}\n`;
            if (char.fears && char.fears.length > 0) {
              markdown += `- **Fears**: ${char.fears.join(', ')}\n`;
            }
            if (char.specialDetails) {
              markdown += `- **Special Details**: ${char.specialDetails}\n`;
            }
            markdown += `\n`;
          });

          if (Object.keys(relationships).length > 0) {
            markdown += `## Relationships\n\n`;
            const processedPairs = new Set();
            Object.entries(relationships).forEach(([key, type]) => {
              const [char1Id, char2Id] = key.split('-').map(Number);
              const pairKey = [char1Id, char2Id].sort().join('-');

              if (!processedPairs.has(pairKey) && type !== 'Not Known to') {
                const char1 = characters.find(c => c.id === char1Id);
                const char2 = characters.find(c => c.id === char2Id);
                if (char1 && char2) {
                  markdown += `- **${char1.name}** ${t.is} **${type}** **${char2.name}**\n`;
                  processedPairs.add(pairKey);
                }
              }
            });
            markdown += `\n`;
          }

          markdown += `## Story Settings\n\n`;
          markdown += `- **Number of Pages**: ${pages}\n`;
          markdown += `- **Reading Level**: ${languageLevel === '1st-grade' ? t.firstGrade : languageLevel === 'standard' ? t.standard : t.advanced}\n`;
          markdown += `- **Language**: ${language === 'de' ? 'German (Deutsch)' : language === 'fr' ? 'French (FranÃ§ais)' : 'English'}\n`;

          const blob = new Blob([markdown], { type: 'text/markdown;charset=utf-8' });
          const url = URL.createObjectURL(blob);
          const link = document.createElement('a');
          link.href = url;
          link.download = `story-info-${storyTypeLabel.replace(/\s+/g, '-')}-${Date.now()}.md`;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          URL.revokeObjectURL(url);
        } catch (error) {
          console.error('Export markdown error:', error);
          alert('Export markdown error: ' + error.message);
        }
      };

      const exportConfiguration = () => {
        try {
          const config = {
            version: '1.0',
            language,
            storyType,
            storyDetails,
            characters: characters.map(char => ({
              id: char.id,
              name: char.name,
              photoUrl: char.photoUrl || null,
              gender: char.gender,
              age: char.age,
              hairColor: char.hairColor || '',
              otherFeatures: char.otherFeatures || '',
              strengths: char.strengths,
              weaknesses: char.weaknesses,
              specialDetails: char.specialDetails || '',
              fears: char.fears
            })),
            customStrengths,
            customWeaknesses,
            customFears,
            customRelationships,
            customStoryTypes,
            relationships,
            pages,
            languageLevel,
            mainCharacters
          };

          const jsonString = JSON.stringify(config, null, 2);
          const blob = new Blob([jsonString], { type: 'application/json' });
          const url = URL.createObjectURL(blob);
          const link = document.createElement('a');
          link.href = url;
          link.download = `story-config-${Date.now()}.json`;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          URL.revokeObjectURL(url);
        } catch (error) {
          console.error('Export error:', error);
          alert('Export error: ' + error.message);
        }
      };

      const parseMarkdownConfig = (mdContent) => {
        const config = {
          language: 'en',
          storyType: '',
          storyDetails: '',
          characters: [],
          relationships: {},
          pages: 5,
          languageLevel: 'standard',
          mainCharacters: []
        };

        // Parse language
        if (mdContent.includes('German (Deutsch)')) config.language = 'de';
        else if (mdContent.includes('French (FranÃ§ais)')) config.language = 'fr';

        // Parse story type
        const storyTypeMatch = mdContent.match(/\*\*Type\*\*:\s*(.+?)\s+(.+)/);
        if (storyTypeMatch) {
          const emoji = storyTypeMatch[1].trim();
          const typeName = storyTypeMatch[2].trim();
          const foundType = allStoryTypes.find(t => t.emoji === emoji || t.name[config.language] === typeName);
          if (foundType) config.storyType = foundType.id;
        }

        // Parse additional story details
        const detailsMatch = mdContent.match(/## Additional Story Details\n\n([\s\S]*?)(?=\n##|$)/);
        if (detailsMatch) {
          config.storyDetails = detailsMatch[1].trim();
        }

        // Parse characters
        const charSections = mdContent.split(/###\s+\d+\.\s+/).slice(1);
        charSections.forEach((section) => {
          const lines = section.split('\n').filter(l => l.trim());
          if (lines.length === 0) return;

          const nameMatch = lines[0].match(/^(.+?)(?:\s+â­\s+\(Main Character\))?$/);
          if (!nameMatch) return;

          const char = {
            id: Date.now() + Math.random(),
            name: nameMatch[1].trim(),
            gender: 'other',
            age: '',
            hairColor: '',
            otherFeatures: '',
            strengths: [],
            weaknesses: [],
            fears: [],
            specialDetails: ''
          };

          const isMain = lines[0].includes('â­');
          if (isMain) config.mainCharacters.push(char.id);

          lines.forEach(line => {
            if (line.includes('**Gender**:')) {
              const gender = line.split(':')[1].trim().toLowerCase();
              if (gender.includes('male') && !gender.includes('female')) char.gender = 'male';
              else if (gender.includes('female')) char.gender = 'female';
            }
            else if (line.includes('**Age**:')) {
              char.age = line.split(':')[1].trim().split(' ')[0];
            }
            else if (line.includes('**Hair Color**:')) {
              char.hairColor = line.split(':')[1].trim();
            }
            else if (line.includes('**Other Features**:')) {
              char.otherFeatures = line.split(':')[1].trim();
            }
            else if (line.includes('**Strengths**:')) {
              char.strengths = line.split(':')[1].trim().split(',').map(s => s.trim());
            }
            else if (line.includes('**Weaknesses**:')) {
              char.weaknesses = line.split(':')[1].trim().split(',').map(s => s.trim());
            }
            else if (line.includes('**Fears**:')) {
              char.fears = line.split(':')[1].trim().split(',').map(s => s.trim());
            }
            else if (line.includes('**Special Details**:')) {
              char.specialDetails = line.split(':')[1].trim();
            }
          });

          config.characters.push(char);
        });

        // Parse relationships
        const relSection = mdContent.match(/## Relationships\n\n([\s\S]*?)(?=\n##|$)/);
        if (relSection) {
          const relLines = relSection[1].split('\n').filter(l => l.trim().startsWith('-'));
          relLines.forEach(line => {
            const match = line.match(/\*\*(.+?)\*\*\s+(.+?)\s+\*\*(.+?)\*\*\s+\*\*(.+?)\*\*/);
            if (match) {
              const char1Name = match[1].trim();
              const relType = match[3].trim();
              const char2Name = match[4].trim();

              const char1 = config.characters.find(c => c.name === char1Name);
              const char2 = config.characters.find(c => c.name === char2Name);

              if (char1 && char2) {
                config.relationships[`${char1.id}-${char2.id}`] = relType;
                // Also set reverse relationship
                const relTypeObj = relationshipTypes.find(r => r.value[config.language] === relType);
                if (relTypeObj) {
                  config.relationships[`${char2.id}-${char1.id}`] = relTypeObj.inverse[config.language];
                } else {
                  config.relationships[`${char2.id}-${char1.id}`] = relType;
                }
              }
            }
          });
        }

        // Parse settings
        const pagesMatch = mdContent.match(/\*\*Number of Pages\*\*:\s*(\d+)/);
        if (pagesMatch) config.pages = parseInt(pagesMatch[1]);

        const levelMatch = mdContent.match(/\*\*Reading Level\*\*:\s*(.+)/);
        if (levelMatch) {
          const level = levelMatch[1].trim();
          if (level.includes('1st') || level.includes('1Ã¨re') || level.includes('1.')) {
            config.languageLevel = '1st-grade';
          } else if (level.includes('Advanced') || level.includes('AvancÃ©') || level.includes('Fortgeschritten')) {
            config.languageLevel = 'advanced';
          } else {
            config.languageLevel = 'standard';
          }
        }

        return config;
      };

      const importConfiguration = (e) => {
        const file = e.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = (event) => {
            try {
              const content = event.target.result;
              let config;

              // Detect file type
              if (file.name.endsWith('.md')) {
                config = parseMarkdownConfig(content);
              } else {
                config = JSON.parse(content);
              }

              setLanguage(config.language || 'en');
              setStoryType(config.storyType || '');
              setStoryDetails(config.storyDetails || '');
              setCharacters(config.characters || []);
              setCustomStrengths(config.customStrengths || []);
              setCustomWeaknesses(config.customWeaknesses || []);
              setCustomFears(config.customFears || []);
              setCustomRelationships(config.customRelationships || []);
              setCustomStoryTypes(config.customStoryTypes || []);
              setRelationships(config.relationships || {});
              setPages(config.pages || 5);
              setLanguageLevel(config.languageLevel || 'standard');
              setMainCharacters(config.mainCharacters || []);
              setStep(1);
              alert('Configuration imported successfully!');
            } catch (error) {
              console.error('Import error:', error);
              alert('Error loading configuration file: ' + error.message);
            }
          };
          reader.readAsText(file);
        }
      };

      const startNewCharacter = () => {
        setCurrentCharacter({
          id: Date.now(),
          name: '',
          photo: null,
          photoUrl: null,
          useDescription: false,
          descriptionAge: '',
          hairColor: '',
          clothing: '',
          otherFeatures: '',
          gender: 'other',
          age: '',
          height: '',
          build: '',
          strengths: [],
          weaknesses: [],
          specialDetails: '',
          fears: []
        });
        setShowCharacterCreated(false);
        setGeneratedAvatar(null);
        setGeneratedAvatars([]);
        setAnalyzedTraitsText('');
        setUploadType('photo'); // Reset to photo upload mode
        setAvatarPrompt(''); // Clear avatar prompt
      };

      const editCharacter = (char) => {
        console.log('âœï¸ Editing character:', char);
        console.log('âœï¸ Character has photoUrl:', !!char.photoUrl);
        console.log('âœï¸ Character strengths:', char.strengths);
        console.log('âœï¸ Character weaknesses:', char.weaknesses);
        console.log('âœï¸ Character fears:', char.fears);

        // Extract custom attributes (not in default lists) and populate custom arrays
        // This ensures custom attributes show up as buttons in edit form
        const allDefaultStrengths = [...defaultStrengths.en, ...defaultStrengths.de, ...defaultStrengths.fr];
        const allDefaultWeaknesses = [...defaultWeaknesses.en, ...defaultWeaknesses.de, ...defaultWeaknesses.fr];
        const allDefaultFears = [...fearOptions.en, ...fearOptions.de, ...fearOptions.fr];

        const customStrs = (char.strengths || []).filter(s => !allDefaultStrengths.includes(s));
        const customWeaks = (char.weaknesses || []).filter(w => !allDefaultWeaknesses.includes(w));
        const customFrs = (char.fears || []).filter(f => !allDefaultFears.includes(f));

        // Merge with existing custom attributes (avoid duplicates)
        setCustomStrengths([...new Set([...customStrengths, ...customStrs])]);
        setCustomWeaknesses([...new Set([...customWeaknesses, ...customWeaks])]);
        setCustomFears([...new Set([...customFears, ...customFrs])]);

        // Store backup before editing
        setCharacterBackup(JSON.parse(JSON.stringify(char))); // Deep copy
        setCurrentCharacter(char);
        setCharacters(characters.filter(c => c.id !== char.id));
        setShowCharacterCreated(false);
        setGeneratedAvatar(null);
        setGeneratedAvatars([]);
        // Scroll to character form after state updates
        setTimeout(() => {
          if (characterFormRef.current) {
            characterFormRef.current.scrollIntoView({ behavior: 'smooth', block: 'start' });
          }
        }, 100);
      };

      const cancelEditCharacter = () => {
        if (characterBackup) {
          // Restore the backup
          setCharacters([...characters, characterBackup]);
          setCharacterBackup(null);
        }
        setCurrentCharacter(null);
        setShowCharacterCreated(false);
        setGeneratedAvatar(null);
        setGeneratedAvatars([]);
      };

      // Helper function to safely navigate between steps
      // Restores any character being edited before changing steps
      const safeSetStep = (newStep) => {
        // If a character is being edited, restore it first
        if (characterBackup) {
          console.log('âš ï¸ Character was being edited - restoring backup before navigation');
          setCharacters([...characters, characterBackup]);
          setCharacterBackup(null);
          setCurrentCharacter(null);
          setShowCharacterCreated(false);
          setGeneratedAvatar(null);
          setGeneratedAvatars([]);
        }
        setStep(newStep);
      };

      const deleteCharacter = (charId) => {
        if (confirm(t.deleteCharacter + '?')) {
          setCharacters(characters.filter(c => c.id !== charId));
          // Remove from main characters if present
          setMainCharacters(mainCharacters.filter(id => id !== charId));
          // Remove relationships involving this character
          const newRelationships = {};
          Object.keys(relationships).forEach(key => {
            if (!key.includes(charId.toString())) {
              newRelationships[key] = relationships[key];
            }
          });
          setRelationships(newRelationships);
        }
      };

      const saveCurrentCharacter = () => {
        if (currentCharacter.name &&
            currentCharacter.strengths && currentCharacter.strengths.length >= 3 &&
            currentCharacter.weaknesses && currentCharacter.weaknesses.length >= 2) {
          const updatedCharacters = [...characters, currentCharacter];
          setCharacters(updatedCharacters);

          // Auto-select main characters based on age
          autoSelectMainCharacters(updatedCharacters);

          setShowCharacterCreated(true);
          setCurrentCharacter(null);
          setCharacterBackup(null); // Clear backup after successful save

          // Scroll to top of page
          window.scrollTo({ top: 0, behavior: 'smooth' });
        }
      };

      const handlePhotoUpload = async (e) => {
        const file = e.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onloadend = async () => {
            const photoUrl = reader.result;

            // First update the photo
            setCurrentCharacter({
              ...currentCharacter,
              photo: file,
              photoUrl: photoUrl
            });
            setGeneratedAvatar(null);

            // Only analyze and auto-fill if it's a real photo (not a ready avatar)
            if (uploadType === 'photo') {
              const traits = await analyzeImageForTraits(photoUrl);
              if (traits) {
                setCurrentCharacter(prev => ({
                  ...prev,
                  gender: traits.gender || prev.gender,  // DeepFace extracts gender
                  age: traits.age || prev.age,
                  height: traits.height || prev.height,
                  build: traits.build || prev.build,
                  hairColor: traits.hairColor || prev.hairColor,
                  clothing: traits.clothing || prev.clothing,
                  otherFeatures: traits.otherFeatures || prev.otherFeatures
                }));
                // Store the full analyzed text for display
                if (traits.fullText) {
                  setAnalyzedTraitsText(traits.fullText);
                }
              }
            }
          };
          reader.readAsDataURL(file);
        }
      };

      const handleNameChange = (name) => {
        const detectedGender = detectGender(name);
        setCurrentCharacter({
          ...currentCharacter,
          name,
          gender: detectedGender
        });
      };

      const toggleArrayItem = (field, item) => {
        const currentArray = currentCharacter[field];
        const newArray = currentArray.includes(item)
          ? currentArray.filter(i => i !== item)
          : [...currentArray, item];
        setCurrentCharacter({ ...currentCharacter, [field]: newArray });
      };

      const addCustomStrength = () => {
        if (newStrength && !allStrengths.includes(newStrength)) {
          setCustomStrengths([...customStrengths, newStrength]);
          setCurrentCharacter({
            ...currentCharacter,
            strengths: [...currentCharacter.strengths, newStrength]
          });
          setNewStrength('');
        }
      };

      const addCustomWeakness = () => {
        if (newWeakness && !allWeaknesses.includes(newWeakness)) {
          setCustomWeaknesses([...customWeaknesses, newWeakness]);
          setCurrentCharacter({
            ...currentCharacter,
            weaknesses: [...currentCharacter.weaknesses, newWeakness]
          });
          setNewWeakness('');
        }
      };

      const addCustomFear = () => {
        if (newFear && !allFears.includes(newFear)) {
          setCustomFears([...customFears, newFear]);
          setCurrentCharacter({
            ...currentCharacter,
            fears: [...currentCharacter.fears, newFear]
          });
          setNewFear('');
        }
      };

      const addCustomRelationship = () => {
        if (newRelationship && !customRelationships.includes(newRelationship)) {
          setCustomRelationships([...customRelationships, newRelationship]);
          setNewRelationship('');
        }
      };

      const addCustomStoryType = () => {
        if (newStoryTypeName.trim()) {
          const newType = {
            id: `custom-${Date.now()}`,
            name: { en: newStoryTypeName, de: newStoryTypeName, fr: newStoryTypeName },
            emoji: newStoryTypeEmoji || 'ðŸŽ­'
          };
          setCustomStoryTypes([...customStoryTypes, newType]);
          setNewStoryTypeName('');
          setNewStoryTypeEmoji('ðŸŽ­');
        }
      };

      const toggleMainCharacter = (charId) => {
        if (mainCharacters.includes(charId)) {
          setMainCharacters(mainCharacters.filter(id => id !== charId));
        } else if (mainCharacters.length < 2) {
          setMainCharacters([...mainCharacters, charId]);
        }
      };

      const initializeRelationships = () => {
        const newRelationships = {};
        characters.forEach(char1 => {
          characters.forEach(char2 => {
            if (char1.id !== char2.id) {
              const key = `${char1.id}-${char2.id}`;
              if (!relationships[key]) {
                newRelationships[key] = relationshipTypes[10].value[language];
              } else {
                newRelationships[key] = relationships[key];
              }
            }
          });
        });
        setRelationships({ ...relationships, ...newRelationships });
      };

      const updateRelationship = (char1Id, char2Id, type) => {
        const inverse = getInverseRelationship(type);
        setRelationships({
          ...relationships,
          [`${char1Id}-${char2Id}`]: type,
          [`${char2Id}-${char1Id}`]: inverse
        });
      };

      const areAllRelationshipsDefined = () => {
        for (let i = 0; i < characters.length; i++) {
          for (let j = 0; j < characters.length; j++) {
            if (i !== j) {
              const key = `${characters[i].id}-${characters[j].id}`;
              if (!relationships[key]) return false;
            }
          }
        }
        return true;
      };

      const renderStep0 = () => (
        <div className="flex flex-col min-h-[calc(100vh-72px)] px-4 lg:px-8 py-6 lg:py-8 relative">
          {/* Decorative Sparkles - Only 4 total, hidden on mobile */}
          <div className="hidden lg:block absolute bottom-10 right-20 text-3xl opacity-50 animate-pulse">âœ¨</div>
          <div className="hidden lg:block absolute top-10 right-1/3 text-3xl opacity-50 animate-pulse" style={{animationDelay: '1s'}}>âœ¨</div>
          <div className="hidden lg:block absolute bottom-24 left-1/4 text-3xl opacity-50 animate-pulse" style={{animationDelay: '1.5s'}}>âœ¨</div>
          <div className="hidden lg:block absolute bottom-1/3 right-1/3 text-3xl opacity-50 animate-pulse" style={{animationDelay: '2s'}}>âœ¨</div>

          <div className="flex flex-col lg:flex-row gap-6 lg:gap-12 w-full relative z-10">
            {/* Left Side - Text and Button */}
            <div className="w-full lg:w-[35%] flex flex-col justify-center">
              <div>
                <h1 className="text-4xl lg:text-6xl font-title text-black mb-4 lg:mb-6 leading-tight">
                  {t.heroTitle}
                </h1>
                <p className="text-lg lg:text-2xl font-body text-black mb-3 lg:mb-4">
                  {t.heroDescription}
                </p>
                <p className="text-lg lg:text-2xl font-body text-black mb-6 lg:mb-8">
                  {t.bookText}
                </p>

                {/* Button directly below text */}
                <button
                  onClick={() => setShowAuthModal(true)}
                  className="bg-gradient-to-r from-purple-600 via-pink-600 to-blue-600 text-white px-8 lg:px-12 py-4 lg:py-6 rounded-2xl text-lg lg:text-2xl font-bold shadow-2xl hover:shadow-3xl transform hover:scale-105 transition-all inline-flex items-center gap-3 border-2 border-black"
                >
                  <Icon name="sparkles" size={28} />
                  {t.startJourney}
                  <Icon name="arrow-right" size={28} />
                </button>
              </div>
            </div>

            {/* Right Side - Photos and Video (Mobile: stacked, Desktop: side-by-side) */}
            <div className="w-full lg:w-[65%] flex items-center">
              {/* Photos Section */}
              <div className="flex flex-row gap-3 lg:gap-6 items-center justify-center w-full">
                {/* Photos Column - Stacked Vertically on both mobile and desktop */}
                <div className="flex flex-col gap-2 lg:gap-4 w-1/4 lg:w-[28%]">
                  {/* Real Photo */}
                  <div className="text-center">
                    <div className="mb-1 lg:mb-2">
                      <img src="images/Real person.jpg" alt="Your Picture" className="w-full h-auto object-contain rounded-lg max-h-[100px] lg:max-h-[180px]" />
                    </div>
                    <p className="text-xs lg:text-base text-black font-semibold">
                      {language === 'de' ? 'Dein Foto' : language === 'fr' ? 'Votre Photo' : 'Your Picture'}
                    </p>
                  </div>

                  {/* Arrow Down - Rotated 90 degrees */}
                  <div className="flex justify-center my-1 lg:my-2">
                    <img src="images/arrow-icon-1162.png" alt="Arrow Down" className="w-6 h-6 lg:w-12 lg:h-12" style={{transform: 'rotate(90deg)'}} />
                  </div>

                  {/* Avatar */}
                  <div className="text-center">
                    <div className="mb-1 lg:mb-2">
                      <img src="images/Avatar 2.png" alt="Your Character" className="w-full h-auto object-contain rounded-lg max-h-[100px] lg:max-h-[180px]" />
                    </div>
                    <p className="text-xs lg:text-base text-black font-semibold">
                      {language === 'de' ? 'Dein Charakter' : language === 'fr' ? 'Votre Personnage' : 'Your Character'}
                    </p>
                  </div>
                </div>

                {/* Arrow Right - Hidden on mobile, shown on desktop */}
                <div className="hidden lg:flex justify-center items-center lg:w-[8%] self-center">
                  <img src="images/arrow-icon-1162.png" alt="Arrow Right" className="w-14 h-14 lg:w-16 lg:h-16" />
                </div>

                {/* Video Column */}
                <div className="text-center w-3/4 lg:w-[64%]">
                  <div className="rounded-xl overflow-hidden shadow-2xl mb-1 lg:mb-2 h-[280px] lg:h-[480px]">
                    <video
                      autoPlay
                      loop
                      muted
                      playsInline
                      className="w-full h-full object-cover"
                    >
                      <source src="images/Pirat Video2.mp4" type="video/mp4" />
                      Your browser does not support the video tag.
                    </video>
                  </div>
                  <p className="text-xs lg:text-base text-black font-semibold">
                    {language === 'de' ? 'Deine Geschichte' : language === 'fr' ? 'Votre Histoire' : 'Your Story'}
                  </p>
                </div>
              </div>
            </div>
          </div>
        </div>
      );

      const renderStep1 = () => (
        <div className="space-y-6">
          <div className="flex justify-between items-center flex-wrap gap-2 mb-4">
            <h2 className="text-2xl font-bold text-purple-700 flex items-center gap-2">
              <Icon name="book-open" size={24} /> {t.chooseStoryType}
            </h2>
            {currentUser && currentUser.role === 'admin' && (
              <div className="flex gap-2 flex-wrap">
                <label className="bg-blue-500 text-white px-4 py-2 rounded-lg hover:bg-blue-600 cursor-pointer flex items-center gap-2">
                  <Icon name="upload" size={20} /> {t.importConfig}
                  <input
                    type="file"
                    accept=".json,.md"
                    onChange={importConfiguration}
                    className="hidden"
                  />
                </label>
                <label className="bg-orange-500 text-white px-4 py-2 rounded-lg hover:bg-orange-600 cursor-pointer flex items-center gap-2">
                  <Icon name="file-text" size={20} /> {t.uploadStory}
                  <input
                    type="file"
                    accept=".txt,.md"
                    onChange={uploadStory}
                    className="hidden"
                  />
                </label>
              </div>
            )}
          </div>
          <div className="grid grid-cols-3 md:grid-cols-5 lg:grid-cols-6 gap-2">
            {allStoryTypes.map(type => (
              <button
                key={type.id}
                onClick={() => {
                  setStoryType(type.id);
                  // Auto-scroll to art style selection after a short delay
                  setTimeout(() => {
                    const artStyleSection = document.getElementById('art-style-section');
                    if (artStyleSection) {
                      artStyleSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    }
                  }, 100);
                }}
                className={`p-2 rounded-lg border-2 transition-all ${
                  storyType === type.id
                    ? 'border-purple-500 bg-purple-50 shadow-lg'
                    : 'border-gray-200 hover:border-purple-300'
                }`}
              >
                <div className="text-2xl mb-1">{type.emoji}</div>
                <div className="font-semibold text-[10px]">{type.name[language]}</div>
              </button>
            ))}
            {/* Add Custom Type Button */}
            <button
              onClick={() => {
                const name = prompt('Enter story type name:');
                if (name) {
                  const newType = {
                    id: `custom_${Date.now()}`,
                    name: { en: name, de: name, fr: name },
                    emoji: 'ðŸ“–'
                  };
                  setCustomStoryTypes([...customStoryTypes, newType]);
                  setStoryType(newType.id); // Auto-select the new custom type
                  // Auto-scroll to art style selection
                  setTimeout(() => {
                    const artStyleSection = document.getElementById('art-style-section');
                    if (artStyleSection) {
                      artStyleSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    }
                  }, 100);
                }
              }}
              className="p-2 rounded-lg border-2 border-dashed border-purple-300 hover:border-purple-500 transition-all hover:bg-purple-50"
            >
              <div className="text-2xl mb-1">âž•</div>
              <div className="font-semibold text-[10px] text-purple-600">{t.addCustomStoryType}</div>
            </button>
          </div>

          {/* Art Style Selection - Show only after story type is selected */}
          {storyType && (
            <div id="art-style-section" className="md:bg-gradient-to-br md:from-pink-50 md:to-purple-50 md:border-2 md:border-pink-300 md:rounded-lg md:p-4 mt-4">
              <div className="flex items-center gap-2 mb-2">
                <Icon name="palette" size={18} className="text-pink-600" />
                <h2 className="text-base md:text-lg font-bold text-gray-800 md:text-pink-700">{t.chooseArtStyle}</h2>
              </div>
              <p className="text-xs text-gray-600 mb-2 md:mb-3">{t.artStyleDescription}</p>
              <div className="grid grid-cols-3 md:grid-cols-5 lg:grid-cols-7 gap-2">
                {artStyles.map(style => (
                  <button
                    key={style.id}
                    onClick={() => setArtStyle(style.id)}
                    className={`rounded-lg border-2 transition-all overflow-hidden flex flex-col bg-white ${
                      artStyle === style.id
                        ? 'border-pink-500 shadow-lg ring-2 ring-pink-300'
                        : 'border-gray-300 hover:border-pink-300'
                    }`}
                  >
                    {/* Image at the top - Taller to show more */}
                    <div className="relative w-full h-32 overflow-hidden">
                      <img
                        src={style.image}
                        alt={style.name[language]}
                        className="w-full h-full object-cover"
                      />
                    </div>

                    {/* Text content below image - No emoji */}
                    <div className="p-1.5 flex flex-col items-center text-center">
                      <div className="font-bold text-[10px] text-gray-800">{style.name[language]}</div>
                    </div>
                  </button>
                ))}
              </div>
            </div>
          )}
        </div>
      );

      const renderStep2 = () => {
        // Character is initialized by useEffect when step changes to 2
        // This prevents state updates during render

        // Ensure arrays are initialized (only if currentCharacter exists)
        if (currentCharacter) {
          if (!currentCharacter.strengths) currentCharacter.strengths = [];
          if (!currentCharacter.weaknesses) currentCharacter.weaknesses = [];
          if (!currentCharacter.fears) currentCharacter.fears = [];
        }

        const canSave = currentCharacter && currentCharacter.name &&
                        currentCharacter.strengths && currentCharacter.strengths.length >= 3 &&
                        currentCharacter.weaknesses && currentCharacter.weaknesses.length >= 2;

        return (
          <div className="space-y-6">
            <h2 className="text-2xl font-bold text-purple-700 flex items-center gap-2">
              <Icon name="users" size={24} /> {t.createCharacters}
            </h2>

            {/* Character list with action buttons - shown when there are existing characters */}
            {characters.length > 0 && !currentCharacter && (
              <div className="space-y-4">
                {/* Success message if just created */}
                {showCharacterCreated && (
                  <div className="md:bg-green-50 md:border-2 md:border-green-400 md:rounded-xl p-4 animate-fade-in">
                    <div className="flex items-center gap-3">
                      <div className="bg-green-500 text-white rounded-full w-8 h-8 flex items-center justify-center">
                        <Icon name="check" size={20} />
                      </div>
                      <h3 className="text-lg font-bold text-green-700">
                        {language === 'de' ? 'Charakter erfolgreich erstellt!' : language === 'fr' ? 'Personnage crÃ©Ã© avec succÃ¨s !' : 'Character Created Successfully!'}
                      </h3>
                    </div>
                  </div>
                )}

                {/* Existing characters */}
                <div className="bg-white border-2 border-purple-200 rounded-lg p-3">
                  <h3 className="text-sm font-bold text-purple-700 mb-2">{t.yourCharacters}</h3>
                  <div className="grid md:grid-cols-2 gap-2">
                    {characters.map((char) => (
                      <div key={char.id} className="border border-gray-200 rounded p-2 relative">
                        <div className="absolute top-1 right-1 flex gap-1">
                          <button
                            onClick={() => editCharacter(char)}
                            className="bg-blue-500 text-white px-2 py-0.5 rounded text-[10px] hover:bg-blue-600"
                          >
                            {t.editCharacter}
                          </button>
                          <button
                            onClick={() => deleteCharacter(char.id)}
                            className="bg-red-500 text-white px-2 py-0.5 rounded text-[10px] hover:bg-red-600"
                          >
                            {t.deleteCharacter}
                          </button>
                        </div>
                        {char.photoUrl && (
                          <img src={char.photoUrl} alt={char.name} className="w-16 h-16 rounded-full mx-auto mb-2 object-cover border-2 border-purple-200" />
                        )}
                        <h4 className="font-bold text-center mb-1 text-sm">{char.name}</h4>
                        <p className="text-xs text-gray-600 text-center mb-2">
                          {char.gender === 'male' ? t.male : char.gender === 'female' ? t.female : t.other}, {char.age} {language === 'de' ? 'J' : language === 'fr' ? 'ans' : 'y'}
                        </p>
                        {char.strengths && char.strengths.length > 0 && (
                          <p className="text-[10px] text-gray-700 mb-1">
                            <strong className="text-green-600">{t.strengths}:</strong> {char.strengths.join(', ')}
                          </p>
                        )}
                        {char.weaknesses && char.weaknesses.length > 0 && (
                          <p className="text-[10px] text-gray-700 mb-1">
                            <strong className="text-orange-600">{t.weaknesses}:</strong> {char.weaknesses.join(', ')}
                          </p>
                        )}
                        {char.fears && char.fears.length > 0 && (
                          <p className="text-[10px] text-gray-700 mb-1">
                            <strong className="text-red-600">{t.fears}:</strong> {char.fears.join(', ')}
                          </p>
                        )}
                      </div>
                    ))}
                  </div>
                </div>

                {/* What would you like to do next? */}
                <div className="md:bg-purple-50 md:border-2 md:border-purple-200 md:rounded-lg p-4">
                  <p className="text-gray-700 mb-4 text-center font-semibold">
                    {language === 'de'
                      ? 'Was mÃ¶chten Sie als NÃ¤chstes tun?'
                      : language === 'fr'
                      ? 'Que voulez-vous faire ensuite ?'
                      : 'What would you like to do next?'}
                  </p>
                  <div className="grid md:grid-cols-2 gap-3">
                    <button
                      onClick={() => {
                        setShowCharacterCreated(false);
                        startNewCharacter();
                      }}
                      className="bg-purple-500 text-white px-6 py-3 rounded-lg hover:bg-purple-600 font-semibold flex items-center justify-center gap-2 transition-colors"
                    >
                      <Icon name="user-plus" size={20} />
                      {language === 'de' ? 'Weiteren Charakter erstellen' : language === 'fr' ? 'CrÃ©er un autre personnage' : 'Create Another Character'}
                    </button>
                    <button
                      onClick={() => {
                        setShowCharacterCreated(false);
                        initializeRelationships();
                        setStep(3);
                      }}
                      className="bg-blue-500 text-white px-6 py-3 rounded-lg hover:bg-blue-600 font-semibold flex items-center justify-center gap-2 transition-colors"
                    >
                      <Icon name="arrow-right" size={20} />
                      {language === 'de' ? 'Weiter zu Beziehungen' : language === 'fr' ? 'Continuer vers les relations' : 'Continue to Relationships'}
                    </button>
                  </div>
                </div>
              </div>
            )}

            {currentCharacter && (
              <div ref={characterFormRef} className="bg-white border-2 border-purple-200 rounded-lg p-3 space-y-3">
                <h3 className="text-base font-bold text-purple-700">{currentCharacter.id ? t.editCharacter : t.startCreating}</h3>

                {/* Character Name */}
                <div>
                  <label className="block text-xs font-semibold mb-1">{t.characterName} *</label>
                  <input
                    type="text"
                    value={currentCharacter.name}
                    onChange={(e) => handleNameChange(e.target.value)}
                    className="w-full px-2 py-1.5 border border-gray-300 rounded text-sm"
                    placeholder={t.characterName}
                  />
                </div>

                <div className="grid md:grid-cols-2 gap-3">
                  <div className="md:border md:border-purple-300 md:rounded-lg p-2 md:bg-purple-50">
                    <label className="block text-xs font-semibold mb-2 text-center">{t.characterPhoto}</label>
                    <div className="flex flex-col items-center gap-2">
                      {currentCharacter.photoUrl && (
                        <img
                          src={currentCharacter.photoUrl}
                          alt="Character"
                          className="w-20 h-20 rounded-full object-cover border-2 border-purple-400"
                        />
                      )}

                      {/* Upload Type Selector - Admin only */}
                      {currentUser && currentUser.role === 'admin' && (
                        <div className="w-full mb-1">
                          <p className="text-xs font-semibold text-center mb-1">{t.uploadType}</p>
                          <div className="flex flex-col gap-1">
                            <label className="flex items-center gap-1 cursor-pointer text-xs">
                              <input
                                type="radio"
                                name="uploadType"
                                value="photo"
                                checked={uploadType === 'photo'}
                                onChange={(e) => setUploadType(e.target.value)}
                                className="w-3 h-3"
                              />
                              <span>{t.uploadRealPhoto}</span>
                            </label>
                            <label className="flex items-center gap-1 cursor-pointer text-xs">
                              <input
                                type="radio"
                                name="uploadType"
                                value="avatar"
                                checked={uploadType === 'avatar'}
                                onChange={(e) => setUploadType(e.target.value)}
                                className="w-3 h-3"
                              />
                              <span>{t.uploadReadyAvatar}</span>
                            </label>
                          </div>
                        </div>
                      )}

                      <label className="cursor-pointer bg-blue-500 text-white px-3 py-1.5 rounded text-xs hover:bg-blue-600 flex items-center gap-1 font-semibold">
                        <Icon name="upload" size={14} /> {t.uploadPhoto}
                        <input
                          type="file"
                          accept="image/*"
                          onChange={handlePhotoUpload}
                          className="hidden"
                        />
                      </label>

                      {/* Generate Avatar Button - Admin only */}
                      {currentUser && currentUser.role === 'admin' && currentCharacter.photoUrl && !generatedAvatar && generatedAvatars.length === 0 && (uploadType === 'photo' || !currentUser || currentUser.role !== 'admin') && (
                        <button
                          onClick={() => generateAvatar(currentCharacter.photoUrl)}
                          disabled={isGeneratingAvatar}
                          className={`px-3 py-1.5 rounded text-xs font-semibold flex items-center gap-1 ${
                            isGeneratingAvatar
                              ? 'bg-gray-400 cursor-not-allowed'
                              : 'bg-purple-500 text-white hover:bg-purple-600'
                          }`}
                        >
                          {isGeneratingAvatar ? (
                            <>
                              <Icon name="loader" size={14} className="animate-spin" /> {t.generatingAvatar}
                            </>
                          ) : (
                            <>
                              <Icon name="sparkles" size={14} /> {language === 'de' ? 'Avatare (3x)' : language === 'fr' ? 'Avatars (3x)' : 'Avatars (3x)'}
                            </>
                          )}
                        </button>
                      )}

                      {/* Show 3 avatar variants for selection */}
                      {generatedAvatars.length > 0 && (
                        <div className="w-full mt-2 p-2 bg-white rounded border border-purple-400">
                          <h3 className="text-xs font-bold text-purple-700 mb-2 text-center">
                            {language === 'de' ? 'WÃ¤hle Avatar' : language === 'fr' ? 'Choisir avatar' : 'Choose Avatar'}
                          </h3>

                          <div className="grid grid-cols-3 gap-1.5 mb-2">
                            {generatedAvatars.map((variant, index) => (
                              <div key={index} className="flex flex-col items-center">
                                <div className="relative w-full aspect-square mb-1 border border-gray-300 rounded overflow-hidden hover:border-purple-500 transition-all cursor-pointer">
                                  <img
                                    src={variant.image}
                                    alt={variant.type}
                                    className="w-full h-full object-cover"
                                    onClick={() => {
                                      // Select this avatar
                                      setGeneratedAvatar(variant.image);
                                      if (variant.traits) {
                                        setCurrentCharacter(prev => ({
                                          ...prev,
                                          photoUrl: variant.image,
                                          photo: null,
                                          age: variant.traits.age || prev.age,
                                          height: variant.traits.height || prev.height,
                                          build: variant.traits.build || prev.build,
                                          hairColor: variant.traits.hairColor || prev.hairColor,
                                          otherFeatures: variant.traits.otherFeatures || prev.otherFeatures
                                        }));
                                        if (variant.traits.fullText) {
                                          setAnalyzedTraitsText(variant.traits.fullText);
                                        }
                                      }
                                      setGeneratedAvatars([]); // Clear variants after selection
                                    }}
                                  />
                                </div>
                                <p className="text-[9px] font-semibold text-gray-700">{variant.type}</p>
                              </div>
                            ))}
                          </div>

                          <div className="flex gap-1">
                            <button
                              onClick={() => setGeneratedAvatars([])}
                              className="flex-1 bg-gray-500 text-white px-2 py-1 rounded text-[10px] hover:bg-gray-600 font-semibold"
                            >
                              <Icon name="x" size={10} className="inline mr-0.5" />
                              {language === 'de' ? 'Verwerfen' : language === 'fr' ? 'Rejeter' : 'Discard'}
                            </button>
                            <button
                              onClick={() => generateAvatar(currentCharacter.photoUrl)}
                              disabled={isGeneratingAvatar}
                              className="flex-1 bg-purple-500 text-white px-2 py-1 rounded text-[10px] hover:bg-purple-600 font-semibold disabled:bg-gray-400"
                            >
                              <Icon name="refresh-cw" size={10} className="inline mr-0.5" />
                              {language === 'de' ? 'Neu' : language === 'fr' ? 'Nouveau' : 'New'}
                            </button>
                          </div>
                        </div>
                      )}

                      {generatedAvatar && (
                        <div className="w-full mt-2 p-2 bg-white rounded border border-purple-400">
                          <h3 className="text-xs font-bold text-purple-700 mb-2 text-center">{t.avatarGenerated}</h3>
                          <img
                            src={generatedAvatar}
                            alt="Generated Avatar"
                            className="w-full rounded mb-2"
                          />

                          {/* Use Generated Avatar / Keep Original buttons - Admin only */}
                          {currentUser && currentUser.role === 'admin' && (
                            <div className="flex gap-2 mb-3">
                              <button
                                onClick={async () => {
                                  // First, update the photo to use the avatar
                                  setCurrentCharacter(prev => ({
                                    ...prev,
                                    photoUrl: generatedAvatar,
                                    photo: null
                                  }));

                                  // Then analyze the generated avatar to extract features
                                  const traits = await analyzeImageForTraits(generatedAvatar);
                                  if (traits) {
                                    setCurrentCharacter(prev => ({
                                      ...prev,
                                      photoUrl: generatedAvatar,
                                      photo: null,
                                      age: traits.age || prev.age,
                                      height: traits.height || prev.height,
                                      build: traits.build || prev.build,
                                      hairColor: traits.hairColor || prev.hairColor,
                                      otherFeatures: traits.otherFeatures || prev.otherFeatures
                                    }));
                                  }

                                  setGeneratedAvatar(null);
                                }}
                                className="flex-1 bg-green-500 text-white px-4 py-2 rounded-lg hover:bg-green-600 font-semibold text-sm"
                              >
                                <Icon name="check" size={16} className="inline mr-1" /> {t.useGeneratedAvatar}
                              </button>
                              <button
                                onClick={() => setGeneratedAvatar(null)}
                                className="flex-1 bg-gray-500 text-white px-4 py-2 rounded-lg hover:bg-gray-600 font-semibold text-sm"
                              >
                                <Icon name="x" size={16} className="inline mr-1" /> {t.keepOriginal}
                              </button>
                            </div>
                          )}


                          {/* Show Prompt Button - Admin only */}
                          {currentUser && currentUser.role === 'admin' && avatarPrompt && (
                            <details className="bg-gray-50 border border-gray-300 rounded-lg p-2 mb-2">
                              <summary className="cursor-pointer text-xs font-semibold text-gray-700 hover:text-gray-900">
                                {t.showPrompt}
                              </summary>
                              <pre className="mt-2 text-xs text-gray-600 whitespace-pre-wrap font-mono bg-white p-2 rounded border border-gray-200">
                                {avatarPrompt}
                              </pre>
                            </details>
                          )}

                          {/* Show Analyzed Traits - Admin only */}
                          {currentUser && currentUser.role === 'admin' && analyzedTraitsText && (
                            <details className="bg-blue-50 border border-blue-300 rounded-lg p-2" open>
                              <summary className="cursor-pointer text-xs font-semibold text-blue-700 hover:text-blue-900">
                                {language === 'de' ? 'Analysierte Eigenschaften' : language === 'fr' ? 'Traits analysÃ©s' : 'Analyzed Traits'}
                              </summary>
                              <pre className="mt-2 text-xs text-blue-600 whitespace-pre-wrap font-mono bg-white p-2 rounded border border-blue-200">
                                {analyzedTraitsText}
                              </pre>
                            </details>
                          )}
                        </div>
                      )}
                    </div>
                  </div>

                  <div className="md:border-2 md:border-green-300 md:rounded-lg p-4 md:bg-green-50">
                    <label className="block text-lg font-semibold mb-3 text-center md:block hidden">{t.orDescribe}</label>
                    <div className="space-y-2">
                      {/* Gender */}
                      <div className="flex items-center gap-2">
                        <label className="text-xs font-semibold whitespace-nowrap min-w-[60px]">{t.gender}:</label>
                        <select
                          value={currentCharacter.gender}
                          onChange={(e) => setCurrentCharacter({ ...currentCharacter, gender: e.target.value })}
                          className="flex-1 px-2 py-1.5 border border-gray-300 rounded text-sm"
                        >
                          <option value="male">{t.male}</option>
                          <option value="female">{t.female}</option>
                          <option value="other">{t.other}</option>
                        </select>
                      </div>

                      {/* Age and Height on same row */}
                      <div className="grid grid-cols-2 gap-2">
                        <div className="flex items-center gap-2">
                          <label className="text-xs font-semibold whitespace-nowrap">{t.age}:</label>
                          <input
                            type="number"
                            value={currentCharacter.age}
                            onChange={(e) => setCurrentCharacter({ ...currentCharacter, age: e.target.value })}
                            className="w-full px-2 py-1.5 border border-gray-300 rounded text-sm"
                            placeholder={t.age}
                            min="1"
                            max="99"
                          />
                        </div>
                        <div className="flex items-center gap-2">
                          <label className="text-xs font-semibold whitespace-nowrap">
                            {language === 'de' ? 'GrÃ¶ÃŸe:' : language === 'fr' ? 'Taille:' : 'Height:'}
                          </label>
                          <input
                            type="number"
                            value={currentCharacter.height}
                            onChange={(e) => setCurrentCharacter({ ...currentCharacter, height: e.target.value })}
                            className="w-full px-2 py-1.5 border border-gray-300 rounded text-sm"
                            placeholder="cm"
                            min="50"
                            max="250"
                          />
                        </div>
                      </div>

                      {/* Build */}
                      <div className="flex items-center gap-2">
                        <label className="text-xs font-semibold whitespace-nowrap min-w-[60px]">
                          {language === 'de' ? 'KÃ¶rperbau:' : language === 'fr' ? 'Corpulence:' : 'Build:'}
                        </label>
                        <select
                          value={currentCharacter.build}
                          onChange={(e) => setCurrentCharacter({ ...currentCharacter, build: e.target.value })}
                          className="flex-1 px-2 py-1.5 border border-gray-300 rounded text-sm"
                        >
                          <option value="">{language === 'de' ? 'WÃ¤hlen...' : language === 'fr' ? 'SÃ©lectionner...' : 'Select...'}</option>
                          <option value="slim">{language === 'de' ? 'Schlank' : language === 'fr' ? 'Mince' : 'Slim'}</option>
                          <option value="average">{language === 'de' ? 'Durchschnittlich' : language === 'fr' ? 'Moyenne' : 'Average'}</option>
                          <option value="athletic">{language === 'de' ? 'Athletisch' : language === 'fr' ? 'AthlÃ©tique' : 'Athletic'}</option>
                          <option value="chubby">{language === 'de' ? 'Mollig' : language === 'fr' ? 'PotelÃ©' : 'Chubby'}</option>
                          <option value="overweight">{language === 'de' ? 'Ãœbergewichtig' : language === 'fr' ? 'En surpoids' : 'Overweight'}</option>
                          <option value="heavily overweight">{language === 'de' ? 'Stark Ã¼bergewichtig' : language === 'fr' ? 'TrÃ¨s en surpoids' : 'Heavily Overweight'}</option>
                        </select>
                      </div>

                      {/* Hair Color and Other Features - Admin only */}
                      {currentUser && currentUser.role === 'admin' && (
                        <>
                          <div className="flex items-center gap-2">
                            <label className="text-xs font-semibold whitespace-nowrap min-w-[60px]">{t.hairColor}:</label>
                            <input
                              type="text"
                              value={currentCharacter.hairColor}
                              onChange={(e) => setCurrentCharacter({ ...currentCharacter, hairColor: e.target.value })}
                              className="flex-1 px-2 py-1.5 border border-gray-300 rounded text-sm"
                              placeholder={t.hairColor}
                            />
                          </div>
                          <div className="flex items-start gap-2">
                            <label className="text-xs font-semibold whitespace-nowrap min-w-[60px] pt-1.5">{t.otherFeatures}:</label>
                            <textarea
                              value={currentCharacter.otherFeatures}
                              onChange={(e) => setCurrentCharacter({ ...currentCharacter, otherFeatures: e.target.value })}
                              className="flex-1 px-2 py-1.5 border border-gray-300 rounded text-sm"
                              placeholder={t.descriptionPlaceholder}
                              rows={2}
                            />
                          </div>
                        </>
                      )}
                    </div>
                  </div>
                </div>

                <div>
                  <label className="block text-lg font-semibold mb-2">
                    {t.strengths} * ({t.selectAtLeast} 3) - {t.selected}: {currentCharacter.strengths.length}
                  </label>
                  <div className="flex flex-wrap gap-2 mb-3">
                    {allStrengths.map(strength => (
                      <button
                        key={strength}
                        onClick={() => toggleArrayItem('strengths', strength)}
                        className={`px-3 py-1 rounded-full text-sm ${
                          currentCharacter.strengths.includes(strength)
                            ? 'bg-green-500 text-white'
                            : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
                        }`}
                      >
                        {strength}
                      </button>
                    ))}
                  </div>
                  <div className="flex gap-2">
                    <input
                      type="text"
                      value={newStrength}
                      onChange={(e) => setNewStrength(e.target.value)}
                      onKeyPress={(e) => e.key === 'Enter' && addCustomStrength()}
                      placeholder={t.addCustomStrengths}
                      className="flex-1 px-3 py-2 border border-gray-300 rounded-lg"
                    />
                    <button
                      onClick={addCustomStrength}
                      className="bg-blue-500 text-white px-4 py-2 rounded-lg hover:bg-blue-600"
                    >
                      <Icon name="plus" size={20} />
                    </button>
                  </div>
                </div>

                <div>
                  <label className="block text-lg font-semibold mb-2">
                    {t.weaknesses} * ({t.selectAtLeast} 2) - {t.selected}: {currentCharacter.weaknesses.length}
                  </label>
                  <div className="flex flex-wrap gap-2 mb-3">
                    {allWeaknesses.map(weakness => (
                      <button
                        key={weakness}
                        onClick={() => toggleArrayItem('weaknesses', weakness)}
                        className={`px-3 py-1 rounded-full text-sm ${
                          currentCharacter.weaknesses.includes(weakness)
                            ? 'bg-orange-500 text-white'
                            : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
                        }`}
                      >
                        {weakness}
                      </button>
                    ))}
                  </div>
                  <div className="flex gap-2">
                    <input
                      type="text"
                      value={newWeakness}
                      onChange={(e) => setNewWeakness(e.target.value)}
                      onKeyPress={(e) => e.key === 'Enter' && addCustomWeakness()}
                      placeholder={t.addCustomWeaknesses}
                      className="flex-1 px-3 py-2 border border-gray-300 rounded-lg"
                    />
                    <button
                      onClick={addCustomWeakness}
                      className="bg-blue-500 text-white px-4 py-2 rounded-lg hover:bg-blue-600"
                    >
                      <Icon name="plus" size={20} />
                    </button>
                  </div>
                </div>

                <div>
                  <label className="block text-lg font-semibold mb-2">{t.specialDetails}</label>
                  <textarea
                    value={currentCharacter.specialDetails}
                    onChange={(e) => setCurrentCharacter({ ...currentCharacter, specialDetails: e.target.value })}
                    className="w-full px-4 py-3 border-2 border-gray-300 rounded-lg text-lg"
                    placeholder={t.specialDetailsPlaceholder}
                    rows={3}
                  />
                </div>

                <div className="flex gap-4">
                  <button
                    onClick={cancelEditCharacter}
                    className="flex-1 bg-gray-300 text-gray-700 px-6 py-3 rounded-lg hover:bg-gray-400 font-semibold"
                  >
                    {t.cancel}
                  </button>
                  <button
                    onClick={saveCurrentCharacter}
                    disabled={!canSave}
                    className={`flex-1 px-6 py-3 rounded-lg font-semibold ${
                      canSave
                        ? 'bg-blue-500 text-white hover:bg-blue-600'
                        : 'bg-gray-300 text-gray-500 cursor-not-allowed'
                    }`}
                  >
                    {t.saveCharacter}
                  </button>
                </div>
              </div>
            )}
          </div>
        );
      };

      const renderStep3 = () => (
        <div className="space-y-6">
          <h2 className="text-2xl font-bold text-purple-700 flex items-center gap-2">
            <Icon name="heart" size={24} /> {t.defineRelationships}
          </h2>
          <p className="text-gray-600">{t.defineRelationshipsDesc}</p>

          <div className="space-y-4">
            {characters.map((char1, i) => (
              <div key={char1.id}>
                {characters.map((char2, j) => {
                  if (i >= j) return null;
                  const key1 = `${char1.id}-${char2.id}`;
                  const key2 = `${char2.id}-${char1.id}`;

                  // Check if this is the last relationship pair
                  const isLastRelationship = i === characters.length - 2 && j === characters.length - 1;

                  return (
                    <>
                      <div key={key1} className="bg-white md:border-2 md:border-purple-200 md:rounded-xl p-4 md:p-6 mb-4">
                      {/* Main relationship selector and description - side by side on wide screens */}
                      <div className="grid lg:grid-cols-[1fr,350px] gap-4">
                        {/* Left: Relationship Selector */}
                        <div className="space-y-4">
                          <div className="grid md:grid-cols-3 gap-2 md:gap-3 items-center">
                            <div className="text-center">
                              {char1.photoUrl && (
                                <img src={char1.photoUrl} alt={char1.name} className="w-16 h-16 rounded-full mx-auto mb-2 object-cover" />
                              )}
                              <div className="font-bold">{char1.name}</div>
                            </div>

                            <div className="space-y-2">
                              <label className="block text-sm font-semibold text-center">{t.is}</label>
                              <select
                                value={relationships[key1] || relationshipTypes[10].value[language]}
                                onChange={(e) => {
                                  const value = e.target.value;
                                  if (value === '__CREATE_CUSTOM__') {
                                    const customRel = prompt(language === 'de' ? 'Beziehung eingeben:' : language === 'fr' ? 'Entrer la relation:' : 'Enter relationship:');
                                    if (customRel && customRel.trim()) {
                                      setCustomRelationships([...customRelationships, customRel.trim()]);
                                      updateRelationship(char1.id, char2.id, customRel.trim());
                                    }
                                  } else {
                                    updateRelationship(char1.id, char2.id, value);
                                  }
                                }}
                                className="w-full px-3 py-2 border-2 border-gray-300 rounded-lg font-semibold"
                              >
                                <option value="__CREATE_CUSTOM__">
                                  {language === 'de' ? '+ Eigene Beziehung erstellen' : language === 'fr' ? '+ CrÃ©er relation personnalisÃ©e' : '+ Create custom relationship'}
                                </option>
                                {allRelationships.map((type, idx) => (
                                  <option key={idx} value={type.value[language]}>{type.value[language]}</option>
                                ))}
                              </select>
                            </div>

                            <div className="text-center">
                              {char2.photoUrl && (
                                <img src={char2.photoUrl} alt={char2.name} className="w-16 h-16 rounded-full mx-auto mb-2 object-cover" />
                              )}
                              <div className="font-bold">{char2.name}</div>
                            </div>
                          </div>
                        </div>

                        {/* Right (wide screens) / Bottom (narrow screens): Relationship Description */}
                        {relationships[key1] && relationships[key2] && (
                          <div className="lg:border-l lg:pl-4 lg:border-gray-200">
                            <label className="block text-xs font-semibold text-gray-600 mb-1">
                              {language === 'de' ? 'Beziehung beschreiben' : language === 'fr' ? 'DÃ©crire la relation' : 'Describe Relationship'}
                            </label>
                            <textarea
                              value={relationshipTexts[key1] || ''}
                              onChange={(e) => setRelationshipTexts({ ...relationshipTexts, [key1]: e.target.value })}
                              placeholder={language === 'de' ? 'z.B. Sie sind seit 10 Jahren beste Freunde...' : language === 'fr' ? 'par ex. Ils sont meilleurs amis depuis 10 ans...' : 'e.g., They have been best friends for 10 years...'}
                              className="w-full px-3 py-2 border border-gray-300 rounded-lg text-sm resize-none"
                              rows="4"
                            />
                          </div>
                        )}
                      </div>
                    </div>

                    {/* Separator line between relationships */}
                    {!isLastRelationship && (
                      <hr className="border-t-2 border-gray-300 my-6" />
                    )}
                  </>
                  );
                })}
              </div>
            ))}
          </div>
        </div>
      );

      const renderStep4 = () => (
        <div className="space-y-6">
          <div className="flex justify-between items-center flex-wrap gap-2">
            <h2 className="text-2xl font-bold text-purple-700 flex items-center gap-2">
              <Icon name="wand-2" size={24} /> {t.storySettings}
            </h2>
            {currentUser && currentUser.role === 'admin' && (
              <div className="flex items-center gap-3">
                {/* Mode Toggle - Admin only */}
                <div className="flex items-center gap-2 bg-gray-100 px-3 py-2 rounded-lg border border-gray-300">
                  <label className="flex items-center gap-2 cursor-pointer">
                    <input
                      type="checkbox"
                      checked={developerMode}
                      onChange={(e) => setDeveloperMode(e.target.checked)}
                      className="w-4 h-4"
                    />
                    <span className="text-sm font-semibold text-gray-700">
                      {language === 'de' ? 'Entwicklermodus' : language === 'fr' ? 'Mode dÃ©veloppeur' : 'Developer Mode'}
                    </span>
                  </label>
                </div>
                <button
                  onClick={exportConfiguration}
                  className="bg-blue-500 text-white px-4 py-2 rounded-lg hover:bg-blue-600 flex items-center gap-2"
                >
                  <Icon name="save" size={20} /> {t.exportConfig}
                </button>
              </div>
            )}
          </div>


          <div className="bg-white border-2 border-purple-200 rounded-xl p-6 space-y-6">
            <div>
              <label className="block text-lg font-semibold mb-3">{t.selectMainCharacters}</label>
              <div className="grid md:grid-cols-2 gap-3">
                {characters.map(char => (
                  <button
                    key={char.id}
                    onClick={() => toggleMainCharacter(char.id)}
                    className={`p-4 rounded-lg border-2 transition-all text-left ${
                      mainCharacters.includes(char.id)
                        ? 'border-yellow-500 bg-yellow-50'
                        : 'border-gray-200 hover:border-gray-300'
                    }`}
                  >
                    <div className="flex items-center gap-3">
                      {char.photoUrl && (
                        <img src={char.photoUrl} alt={char.name} className="w-12 h-12 rounded-full object-cover" />
                      )}
                      <div className="flex-1">
                        <div className="font-bold flex items-center gap-2">
                          {char.name}
                          <span className={mainCharacters.includes(char.id) ? 'inline-block' : 'hidden'}>
                            <Icon name="star" size={16} className="text-yellow-500" />
                          </span>
                        </div>
                        <div className="text-sm text-gray-600">
                          {char.gender === 'male' ? t.male : char.gender === 'female' ? t.female : t.other}, {char.age}
                        </div>
                      </div>
                    </div>
                  </button>
                ))}
              </div>
            </div>

            <div>
              <label className="block text-lg font-semibold mb-3">
                {t.numberOfPages}
              </label>
              <select
                value={pages}
                onChange={(e) => setPages(parseInt(e.target.value))}
                className="w-full px-4 py-3 border-2 border-purple-200 rounded-lg focus:border-purple-500 focus:outline-none text-lg font-semibold"
              >
                {currentUser && currentUser.role === 'admin' && (
                  <option value="1">1 {language === 'de' ? 'Seite (Test)' : language === 'fr' ? 'page (Test)' : 'page (Test)'}</option>
                )}
                <option value="5">5 {language === 'de' ? 'Seiten' : language === 'fr' ? 'pages' : 'pages'}</option>
                <option value="15">15 {language === 'de' ? 'Seiten' : language === 'fr' ? 'pages' : 'pages'}</option>
                <option value="20">20 {language === 'de' ? 'Seiten' : language === 'fr' ? 'pages' : 'pages'}</option>
              </select>
            </div>

            <div>
              <label className="block text-lg font-semibold mb-3">{t.readingLevel}</label>
              <div className="space-y-2">
                {[
                  { value: '1st-grade', label: t.firstGrade, desc: t.firstGradeDesc },
                  { value: 'standard', label: t.standard, desc: t.standardDesc },
                  { value: 'advanced', label: t.advanced, desc: t.advancedDesc }
                ].map(level => (
                  <button
                    key={level.value}
                    onClick={() => setLanguageLevel(level.value)}
                    className={`w-full text-left p-4 rounded-lg border-2 transition-all ${
                      languageLevel === level.value
                        ? 'border-purple-500 bg-purple-50'
                        : 'border-gray-200 hover:border-purple-300'
                    }`}
                  >
                    <div className="font-semibold">{level.label}</div>
                    <div className="text-sm text-gray-600">{level.desc}</div>
                  </button>
                ))}
              </div>
            </div>

            {/* Additional Story Details */}
            <div className="bg-blue-50 border-2 border-blue-200 rounded-lg p-4">
              <label className="block text-sm font-semibold text-blue-700 mb-2">{t.storyDetails}</label>
              <textarea
                value={storyDetails}
                onChange={(e) => setStoryDetails(e.target.value)}
                placeholder={t.storyDetailsPlaceholder}
                className="w-full px-3 py-2 border-2 border-gray-300 rounded-lg focus:border-blue-500 focus:outline-none text-sm"
                rows="3"
              />
            </div>

            {/* Prompt Preview Section - Admin only */}
            {currentUser && currentUser.role === 'admin' && (
              <div className="border-t-2 border-gray-200 pt-6">
                <div className="flex justify-between items-center mb-3">
                  <h3 className="text-lg font-semibold text-purple-700">{t.promptPreview}</h3>
                  <div className="flex gap-2">
                    <button
                      onClick={() => {
                        if (!showPromptPreview) {
                          setEditablePrompt(buildOutlinePrompt());
                        }
                        setShowPromptPreview(!showPromptPreview);
                      }}
                      className="bg-gray-500 text-white px-4 py-2 rounded-lg hover:bg-gray-600 flex items-center gap-2 text-sm"
                    >
                      <Icon name={showPromptPreview ? "eye-off" : "eye"} size={16} />
                      {showPromptPreview ? t.hidePromptPreview : t.showPromptPreview}
                    </button>
                    {showPromptPreview && (
                      <button
                        onClick={() => setEditablePrompt(buildOutlinePrompt())}
                        className="bg-orange-500 text-white px-4 py-2 rounded-lg hover:bg-orange-600 flex items-center gap-2 text-sm"
                      >
                        <Icon name="refresh-cw" size={16} />
                        {t.resetPrompt}
                      </button>
                    )}
                  </div>
                </div>
                {showPromptPreview && (
                  <div className="bg-gray-50 border-2 border-gray-300 rounded-lg p-4">
                    <textarea
                      value={editablePrompt}
                      onChange={(e) => setEditablePrompt(e.target.value)}
                      className="w-full h-64 px-4 py-3 border-2 border-gray-300 rounded-lg font-mono text-sm resize-y"
                      placeholder="Prompt will appear here..."
                    />
                    <p className="text-xs text-gray-500 mt-2">
                      {t.editPrompt}: You can modify the prompt above before generating the story.
                    </p>
                  </div>
                )}
              </div>
            )}

            {/* Two-stage generation: Outline first, then story - Only show in Developer Mode */}
            {developerMode && (
              <>
                {!editableOutline ? (
                  // Stage 1: Generate Outline
                  <>
                    <button
                      onClick={generateOutline}
                      disabled={isGeneratingOutline || characters.length === 0 || (userQuota && !userQuota.unlimited && userQuota.remaining <= 0)}
                      className={`w-full py-4 rounded-lg font-bold text-lg flex items-center justify-center gap-2 ${
                        isGeneratingOutline || characters.length === 0 || (userQuota && !userQuota.unlimited && userQuota.remaining <= 0)
                          ? 'bg-gray-300 text-gray-500 cursor-not-allowed'
                          : 'bg-purple-500 text-white hover:bg-purple-600'
                      }`}
                    >
                      <Icon name="list" size={24} />
                      {isGeneratingOutline ? t.generatingOutline : t.generateOutline}
                    </button>
                    {userQuota && !userQuota.unlimited && userQuota.remaining <= 0 && (
                      <p className="text-sm text-red-600 font-semibold mt-2 text-center">
                        {language === 'de' ? 'Keine Credits mehr verfÃ¼gbar. Kontaktieren Sie den Administrator fÃ¼r mehr Credits.' :
                         language === 'fr' ? 'Plus de crÃ©dits disponibles. Contactez l\'administrateur pour plus de crÃ©dits.' :
                         'No credits remaining. Contact administrator for more credits.'}
                      </p>
                    )}
                  </>
                ) : (
                  // Stage 2: Show outline and Generate Story button
                  <div className="space-y-4">
                    <div className="md:bg-green-50 md:border-2 md:border-green-200 md:rounded-xl p-4 md:p-6">
                      <div className="flex justify-between items-center mb-3">
                        <h3 className="text-lg font-bold text-green-700">{t.outlineReady}</h3>
                        <button
                          onClick={() => {
                            setEditableOutline('');
                            setStoryOutline('');
                          }}
                          className="bg-orange-500 text-white px-3 py-1 rounded-lg hover:bg-orange-600 flex items-center gap-1 text-sm"
                        >
                          <Icon name="refresh-cw" size={14} />
                          {t.regenerateOutline}
                        </button>
                      </div>
                      <p className="text-sm text-green-700 mb-3">{t.editOutline}</p>
                      <textarea
                        value={editableOutline}
                        onChange={(e) => setEditableOutline(e.target.value)}
                        className="w-full h-64 px-4 py-3 border-2 border-green-300 rounded-lg resize-y bg-white"
                        placeholder="Story outline..."
                      />
                    </div>

                    <button
                      onClick={generateStory}
                      disabled={isGenerating || !editableOutline || (userQuota && !userQuota.unlimited && userQuota.remaining <= 0)}
                      className={`w-full py-4 rounded-lg font-bold text-lg flex items-center justify-center gap-2 ${
                        isGenerating || !editableOutline || (userQuota && !userQuota.unlimited && userQuota.remaining <= 0)
                          ? 'bg-gray-300 text-gray-500 cursor-not-allowed'
                          : 'bg-blue-500 text-white hover:bg-blue-600'
                      }`}
                    >
                      <Icon name="wand-2" size={24} />
                      {isGenerating ? t.creating : t.generateStory}
                    </button>
                    {userQuota && !userQuota.unlimited && userQuota.remaining <= 0 && (
                      <p className="text-sm text-red-600 font-semibold mt-2 text-center">
                        {language === 'de' ? 'Keine Credits mehr verfÃ¼gbar. Kontaktieren Sie den Administrator fÃ¼r mehr Credits.' :
                         language === 'fr' ? 'Plus de crÃ©dits disponibles. Contactez l\'administrateur pour plus de crÃ©dits.' :
                         'No credits remaining. Contact administrator for more credits.'}
                      </p>
                    )}
                  </div>
                )}
              </>
            )}

            {/* Progress indicator for multi-part generation */}
            {generationProgress.total > 0 && (
              <div className="mt-6 bg-blue-50 border-2 border-blue-200 rounded-lg p-4">
                <div className="mb-2">
                  <div className="w-full bg-blue-200 rounded-full h-2 overflow-hidden">
                    <div
                      className="bg-blue-500 h-full rounded-full transition-all duration-500 ease-out"
                      style={{ width: `${(generationProgress.current / generationProgress.total) * 100}%` }}
                    ></div>
                  </div>
                </div>
                <p className="text-xs text-blue-600 text-center">
                  {language === 'de' ? 'Geschichte wird generiert, dies kann einige Minuten dauern...' :
                   language === 'fr' ? 'GÃ©nÃ©ration de l\'histoire, cela peut prendre quelques minutes...' :
                   'Generating story, this will take a few minutes...'}
                </p>
              </div>
            )}

            {/* Generate Story Button - At the very end */}
            {(!currentUser || currentUser.role !== 'admin' || !developerMode) && (
              <button
                onClick={runAutoMode}
                disabled={characters.length === 0 || isGenerating || isGeneratingOutline || isGeneratingScenes || isGeneratingImages || (userQuota && !userQuota.unlimited && userQuota.remaining <= 0)}
                className={`w-full py-3 rounded-lg font-bold text-base flex items-center justify-center gap-2 ${
                  characters.length === 0 || isGenerating || isGeneratingOutline || isGeneratingScenes || isGeneratingImages || (userQuota && !userQuota.unlimited && userQuota.remaining <= 0)
                    ? 'bg-gray-400 cursor-not-allowed'
                    : 'bg-purple-600 text-white hover:bg-purple-700'
                }`}
              >
                <Icon name="sparkles" size={20} />
                {language === 'de' ? 'Geschichte Generieren' : language === 'fr' ? 'GÃ©nÃ©rer l\'histoire' : 'Generate Story'}
              </button>
            )}
            {userQuota && !userQuota.unlimited && userQuota.remaining <= 0 && (
              <p className="text-xs text-red-600 font-semibold text-center">
                {language === 'de' ? 'Keine Credits mehr verfÃ¼gbar. Kontaktieren Sie den Administrator fÃ¼r mehr Credits.' :
                 language === 'fr' ? 'Plus de crÃ©dits disponibles. Contactez l\'administrateur pour plus de crÃ©dits.' :
                 'No credits remaining. Contact administrator for more credits.'}
              </p>
            )}
          </div>
        </div>
      );

      const renderStep5 = () => {
        // Parse story by pages for side-by-side display
        const pageMatches = generatedStory ? generatedStory.split(/---\s*Page\s+\d+\s*---/i) : [];
        const storyPages = pageMatches.slice(1).filter(p => p.trim().length > 0);

        return (
        <div className="space-y-6">
          <div className="flex justify-between items-center flex-wrap gap-3">
            <h2 className="text-2xl font-bold text-purple-700 flex items-center gap-2">
              <Icon name="book-open" size={24} /> {t.yourStory}
            </h2>
            {currentUser && currentUser.role === 'admin' && (
              <div className="flex items-center gap-3">
                {/* Developer Mode Toggle - Admin only */}
                <div className="flex items-center gap-2 bg-gray-100 px-3 py-2 rounded-lg border border-gray-300">
                  <label className="flex items-center gap-2 cursor-pointer">
                    <input
                      type="checkbox"
                      checked={developerMode}
                      onChange={(e) => setDeveloperMode(e.target.checked)}
                      className="w-4 h-4"
                    />
                    <span className="text-sm font-semibold text-gray-700">
                      {language === 'de' ? 'Entwicklermodus' : language === 'fr' ? 'Mode dÃ©veloppeur' : 'Developer Mode'}
                    </span>
                  </label>
                </div>
                <label className="bg-orange-500 text-white px-4 py-2 rounded-lg hover:bg-orange-600 cursor-pointer flex items-center gap-2 text-sm">
                  <Icon name="upload" size={18} /> {t.uploadStory}
                  <input
                    type="file"
                    accept=".txt,.md"
                    onChange={uploadStory}
                    className="hidden"
                  />
                </label>
              </div>
            )}
          </div>

          {/* 1. Prompt Used - Developer Mode Only */}
          {developerMode && generatedPrompt && (
            <div className="bg-gray-50 border-2 border-gray-300 rounded-xl p-6">
              <div className="flex justify-between items-center mb-4">
                <h3 className="text-lg font-bold text-gray-700">{t.promptUsed}</h3>
                <button
                  onClick={() => setShowPrompt(!showPrompt)}
                  className="bg-gray-500 text-white px-4 py-2 rounded-lg hover:bg-gray-600 flex items-center gap-2"
                >
                  <Icon name={showPrompt ? "eye-off" : "eye"} size={20} />
                  {showPrompt ? t.hidePrompt : t.viewPrompt}
                </button>
              </div>
              {showPrompt && (
                <div className="bg-white border border-gray-300 rounded-lg p-4 mt-4">
                  <pre className="whitespace-pre-wrap text-sm text-gray-700 font-mono">
                    {generatedPrompt}
                  </pre>
                </div>
              )}
            </div>
          )}

          {/* 2. Story Outline - Developer Mode Only */}
          {developerMode && storyOutline && (
            <div className="md:bg-yellow-50 md:border-2 md:border-yellow-300 md:rounded-xl p-4 md:p-6">
              <h3 className="text-lg font-bold text-yellow-700 mb-3 flex items-center gap-2">
                <Icon name="list" size={20} /> Story Outline
              </h3>
              <div className="bg-white border border-yellow-200 rounded-lg p-4">
                <pre className="whitespace-pre-wrap text-sm text-gray-700 font-mono">
                  {storyOutline}
                </pre>
              </div>
            </div>
          )}

          {/* 3. Full Story Text - Developer Mode Only */}
          {developerMode && (
            <div className="md:bg-white md:border-2 md:border-purple-200 md:rounded-xl p-4 md:p-8">
              <div className="flex justify-between items-center mb-4">
                <h3 className="text-lg font-bold text-purple-700">Full Story Text</h3>
                <button
                  onClick={() => {
                    if (editingStory) {
                      setGeneratedStory(editableStory);
                      setEditingStory(false);
                    } else {
                      setEditableStory(generatedStory);
                      setEditingStory(true);
                    }
                  }}
                  className="bg-purple-500 text-white px-4 py-2 rounded-lg hover:bg-purple-600 flex items-center gap-2"
                >
                  <Icon name={editingStory ? "save" : "edit"} size={16} />
                  {editingStory ? t.saveStory : t.editStory}
                </button>
              </div>
              {editingStory ? (
                <textarea
                  value={editableStory}
                  onChange={(e) => setEditableStory(e.target.value)}
                  className="w-full h-96 px-4 py-3 border border-gray-300 rounded-lg font-serif text-gray-800 resize-none"
                />
              ) : (
                <div className="prose max-w-none whitespace-pre-wrap leading-relaxed text-gray-800">
                  {generatedStory}
                </div>
              )}
            </div>
          )}

          <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-3">
            {/* Admin only: TXT and PDF downloads */}
            {currentUser && currentUser.role === 'admin' && (
              <>
                <button
                  onClick={() => downloadStory('txt')}
                  className="bg-blue-500 text-white px-6 py-3 rounded-lg hover:bg-blue-600 font-semibold flex items-center justify-center gap-2"
                >
                  <Icon name="download" size={20} /> {t.downloadTXT}
                </button>
              </>
            )}
            {/* All users: Printable PDF */}
            {sceneImages.length > 0 && (
              <button
                onClick={downloadPrintablePDF}
                className="bg-green-500 text-white px-6 py-3 rounded-lg hover:bg-green-600 font-semibold flex items-center justify-center gap-2"
              >
                <Icon name="file-text" size={20} /> {language === 'de' ? 'PDF herunterladen' : language === 'fr' ? 'TÃ©lÃ©charger PDF' : 'Download PDF'}
              </button>
            )}
            {/* All users: Print Book via Gelato */}
            {sceneImages.length > 0 && (
              <button
                onClick={orderPrintedBook}
                className="bg-purple-500 text-white px-6 py-3 rounded-lg hover:bg-purple-600 font-semibold flex items-center justify-center gap-2"
              >
                <Icon name="printer" size={20} /> {language === 'de' ? 'Buch drucken' : language === 'fr' ? 'Imprimer le livre' : 'Print Book'}
              </button>
            )}
            {/* Developer Mode Only: Buy Book via Stripe */}
            {developerMode && sceneImages.length > 0 && (
              <a
                href="https://buy.stripe.com/bJe8wHdtFbqofebgxK8Zq00"
                target="_blank"
                rel="noopener noreferrer"
                className="bg-orange-500 text-white px-6 py-3 rounded-lg hover:bg-orange-600 font-semibold flex items-center justify-center gap-2"
              >
                <Icon name="shopping-cart" size={20} /> Buy Book
              </a>
            )}
            {currentUser && currentUser.role === 'admin' && generatedPrompt && (
              <button
                onClick={downloadPrompt}
                className="bg-blue-500 text-white px-6 py-3 rounded-lg hover:bg-blue-600 font-semibold flex items-center justify-center gap-2"
              >
                <Icon name="download" size={20} /> {t.downloadPrompt}
              </button>
            )}
            {currentUser && currentUser.role === 'admin' && (
              <>
                <button
                  onClick={exportConfiguration}
                  className="bg-blue-500 text-white px-6 py-3 rounded-lg hover:bg-blue-600 font-semibold flex items-center justify-center gap-2"
                >
                  <Icon name="save" size={20} /> {t.exportConfig}
                </button>
                <button
                  onClick={generateScenes}
                  disabled={isGeneratingScenes || !generatedStory}
                  className={`px-6 py-3 rounded-lg font-semibold flex items-center justify-center gap-2 ${
                    isGeneratingScenes || !generatedStory
                      ? 'bg-gray-300 text-gray-500 cursor-not-allowed'
                      : 'bg-green-500 text-white hover:bg-green-600'
                  }`}
                >
                  <Icon name="image" size={20} /> {isGeneratingScenes ? t.creatingScenes : t.createScenes}
                </button>
              </>
            )}
            {currentUser && currentUser.role === 'admin' && sceneDescriptions.length > 0 && (
              <>
                <button
                  onClick={downloadScenes}
                  className="bg-green-500 text-white px-6 py-3 rounded-lg hover:bg-green-600 font-semibold flex items-center justify-center gap-2"
                >
                  <Icon name="download" size={20} /> {t.downloadScenes}
                </button>
                <button
                  onClick={generateSceneImages}
                  disabled={isGeneratingImages}
                  className={`px-6 py-3 rounded-lg font-semibold flex items-center justify-center gap-2 ${
                    isGeneratingImages
                      ? 'bg-gray-300 text-gray-500 cursor-not-allowed'
                      : 'bg-indigo-500 text-white hover:bg-indigo-600'
                  }`}
                >
                  <Icon name="sparkles" size={20} /> {isGeneratingImages ? t.generatingImages : t.generateImages}
                </button>
              </>
            )}
            {currentUser && currentUser.role === 'admin' && sceneImages.length > 0 && (
              <button
                onClick={() => {
                  sceneImages.forEach((img, i) => {
                    if (img.imageData) {
                      setTimeout(() => downloadImage(img.imageData, img.pageNumber), i * 100);
                    }
                  });
                }}
                className="bg-indigo-500 text-white px-6 py-3 rounded-lg hover:bg-indigo-600 font-semibold flex items-center justify-center gap-2"
              >
                <Icon name="download" size={20} /> Download All Images
              </button>
            )}
            <button
              onClick={() => {
                setStep(1);
                setGeneratedStory('');
                setGeneratedPrompt('');
                setShowPrompt(false);
                setCharacters([]);
                setRelationships({});
                setStoryType('');
                setMainCharacters([]);
                setSceneDescriptions([]);
                setSceneImages([]);
                setEditableOutline('');
                setStoryOutline('');
              }}
              className="bg-purple-500 text-white px-6 py-3 rounded-lg hover:bg-purple-600 font-semibold flex items-center justify-center gap-2 sm:col-span-2 lg:col-span-1"
            >
              {t.createAnotherStory}
            </button>
          </div>

          {/* MOVED: Side-by-Side story moved to end after images section */}
          {false && sceneImages.length > 0 && (
            <div className="space-y-8 mt-8">
              <h3 className="text-2xl font-bold text-purple-700 text-center mb-6">
                {language === 'de' ? 'Ihre vollstÃ¤ndige Geschichte' : language === 'fr' ? 'Votre histoire complÃ¨te' : 'Your Complete Story'}
              </h3>

              {storyPages.map((pageText, index) => {
                const pageNumber = index + 1;
                const image = sceneImages.find(img => img.pageNumber === pageNumber);

                return (
                  <div key={pageNumber} className="bg-white border-2 border-purple-300 rounded-xl p-6 shadow-lg">
                    <h4 className="text-xl font-bold text-purple-700 mb-4 text-center">
                      {language === 'de' ? `Seite ${pageNumber}` : language === 'fr' ? `Page ${pageNumber}` : `Page ${pageNumber}`}
                    </h4>

                    <div className="grid md:grid-cols-2 gap-6">
                      {/* Image on the left */}
                      {image && image.imageData ? (
                        <div className="flex flex-col">
                          <img
                            src={image.imageData}
                            alt={`Scene for page ${pageNumber}`}
                            className="w-full rounded-lg shadow-md object-cover"
                          />
                          {developerMode && (
                            <button
                              onClick={() => downloadImage(image.imageData, pageNumber)}
                              className="mt-3 bg-indigo-500 text-white px-4 py-2 rounded-lg hover:bg-indigo-600 flex items-center justify-center gap-2 text-sm"
                            >
                              <Icon name="download" size={16} /> Download Image
                            </button>
                          )}
                        </div>
                      ) : (
                        <div className="flex items-center justify-center bg-gray-100 rounded-lg p-8">
                          <p className="text-gray-500 text-center">
                            {language === 'de' ? 'Kein Bild fÃ¼r diese Seite' : language === 'fr' ? 'Pas d\'image pour cette page' : 'No image for this page'}
                          </p>
                        </div>
                      )}

                      {/* Text on the right */}
                      <div className="flex items-center">
                        <div className="prose max-w-none">
                          <p className="text-gray-800 leading-relaxed whitespace-pre-wrap font-serif text-lg">
                            {pageText.trim()}
                          </p>
                        </div>
                      </div>
                    </div>
                  </div>
                );
              })}
            </div>
          )}

          {/* Display Scene Descriptions - Developer Mode Only */}
          {developerMode && sceneDescriptions.length > 0 && (
            <div className="md:bg-green-50 md:border-2 md:border-green-200 md:rounded-xl p-4 md:p-6 mt-6">
              <h3 className="text-xl font-bold text-green-700 mb-4 flex items-center gap-2">
                <Icon name="image" size={24} /> {t.scenesReady}
              </h3>

              <div className="space-y-6">
                {sceneDescriptions.map((scene, index) => (
                  <div key={index} className="bg-white border-2 border-green-300 rounded-lg p-6">
                    <div className="flex justify-between items-center mb-3">
                      <h4 className="text-lg font-bold text-green-700">
                        {t.sceneForPage} {scene.pageNumber}
                      </h4>
                      <button
                        onClick={() => {
                          if (editingSceneIndex === index) {
                            // Save the edited scene
                            const updatedScenes = [...sceneDescriptions];
                            updatedScenes[index] = { ...scene, description: editableScene };
                            setSceneDescriptions(updatedScenes);
                            setEditingSceneIndex(null);
                          } else {
                            // Start editing
                            setEditableScene(scene.description);
                            setEditingSceneIndex(index);
                          }
                        }}
                        className="bg-green-500 text-white px-3 py-1 rounded-lg hover:bg-green-600 flex items-center gap-1 text-sm"
                      >
                        <Icon name={editingSceneIndex === index ? "save" : "edit"} size={14} />
                        {editingSceneIndex === index ? t.saveScene : t.editScene}
                      </button>
                    </div>
                    {editingSceneIndex === index ? (
                      <textarea
                        value={editableScene}
                        onChange={(e) => setEditableScene(e.target.value)}
                        className="w-full h-32 px-3 py-2 border border-gray-300 rounded-lg resize-none"
                      />
                    ) : (
                      <p className="text-gray-700 leading-relaxed whitespace-pre-wrap">
                        {scene.description}
                      </p>
                    )}

                    {/* Show individual prompt for this scene */}
                    {sceneDescriptionPrompts[scene.pageNumber] && (
                      <details className="bg-gray-50 border border-gray-300 rounded-lg p-3 mt-3">
                        <summary className="cursor-pointer text-sm font-semibold text-gray-700 hover:text-gray-900">
                          {t.showPrompt} (Page {scene.pageNumber})
                        </summary>
                        <pre className="mt-2 text-xs text-gray-600 whitespace-pre-wrap font-mono bg-white p-3 rounded border border-gray-200 overflow-x-auto">
                          {sceneDescriptionPrompts[scene.pageNumber]}
                        </pre>
                      </details>
                    )}
                  </div>
                ))}
              </div>
            </div>
          )}

          {/* Display Cover Images with Controls */}
          {(coverImages.frontCover || coverImages.page0 || coverImages.backCover || coverImagePrompts.frontCover || coverImagePrompts.page0 || coverImagePrompts.backCover) && (
            <div className="bg-purple-50 border-2 border-purple-200 rounded-xl p-6 mt-6">
              <h3 className="text-xl font-bold text-purple-700 mb-4 flex items-center gap-2">
                <Icon name="book" size={24} /> Cover Pages
              </h3>
              <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
                {/* Front Cover / Title Page */}
                {(coverImages.frontCover || coverImagePrompts.frontCover) && (
                  <div className="bg-white border-2 border-purple-300 rounded-lg p-4 shadow-lg">
                    <h4 className="text-lg font-bold text-purple-700 mb-3">Front Cover / Title Page</h4>
                    {coverImages.frontCover ? (
                      <>
                        <img
                          src={coverImages.frontCover}
                          alt="Front Cover"
                          className="w-full rounded-lg shadow-md mb-3"
                        />
                        {currentUser && currentUser.role === 'admin' && (
                          <>
                            <div className="flex gap-2 mb-3">
                              <button
                                onClick={async () => {
                                  if (confirm('Regenerate front cover?')) {
                                    try {
                                      const prompt = coverImagePrompts.frontCover;
                                      const newImage = await callGeminiAPI(prompt);
                                      setCoverImages({...coverImages, frontCover: newImage});
                                    } catch (error) {
                                      alert(`Error: ${error.message}`);
                                    }
                                  }
                                }}
                                className="flex-1 bg-orange-500 text-white px-3 py-2 rounded-lg hover:bg-orange-600 flex items-center justify-center gap-1 text-sm font-semibold"
                              >
                                <Icon name="refresh-cw" size={14} /> {t.regenerateImage}
                              </button>
                              <button
                                onClick={() => {
                                  setEditingCoverImage(editingCoverImage === 'frontCover' ? null : 'frontCover');
                                  setCoverEditInstruction('');
                                }}
                                className="flex-1 bg-purple-500 text-white px-3 py-2 rounded-lg hover:bg-purple-600 flex items-center justify-center gap-1 text-sm"
                              >
                                <Icon name="edit" size={14} /> {t.editImage}
                              </button>
                            </div>
                          </>
                        )}
                      </>
                    ) : (
                      <div className="bg-red-50 border-2 border-red-200 rounded-lg p-4 text-red-700 mb-3">
                        <p className="font-semibold">âš ï¸ Error generating image</p>
                      </div>
                    )}

                    {currentUser && currentUser.role === 'admin' && editingCoverImage === 'frontCover' && (
                      <div className="bg-purple-50 border-2 border-purple-300 rounded-lg p-3 mb-3">
                        <p className="text-sm font-semibold text-purple-700 mb-2">{t.editInstruction}</p>
                        <textarea
                          value={coverEditInstruction}
                          onChange={(e) => setCoverEditInstruction(e.target.value)}
                          placeholder={coverImagePrompts.frontCover || "Enter prompt..."}
                          className="w-full px-3 py-2 border border-purple-300 rounded-lg text-sm mb-2 h-24"
                        />
                        <button
                          onClick={async () => {
                            if (!coverEditInstruction.trim()) {
                              alert('Please enter a prompt');
                              return;
                            }
                            try {
                              const newImage = await callGeminiAPI(coverEditInstruction);
                              setCoverImages({...coverImages, frontCover: newImage});
                              setCoverImagePrompts({...coverImagePrompts, frontCover: coverEditInstruction});
                              setEditingCoverImage(null);
                              setCoverEditInstruction('');
                            } catch (error) {
                              alert(`Error: ${error.message}`);
                            }
                          }}
                          className="w-full bg-purple-600 text-white px-4 py-2 rounded-lg hover:bg-purple-700 text-sm font-semibold"
                        >
                          {t.applyEdit}
                        </button>
                      </div>
                    )}

                    {currentUser && currentUser.role === 'admin' && coverImagePrompts.frontCover && (
                      <details className="bg-gray-50 border border-gray-300 rounded-lg p-3 mb-2">
                        <summary className="cursor-pointer text-sm font-semibold text-gray-700 hover:text-gray-900">
                          {t.showPrompt}
                        </summary>
                        <pre className="mt-2 text-xs text-gray-600 whitespace-pre-wrap font-mono bg-white p-3 rounded border border-gray-200 overflow-x-auto">
                          {coverImagePrompts.frontCover}
                        </pre>
                      </details>
                    )}

                    {currentUser && currentUser.role === 'admin' && coverImageApiCalls.frontCover && (
                      <details className="bg-blue-50 border border-blue-300 rounded-lg p-3">
                        <summary className="cursor-pointer text-sm font-semibold text-blue-700 hover:text-blue-900">
                          {language === 'de' ? 'API-Aufruf anzeigen' : language === 'fr' ? 'Afficher l\'appel API' : 'Show API Call'}
                        </summary>
                        <div className="mt-2 text-xs text-gray-700">
                          <div className="mb-2"><span className="font-semibold">Model:</span> {coverImageApiCalls.frontCover.model}</div>
                          <div className="mb-2"><span className="font-semibold">Type:</span> {coverImageApiCalls.frontCover.type}</div>
                          <pre className="text-xs text-gray-600 whitespace-pre-wrap font-mono bg-white p-3 rounded border border-gray-200 overflow-x-auto max-h-96">
                            {JSON.stringify(coverImageApiCalls.frontCover, null, 2)}
                          </pre>
                        </div>
                      </details>
                    )}
                  </div>
                )}

                {/* Page 0 */}
                {(coverImages.page0 || coverImagePrompts.page0) && (
                  <div className="bg-white border-2 border-purple-300 rounded-lg p-4 shadow-lg">
                    <h4 className="text-lg font-bold text-purple-700 mb-3">Page 0</h4>
                    {coverImages.page0 ? (
                      <>
                        <img
                          src={coverImages.page0}
                          alt="Page 0"
                          className="w-full rounded-lg shadow-md mb-3"
                        />
                        {currentUser && currentUser.role === 'admin' && (
                          <>
                            <div className="flex gap-2 mb-3">
                              <button
                                onClick={async () => {
                                  if (confirm('Regenerate Page 0?')) {
                                    try {
                                      const prompt = coverImagePrompts.page0;
                                      const newImage = await callGeminiAPI(prompt);
                                      setCoverImages({...coverImages, page0: newImage});
                                    } catch (error) {
                                      alert(`Error: ${error.message}`);
                                    }
                                  }
                                }}
                                className="flex-1 bg-orange-500 text-white px-3 py-2 rounded-lg hover:bg-orange-600 flex items-center justify-center gap-1 text-sm font-semibold"
                              >
                                <Icon name="refresh-cw" size={14} /> {t.regenerateImage}
                              </button>
                              <button
                                onClick={() => {
                                  setEditingCoverImage(editingCoverImage === 'page0' ? null : 'page0');
                                  setCoverEditInstruction('');
                                }}
                                className="flex-1 bg-purple-500 text-white px-3 py-2 rounded-lg hover:bg-purple-600 flex items-center justify-center gap-1 text-sm"
                              >
                                <Icon name="edit" size={14} /> {t.editImage}
                              </button>
                            </div>
                          </>
                        )}
                      </>
                    ) : (
                      <div className="bg-red-50 border-2 border-red-200 rounded-lg p-4 text-red-700 mb-3">
                        <p className="font-semibold">âš ï¸ Error generating image</p>
                      </div>
                    )}

                    {currentUser && currentUser.role === 'admin' && editingCoverImage === 'page0' && (
                      <div className="bg-purple-50 border-2 border-purple-300 rounded-lg p-3 mb-3">
                        <p className="text-sm font-semibold text-purple-700 mb-2">{t.editInstruction}</p>
                        <textarea
                          value={coverEditInstruction}
                          onChange={(e) => setCoverEditInstruction(e.target.value)}
                          placeholder={coverImagePrompts.page0 || "Enter prompt..."}
                          className="w-full px-3 py-2 border border-purple-300 rounded-lg text-sm mb-2 h-24"
                        />
                        <button
                          onClick={async () => {
                            if (!coverEditInstruction.trim()) {
                              alert('Please enter a prompt');
                              return;
                            }
                            try {
                              const newImage = await callGeminiAPI(coverEditInstruction);
                              setCoverImages({...coverImages, page0: newImage});
                              setCoverImagePrompts({...coverImagePrompts, page0: coverEditInstruction});
                              setEditingCoverImage(null);
                              setCoverEditInstruction('');
                            } catch (error) {
                              alert(`Error: ${error.message}`);
                            }
                          }}
                          className="w-full bg-purple-600 text-white px-4 py-2 rounded-lg hover:bg-purple-700 text-sm font-semibold"
                        >
                          {t.applyEdit}
                        </button>
                      </div>
                    )}

                    {currentUser && currentUser.role === 'admin' && coverImagePrompts.page0 && (
                      <details className="bg-gray-50 border border-gray-300 rounded-lg p-3 mb-2">
                        <summary className="cursor-pointer text-sm font-semibold text-gray-700 hover:text-gray-900">
                          {t.showPrompt}
                        </summary>
                        <pre className="mt-2 text-xs text-gray-600 whitespace-pre-wrap font-mono bg-white p-3 rounded border border-gray-200 overflow-x-auto">
                          {coverImagePrompts.page0}
                        </pre>
                      </details>
                    )}

                    {currentUser && currentUser.role === 'admin' && coverImageApiCalls.page0 && (
                      <details className="bg-blue-50 border border-blue-300 rounded-lg p-3">
                        <summary className="cursor-pointer text-sm font-semibold text-blue-700 hover:text-blue-900">
                          {language === 'de' ? 'API-Aufruf anzeigen' : language === 'fr' ? 'Afficher l\'appel API' : 'Show API Call'}
                        </summary>
                        <div className="mt-2 text-xs text-gray-700">
                          <div className="mb-2"><span className="font-semibold">Model:</span> {coverImageApiCalls.page0.model}</div>
                          <div className="mb-2"><span className="font-semibold">Type:</span> {coverImageApiCalls.page0.type}</div>
                          <pre className="text-xs text-gray-600 whitespace-pre-wrap font-mono bg-white p-3 rounded border border-gray-200 overflow-x-auto max-h-96">
                            {JSON.stringify(coverImageApiCalls.page0, null, 2)}
                          </pre>
                        </div>
                      </details>
                    )}
                  </div>
                )}

                {/* Back Cover */}
                {(coverImages.backCover || coverImagePrompts.backCover) && (
                  <div className="bg-white border-2 border-purple-300 rounded-lg p-4 shadow-lg">
                    <h4 className="text-lg font-bold text-purple-700 mb-3">Back Cover</h4>
                    {coverImages.backCover ? (
                      <>
                        <img
                          src={coverImages.backCover}
                          alt="Back Cover"
                          className="w-full rounded-lg shadow-md mb-3"
                        />
                        {currentUser && currentUser.role === 'admin' && (
                          <>
                            <div className="flex gap-2 mb-3">
                              <button
                                onClick={async () => {
                                  if (confirm('Regenerate back cover?')) {
                                    try {
                                      const prompt = coverImagePrompts.backCover;
                                      const newImage = await callGeminiAPI(prompt);
                                      setCoverImages({...coverImages, backCover: newImage});
                                    } catch (error) {
                                      alert(`Error: ${error.message}`);
                                    }
                                  }
                                }}
                                className="flex-1 bg-orange-500 text-white px-3 py-2 rounded-lg hover:bg-orange-600 flex items-center justify-center gap-1 text-sm font-semibold"
                              >
                                <Icon name="refresh-cw" size={14} /> {t.regenerateImage}
                              </button>
                              <button
                                onClick={() => {
                                  setEditingCoverImage(editingCoverImage === 'backCover' ? null : 'backCover');
                                  setCoverEditInstruction('');
                                }}
                                className="flex-1 bg-purple-500 text-white px-3 py-2 rounded-lg hover:bg-purple-600 flex items-center justify-center gap-1 text-sm"
                              >
                                <Icon name="edit" size={14} /> {t.editImage}
                              </button>
                            </div>
                          </>
                        )}
                      </>
                    ) : (
                      <div className="bg-red-50 border-2 border-red-200 rounded-lg p-4 text-red-700 mb-3">
                        <p className="font-semibold">âš ï¸ Error generating image</p>
                      </div>
                    )}

                    {editingCoverImage === 'backCover' && (
                      <div className="bg-purple-50 border-2 border-purple-300 rounded-lg p-3 mb-3">
                        <p className="text-sm font-semibold text-purple-700 mb-2">{t.editInstruction}</p>
                        <textarea
                          value={coverEditInstruction}
                          onChange={(e) => setCoverEditInstruction(e.target.value)}
                          placeholder={coverImagePrompts.backCover || "Enter prompt..."}
                          className="w-full px-3 py-2 border border-purple-300 rounded-lg text-sm mb-2 h-24"
                        />
                        <button
                          onClick={async () => {
                            if (!coverEditInstruction.trim()) {
                              alert('Please enter a prompt');
                              return;
                            }
                            try {
                              const newImage = await callGeminiAPI(coverEditInstruction);
                              setCoverImages({...coverImages, backCover: newImage});
                              setCoverImagePrompts({...coverImagePrompts, backCover: coverEditInstruction});
                              setEditingCoverImage(null);
                              setCoverEditInstruction('');
                            } catch (error) {
                              alert(`Error: ${error.message}`);
                            }
                          }}
                          className="w-full bg-purple-600 text-white px-4 py-2 rounded-lg hover:bg-purple-700 text-sm font-semibold"
                        >
                          {t.applyEdit}
                        </button>
                      </div>
                    )}

                    {currentUser && currentUser.role === 'admin' && coverImagePrompts.backCover && (
                      <details className="bg-gray-50 border border-gray-300 rounded-lg p-3 mb-2">
                        <summary className="cursor-pointer text-sm font-semibold text-gray-700 hover:text-gray-900">
                          {t.showPrompt}
                        </summary>
                        <pre className="mt-2 text-xs text-gray-600 whitespace-pre-wrap font-mono bg-white p-3 rounded border border-gray-200 overflow-x-auto">
                          {coverImagePrompts.backCover}
                        </pre>
                      </details>
                    )}

                    {currentUser && currentUser.role === 'admin' && coverImageApiCalls.backCover && (
                      <details className="bg-blue-50 border border-blue-300 rounded-lg p-3">
                        <summary className="cursor-pointer text-sm font-semibold text-blue-700 hover:text-blue-900">
                          {language === 'de' ? 'API-Aufruf anzeigen' : language === 'fr' ? 'Afficher l\'appel API' : 'Show API Call'}
                        </summary>
                        <div className="mt-2 text-xs text-gray-700">
                          <div className="mb-2"><span className="font-semibold">Model:</span> {coverImageApiCalls.backCover.model}</div>
                          <div className="mb-2"><span className="font-semibold">Type:</span> {coverImageApiCalls.backCover.type}</div>
                          <pre className="text-xs text-gray-600 whitespace-pre-wrap font-mono bg-white p-3 rounded border border-gray-200 overflow-x-auto max-h-96">
                            {JSON.stringify(coverImageApiCalls.backCover, null, 2)}
                          </pre>
                        </div>
                      </details>
                    )}
                  </div>
                )}
              </div>
            </div>
          )}

          {/* Display Generated Images - Developer Mode Only */}
          {developerMode && sceneImages.length > 0 && (
            <div className="bg-indigo-50 border-2 border-indigo-200 rounded-xl p-6 mt-6">
              <h3 className="text-xl font-bold text-indigo-700 mb-4 flex items-center gap-2">
                <Icon name="sparkles" size={24} /> {t.imagesReady}
              </h3>
              <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                {sceneImages.map((image, index) => (
                  <div key={index} className="bg-white border-2 border-indigo-300 rounded-lg p-4 shadow-lg">
                    <div className="flex justify-between items-center mb-3">
                      <h4 className="text-lg font-bold text-indigo-700">
                        {t.imageForPage} {image.pageNumber}
                      </h4>
                      {image.imageData && (
                        <button
                          onClick={() => downloadImage(image.imageData, image.pageNumber)}
                          className="bg-indigo-500 text-white px-3 py-1 rounded-lg hover:bg-indigo-600 flex items-center gap-1 text-sm"
                        >
                          <Icon name="download" size={16} /> {t.downloadImage}
                        </button>
                      )}
                    </div>
                    {image.imageData ? (
                      <>
                        <img
                          src={image.imageData}
                          alt={`Scene for page ${image.pageNumber}`}
                          className="w-full rounded-lg shadow-md mb-3"
                        />

                        {/* Image Action Buttons */}
                        <div className="flex gap-2 mb-3">
                          <button
                            onClick={() => {
                              const scene = sceneDescriptions.find(s => s.pageNumber === image.pageNumber);
                              if (scene) {
                                const confirmed = confirm(`Regenerate image for page ${image.pageNumber}?`);
                                if (confirmed) {
                                  // Regenerate this specific image
                                  (async () => {
                                    try {
                                      const imagePrompt = imagePrompts[image.pageNumber];
                                      if (imagePrompt) {
                                        const newImageData = await callGeminiAPI(imagePrompt);
                                        const updatedImages = [...sceneImages];
                                        updatedImages[index] = { ...image, imageData: newImageData };
                                        setSceneImages(updatedImages);
                                      }
                                    } catch (error) {
                                      alert(`Error regenerating image: ${error.message}`);
                                    }
                                  })();
                                }
                              }
                            }}
                            className="flex-1 bg-orange-500 text-white px-3 py-2 rounded-lg hover:bg-orange-600 flex items-center justify-center gap-1 text-sm"
                          >
                            <Icon name="refresh-cw" size={14} /> {t.regenerateImage}
                          </button>
                          <button
                            onClick={() => {
                              if (editingImageIndex === index) {
                                setEditingImageIndex(null);
                                setImageEditInstruction('');
                              } else {
                                setEditingImageIndex(index);
                                setImageEditInstruction('');
                              }
                            }}
                            className="flex-1 bg-purple-500 text-white px-3 py-2 rounded-lg hover:bg-purple-600 flex items-center justify-center gap-1 text-sm"
                          >
                            <Icon name="edit" size={14} /> {t.editImage}
                          </button>
                        </div>

                        {/* Edit Image Interface */}
                        {editingImageIndex === index && (
                          <div className="bg-purple-50 border-2 border-purple-300 rounded-lg p-3 mb-3">
                            <p className="text-sm font-semibold text-purple-700 mb-2">{t.editInstruction}</p>
                            <input
                              type="text"
                              value={imageEditInstruction}
                              onChange={(e) => setImageEditInstruction(e.target.value)}
                              placeholder="e.g., Make the sky darker, add more trees..."
                              className="w-full px-3 py-2 border border-purple-300 rounded-lg text-sm mb-2"
                            />
                            <button
                              onClick={async () => {
                                if (!imageEditInstruction.trim()) {
                                  alert('Please enter edit instructions');
                                  return;
                                }
                                try {
                                  const editedImage = await editImage(image.imageData, imageEditInstruction);
                                  if (editedImage) {
                                    const updatedImages = [...sceneImages];
                                    updatedImages[index] = { ...image, imageData: editedImage };
                                    setSceneImages(updatedImages);
                                    setEditingImageIndex(null);
                                    setImageEditInstruction('');
                                  }
                                } catch (error) {
                                  alert(`Error editing image: ${error.message}`);
                                }
                              }}
                              className="w-full bg-purple-600 text-white px-4 py-2 rounded-lg hover:bg-purple-700 text-sm font-semibold"
                            >
                              {t.applyEdit}
                            </button>
                          </div>
                        )}

                        {/* Show Prompt */}
                        {imagePrompts[image.pageNumber] && (
                          <details className="bg-gray-50 border border-gray-300 rounded-lg p-3 mb-2">
                            <summary className="cursor-pointer text-sm font-semibold text-gray-700 hover:text-gray-900">
                              {t.showPrompt}
                            </summary>
                            <pre className="mt-2 text-xs text-gray-600 whitespace-pre-wrap font-mono bg-white p-3 rounded border border-gray-200 overflow-x-auto">
                              {imagePrompts[image.pageNumber]}
                            </pre>
                          </details>
                        )}

                        {/* Show API Call - Admin only */}
                        {currentUser && currentUser.role === 'admin' && apiCalls[image.pageNumber] && (
                          <details className="bg-blue-50 border border-blue-300 rounded-lg p-3">
                            <summary className="cursor-pointer text-sm font-semibold text-blue-700 hover:text-blue-900">
                              {language === 'de' ? 'API-Aufruf anzeigen' : language === 'fr' ? 'Afficher l\'appel API' : 'Show API Call'}
                            </summary>
                            <div className="mt-2 text-xs text-gray-700">
                              <div className="mb-2">
                                <span className="font-semibold">Endpoint:</span> {apiCalls[image.pageNumber].endpoint}
                              </div>
                              <div className="mb-2">
                                <span className="font-semibold">Method:</span> {apiCalls[image.pageNumber].method}
                              </div>
                              <div className="mb-2">
                                <span className="font-semibold">Timestamp:</span> {new Date(apiCalls[image.pageNumber].timestamp).toLocaleString()}
                              </div>
                              <div className="mb-1 font-semibold">Payload:</div>
                              <pre className="text-xs text-gray-600 whitespace-pre-wrap font-mono bg-white p-3 rounded border border-gray-200 overflow-x-auto max-h-96">
                                {JSON.stringify(apiCalls[image.pageNumber].payload, null, 2)}
                              </pre>
                            </div>
                          </details>
                        )}
                      </>
                    ) : (
                      <>
                        {/* Error Display for Blocked/Failed Images */}
                        <div className="bg-red-50 border-2 border-red-200 rounded-lg p-4 text-red-700 mb-3">
                          <p className="font-semibold">âš ï¸ Error generating image:</p>
                          <p className="text-sm mt-1">{image.error || 'Unknown error'}</p>
                        </div>

                        {/* Action Buttons - Even for Failed Images */}
                        <div className="flex gap-2 mb-3">
                          <button
                            onClick={() => {
                              const scene = sceneDescriptions.find(s => s.pageNumber === image.pageNumber);
                              if (scene) {
                                const confirmed = confirm(`Retry generating image for page ${image.pageNumber}?`);
                                if (confirmed) {
                                  (async () => {
                                    try {
                                      const imagePrompt = imagePrompts[image.pageNumber];
                                      if (imagePrompt) {
                                        const newImageData = await callGeminiAPI(imagePrompt);
                                        const updatedImages = [...sceneImages];
                                        updatedImages[index] = { ...image, imageData: newImageData, error: null };
                                        setSceneImages(updatedImages);
                                      }
                                    } catch (error) {
                                      alert(`Error regenerating image: ${error.message}`);
                                      const updatedImages = [...sceneImages];
                                      updatedImages[index] = { ...image, error: error.message };
                                      setSceneImages(updatedImages);
                                    }
                                  })();
                                }
                              }
                            }}
                            className="flex-1 bg-orange-500 text-white px-3 py-2 rounded-lg hover:bg-orange-600 flex items-center justify-center gap-1 text-sm font-semibold"
                          >
                            <Icon name="refresh-cw" size={14} /> {language === 'de' ? 'Erneut versuchen' : language === 'fr' ? 'RÃ©essayer' : 'Retry'}
                          </button>
                          <button
                            onClick={() => {
                              if (editingImageIndex === index) {
                                setEditingImageIndex(null);
                                setImageEditInstruction('');
                              } else {
                                setEditingImageIndex(index);
                                setImageEditInstruction('');
                              }
                            }}
                            className="flex-1 bg-purple-500 text-white px-3 py-2 rounded-lg hover:bg-purple-600 flex items-center justify-center gap-1 text-sm"
                          >
                            <Icon name="edit" size={14} /> {language === 'de' ? 'Prompt bearbeiten' : language === 'fr' ? 'Modifier le prompt' : 'Edit Prompt'}
                          </button>
                        </div>

                        {/* Edit Prompt Interface for Failed Images */}
                        {editingImageIndex === index && (
                          <div className="bg-purple-50 border-2 border-purple-300 rounded-lg p-3 mb-3">
                            <p className="text-sm font-semibold text-purple-700 mb-2">
                              {language === 'de' ? 'Prompt bearbeiten und erneut versuchen:' : language === 'fr' ? 'Modifier le prompt et rÃ©essayer:' : 'Edit prompt and retry:'}
                            </p>
                            <textarea
                              value={imageEditInstruction}
                              onChange={(e) => setImageEditInstruction(e.target.value)}
                              placeholder={imagePrompts[image.pageNumber] || "Enter new prompt..."}
                              className="w-full px-3 py-2 border border-purple-300 rounded-lg text-sm mb-2 h-24"
                            />
                            <button
                              onClick={async () => {
                                if (!imageEditInstruction.trim()) {
                                  alert('Please enter a prompt');
                                  return;
                                }
                                try {
                                  const newImageData = await callGeminiAPI(imageEditInstruction);
                                  const updatedImages = [...sceneImages];
                                  updatedImages[index] = { ...image, imageData: newImageData, error: null };
                                  setSceneImages(updatedImages);
                                  // Update the prompt
                                  setImagePrompts({...imagePrompts, [image.pageNumber]: imageEditInstruction});
                                  setEditingImageIndex(null);
                                  setImageEditInstruction('');
                                } catch (error) {
                                  alert(`Error generating image: ${error.message}`);
                                  const updatedImages = [...sceneImages];
                                  updatedImages[index] = { ...image, error: error.message };
                                  setSceneImages(updatedImages);
                                }
                              }}
                              className="w-full bg-purple-600 text-white px-4 py-2 rounded-lg hover:bg-purple-700 text-sm font-semibold"
                            >
                              {language === 'de' ? 'Mit neuem Prompt generieren' : language === 'fr' ? 'GÃ©nÃ©rer avec nouveau prompt' : 'Generate with new prompt'}
                            </button>
                          </div>
                        )}

                        {/* Show Prompt - Even for Failed Images */}
                        {imagePrompts[image.pageNumber] && (
                          <details className="bg-gray-50 border border-gray-300 rounded-lg p-3 mb-2">
                            <summary className="cursor-pointer text-sm font-semibold text-gray-700 hover:text-gray-900">
                              {language === 'de' ? 'Verwendeten Prompt anzeigen' : language === 'fr' ? 'Afficher le prompt utilisÃ©' : 'Show Used Prompt'}
                            </summary>
                            <pre className="mt-2 text-xs text-gray-600 whitespace-pre-wrap font-mono bg-white p-3 rounded border border-gray-200 overflow-x-auto">
                              {imagePrompts[image.pageNumber]}
                            </pre>
                          </details>
                        )}

                        {/* Show API Call - Admin only - Even for Failed Images */}
                        {currentUser && currentUser.role === 'admin' && apiCalls[image.pageNumber] && (
                          <details className="bg-blue-50 border border-blue-300 rounded-lg p-3">
                            <summary className="cursor-pointer text-sm font-semibold text-blue-700 hover:text-blue-900">
                              {language === 'de' ? 'API-Aufruf anzeigen' : language === 'fr' ? 'Afficher l\'appel API' : 'Show API Call'}
                            </summary>
                            <div className="mt-2 text-xs text-gray-700">
                              <div className="mb-2">
                                <span className="font-semibold">Endpoint:</span> {apiCalls[image.pageNumber].endpoint || 'N/A'}
                              </div>
                              <div className="mb-2">
                                <span className="font-semibold">Method:</span> {apiCalls[image.pageNumber].method || 'N/A'}
                              </div>
                              <div className="mb-2">
                                <span className="font-semibold">Timestamp:</span> {apiCalls[image.pageNumber].timestamp ? new Date(apiCalls[image.pageNumber].timestamp).toLocaleString() : 'N/A'}
                              </div>
                              <div className="mb-1 font-semibold">Payload:</div>
                              <pre className="text-xs text-gray-600 whitespace-pre-wrap font-mono bg-white p-3 rounded border border-gray-200 overflow-x-auto max-h-96">
                                {JSON.stringify(apiCalls[image.pageNumber].payload || {}, null, 2)}
                              </pre>
                            </div>
                          </details>
                        )}
                      </>
                    )}
                  </div>
                ))}
              </div>
            </div>
          )}

          {/* Final Story: Side-by-Side Pages with Images (MOVED TO END) */}
          {sceneImages.length > 0 && (
            <div className="space-y-8 mt-8">
              <h3 className="text-2xl font-bold text-purple-700 text-center mb-6">
                {language === 'de' ? 'Ihre vollstÃ¤ndige Geschichte' : language === 'fr' ? 'Votre histoire complÃ¨te' : 'Your Complete Story'}
              </h3>

              {storyPages.map((pageText, index) => {
                const pageNumber = index + 1;
                const image = sceneImages.find(img => img.pageNumber === pageNumber);

                return (
                  <div key={pageNumber} className="md:bg-white md:border-2 md:border-purple-300 md:rounded-xl p-4 md:p-6 md:shadow-lg">
                    <h4 className="text-xl font-bold text-purple-700 mb-4 text-center">
                      {language === 'de' ? `Seite ${pageNumber}` : language === 'fr' ? `Page ${pageNumber}` : `Page ${pageNumber}`}
                    </h4>

                    <div className="grid md:grid-cols-2 gap-6">
                      {/* Image on the left */}
                      {image && image.imageData ? (
                        <div className="flex flex-col">
                          <img
                            src={image.imageData}
                            alt={`Scene for page ${pageNumber}`}
                            className="w-full rounded-lg shadow-md object-cover"
                          />
                          {developerMode && (
                            <button
                              onClick={() => downloadImage(image.imageData, pageNumber)}
                              className="mt-3 bg-indigo-500 text-white px-4 py-2 rounded-lg hover:bg-indigo-600 flex items-center justify-center gap-2 text-sm"
                            >
                              <Icon name="download" size={16} /> Download Image
                            </button>
                          )}
                        </div>
                      ) : (
                        <div className="flex items-center justify-center bg-gray-100 rounded-lg p-8">
                          <p className="text-gray-500 text-center">
                            {language === 'de' ? 'Kein Bild fÃ¼r diese Seite' : language === 'fr' ? 'Pas d\'image pour cette page' : 'No image for this page'}
                          </p>
                        </div>
                      )}

                      {/* Text on the right */}
                      <div className="flex items-center">
                        <div className="prose max-w-none">
                          <p className="text-gray-800 leading-relaxed whitespace-pre-wrap font-serif text-lg">
                            {pageText.trim()}
                          </p>
                        </div>
                      </div>
                    </div>
                  </div>
                );
              })}
            </div>
          )}
        </div>
        );
      };

      return (
        <div className="min-h-screen" style={{backgroundColor: '#e0f2fe'}}>
          {/* Authentication Modal */}
          {showAuthModal && (
            <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4">
              <div className="bg-white rounded-xl shadow-2xl max-w-md w-full p-8 animate-fade-in">
                <div className="text-center mb-6">
                  <h2 className="text-3xl font-bold text-purple-700 mb-2">
                    {authMode === 'login' ? t.welcomeBack : t.createAccount}
                  </h2>
                  <p className="text-gray-600">{t.loginRequired}</p>
                </div>

                {authError && (
                  <div className="bg-red-50 border border-red-200 text-red-600 px-4 py-3 rounded-lg mb-4">
                    {authError}
                  </div>
                )}

                <form onSubmit={authMode === 'login' ? handleLogin : handleRegister} className="space-y-4">
                  <div>
                    <label className="block text-sm font-medium text-gray-700 mb-1">{t.email}</label>
                    <input
                      type="email"
                      value={authForm.username}
                      onChange={(e) => setAuthForm({...authForm, username: e.target.value})}
                      className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-purple-500 focus:border-transparent outline-none"
                      placeholder="your@email.com"
                      required
                    />
                  </div>

                  <div>
                    <label className="block text-sm font-medium text-gray-700 mb-1">{t.password}</label>
                    <input
                      type="password"
                      value={authForm.password}
                      onChange={(e) => setAuthForm({...authForm, password: e.target.value})}
                      className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-purple-500 focus:border-transparent outline-none"
                      required
                    />
                  </div>

                  <button
                    type="submit"
                    className="w-full bg-purple-600 text-white py-3 rounded-lg font-semibold hover:bg-purple-700 transition-colors"
                  >
                    {authMode === 'login' ? t.signIn : t.signUp}
                  </button>
                </form>

                <div className="mt-4 text-center">
                  <p className="text-sm text-gray-600">
                    {authMode === 'login' ? t.noAccount : t.haveAccount}
                    {' '}
                    <button
                      onClick={() => {
                        setAuthMode(authMode === 'login' ? 'register' : 'login');
                        setAuthError('');
                      }}
                      className="text-purple-600 font-semibold hover:text-purple-700"
                    >
                      {authMode === 'login' ? t.signUp : t.signIn}
                    </button>
                  </p>
                </div>
              </div>
            </div>
          )}

          {/* Admin Panel Modal */}
          {showAdminPanel && currentUser && currentUser.role === 'admin' && (
            <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4 overflow-y-auto">
              <div className="bg-white rounded-xl shadow-2xl max-w-6xl w-full max-h-[90vh] overflow-y-auto p-8 animate-fade-in">
                <div className="flex justify-between items-center mb-6">
                  <h2 className="text-3xl font-bold text-yellow-700 flex items-center gap-2">
                    <span className="text-4xl">ðŸ‘¥</span>
                    {language === 'de' ? 'Benutzerverwaltung' : language === 'fr' ? 'Gestion des utilisateurs' : 'User Management'}
                  </h2>
                  <button
                    onClick={() => setShowAdminPanel(false)}
                    className="text-gray-500 hover:text-gray-700 text-2xl font-bold"
                  >
                    âœ•
                  </button>
                </div>

                <button
                      onClick={fetchAllUsers}
                      className="mb-4 bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 flex items-center gap-2"
                    >
                      <span>ðŸ”„</span>
                      Refresh Users
                    </button>

                {adminUsers.length === 0 ? (
                  <div className="text-center py-12">
                    <div className="text-gray-300 mb-4 text-6xl">ðŸ‘¥</div>
                    <p className="text-gray-500 text-lg">Click "Refresh Users" to load user list</p>
                  </div>
                ) : (
                  <div className="overflow-x-auto">
                    <table className="w-full border-collapse">
                      <thead>
                        <tr className="bg-gray-100">
                          <th className="px-4 py-3 text-left text-sm font-semibold text-gray-700">Email</th>
                          <th className="px-4 py-3 text-left text-sm font-semibold text-gray-700">Role</th>
                          <th className="px-4 py-3 text-center text-sm font-semibold text-gray-700">Quota</th>
                          <th className="px-4 py-3 text-center text-sm font-semibold text-gray-700">Used</th>
                          <th className="px-4 py-3 text-center text-sm font-semibold text-gray-700">Remaining</th>
                          <th className="px-4 py-3 text-center text-sm font-semibold text-gray-700">Actions</th>
                        </tr>
                      </thead>
                      <tbody>
                        {adminUsers.map(user => {
                          const remaining = user.storyQuota === -1 ? 'âˆž' : Math.max(0, user.storyQuota - user.storiesGenerated);
                          const isLow = user.storyQuota !== -1 && remaining <= 1;
                          const isEmpty = user.storyQuota !== -1 && remaining <= 0;

                          return (
                            <tr key={user.id} className="border-b hover:bg-gray-50">
                              <td className="px-4 py-3 text-sm font-medium text-gray-900">
                                {user.username}
                              </td>
                              <td className="px-4 py-3 text-sm">
                                <span className={`px-2 py-1 rounded text-xs font-semibold ${
                                  user.role === 'admin' ? 'bg-yellow-100 text-yellow-800' : 'bg-gray-100 text-gray-800'
                                }`}>
                                  {user.role} {user.role === 'admin' && 'ðŸ‘‘'}
                                </span>
                              </td>
                              <td className="px-4 py-3 text-sm text-center font-medium">
                                {user.storyQuota === -1 ? 'âˆž' : user.storyQuota}
                              </td>
                              <td className="px-4 py-3 text-sm text-center">{user.storiesGenerated || 0}</td>
                              <td className="px-4 py-3 text-sm text-center">
                                <span className={`px-2 py-1 rounded font-semibold ${
                                  isEmpty ? 'bg-red-100 text-red-800' :
                                  isLow ? 'bg-yellow-100 text-yellow-800' :
                                  'bg-green-100 text-green-800'
                                }`}>
                                  {remaining}
                                </span>
                              </td>
                              <td className="px-4 py-3 text-sm text-center">
                                <div className="flex gap-1 justify-center flex-wrap">
                                  <button
                                    onClick={() => {
                                      if (confirm(`Set ${user.username}'s quota to 0?`)) {
                                        updateUserQuota(user.id, 0);
                                      }
                                    }}
                                    className="bg-red-600 text-white px-2 py-1 rounded text-xs hover:bg-red-700"
                                    title="Set quota to 0"
                                  >
                                    0
                                  </button>
                                  <button
                                    onClick={() => updateUserQuota(user.id, user.storyQuota + 1)}
                                    className="bg-green-600 text-white px-2 py-1 rounded text-xs hover:bg-green-700"
                                    title="Add 1 story"
                                  >
                                    +1
                                  </button>
                                  <button
                                    onClick={() => updateUserQuota(user.id, user.storyQuota + 5)}
                                    className="bg-blue-600 text-white px-2 py-1 rounded text-xs hover:bg-blue-700"
                                    title="Add 5 stories"
                                  >
                                    +5
                                  </button>
                                  <button
                                    onClick={() => updateUserQuota(user.id, user.storyQuota + 10)}
                                    className="bg-purple-600 text-white px-2 py-1 rounded text-xs hover:bg-purple-700"
                                    title="Add 10 stories"
                                  >
                                    +10
                                  </button>
                                  <button
                                    onClick={() => {
                                      if (confirm(`Give ${user.username} unlimited stories?`)) {
                                        updateUserQuota(user.id, -1);
                                      }
                                    }}
                                    className="bg-yellow-600 text-white px-2 py-1 rounded text-xs hover:bg-yellow-700"
                                    title="Unlimited stories"
                                  >
                                    âˆž
                                  </button>
                                </div>
                              </td>
                            </tr>
                          );
                        })}
                      </tbody>
                    </table>
                  </div>
                )}

                {/* Orphaned Data Section */}
                <div className="mt-8 p-6 bg-orange-50 rounded-lg border-2 border-orange-200">
                  <div className="flex justify-between items-center mb-4">
                    <h3 className="text-xl font-bold text-orange-900 flex items-center gap-2">
                      <span>ðŸ—‘ï¸</span>
                      {language === 'de' ? 'Verwaiste Daten' : language === 'fr' ? 'DonnÃ©es orphelines' : 'Orphaned Data'}
                    </h3>
                    <button
                      onClick={checkOrphanedData}
                      disabled={isCheckingOrphaned}
                      className="bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 flex items-center gap-2 disabled:opacity-50"
                    >
                      <span>ðŸ”</span>
                      {isCheckingOrphaned
                        ? (language === 'de' ? 'PrÃ¼fe...' : language === 'fr' ? 'VÃ©rification...' : 'Checking...')
                        : (language === 'de' ? 'PrÃ¼fen' : language === 'fr' ? 'VÃ©rifier' : 'Check')}
                    </button>
                  </div>

                  {orphanedData === null ? (
                    <p className="text-gray-600 text-center py-4">
                      {language === 'de'
                        ? 'Klicken Sie auf "PrÃ¼fen", um nach verwaisten Charakteren und Geschichten zu suchen'
                        : language === 'fr'
                        ? 'Cliquez sur "VÃ©rifier" pour rechercher les personnages et histoires orphelins'
                        : 'Click "Check" to scan for orphaned characters and stories'}
                    </p>
                  ) : (
                    <div>
                      <div className="grid grid-cols-2 gap-4 mb-4">
                        <div className="bg-white p-4 rounded-lg border border-orange-300">
                          <div className="text-3xl font-bold text-orange-600">{orphanedData.characters}</div>
                          <div className="text-sm text-gray-600">
                            {language === 'de' ? 'Verwaiste Charaktere' : language === 'fr' ? 'Personnages orphelins' : 'Orphaned Characters'}
                          </div>
                        </div>
                        <div className="bg-white p-4 rounded-lg border border-orange-300">
                          <div className="text-3xl font-bold text-orange-600">{orphanedData.stories}</div>
                          <div className="text-sm text-gray-600">
                            {language === 'de' ? 'Verwaiste Geschichten' : language === 'fr' ? 'Histoires orphelines' : 'Orphaned Stories'}
                          </div>
                        </div>
                      </div>

                      {(orphanedData.characters > 0 || orphanedData.stories > 0) && (
                        <button
                          onClick={deleteOrphanedData}
                          disabled={isCheckingOrphaned}
                          className="w-full bg-red-600 text-white px-4 py-3 rounded-lg hover:bg-red-700 font-semibold disabled:opacity-50"
                        >
                          {language === 'de'
                            ? 'Alle verwaisten Daten lÃ¶schen'
                            : language === 'fr'
                            ? 'Supprimer toutes les donnÃ©es orphelines'
                            : 'Delete All Orphaned Data'}
                        </button>
                      )}

                      {orphanedData.characters === 0 && orphanedData.stories === 0 && (
                        <div className="text-center text-green-600 font-semibold py-2">
                          âœ… {language === 'de' ? 'Keine verwaisten Daten gefunden!' : language === 'fr' ? 'Aucune donnÃ©e orpheline trouvÃ©e !' : 'No orphaned data found!'}
                        </div>
                      )}
                    </div>
                  )}
                </div>

                <div className="mt-6 p-4 bg-blue-50 rounded-lg border border-blue-200">
                  <h3 className="font-semibold text-blue-900 mb-2">Quick Guide:</h3>
                  <ul className="text-sm text-blue-800 space-y-1">
                    <li>â€¢ Default quota for new users: 2 stories</li>
                    <li>â€¢ Admin accounts have unlimited stories (âˆž)</li>
                    <li>â€¢ Click +1, +5, or +10 to add stories to a user's quota</li>
                    <li>â€¢ Click âˆž to give unlimited access</li>
                  </ul>
                </div>
              </div>
            </div>
          )}

          {/* Products Management Panel Modal */}
          {showProductsPanel && currentUser && currentUser.role === 'admin' && (
            <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4 overflow-y-auto">
              <div className="bg-white rounded-xl shadow-2xl max-w-6xl w-full max-h-[90vh] overflow-y-auto p-8 animate-fade-in">
                <div className="flex justify-between items-center mb-6">
                  <h2 className="text-3xl font-bold text-yellow-700 flex items-center gap-2">
                    <span className="text-4xl">ðŸ“¦</span>
                    {language === 'de' ? 'Produktverwaltung' : language === 'fr' ? 'Gestion des produits' : 'Product Management'}
                  </h2>
                  <button
                    onClick={() => setShowProductsPanel(false)}
                    className="text-gray-500 hover:text-gray-700 text-2xl font-bold"
                  >
                    âœ•
                  </button>
                </div>

                <div className="flex justify-between items-center mb-4 gap-4">
                  <div className="flex gap-2">
                    <button
                      onClick={fetchGelatoProducts}
                      className="bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 flex items-center gap-2"
                    >
                      <span>ðŸ”„</span>
                      Refresh
                    </button>
                    <button
                      onClick={fetchGelatoApiProducts}
                      className="bg-purple-600 text-white px-4 py-2 rounded-lg hover:bg-purple-700 flex items-center gap-2"
                    >
                      <span>ðŸŒ</span>
                      Fetch from Gelato API
                    </button>
                  </div>
                  <button
                    onClick={() => {
                      setShowProductForm(true);
                      setEditingProduct(null);
                      setProductForm({
                        product_uid: '',
                        product_name: '',
                        description: '',
                        size: '',
                        cover_type: '',
                        min_pages: 24,
                        max_pages: 24,
                        available_page_counts: '[24]',
                        is_active: true
                      });
                    }}
                    className="bg-green-600 text-white px-4 py-2 rounded-lg hover:bg-green-700 flex items-center gap-2"
                  >
                    <span>âž•</span>
                    Add Product
                  </button>
                </div>

                {gelatoProducts.length === 0 ? (
                  <div className="text-center py-12 bg-gray-50 rounded-lg">
                    <div className="text-gray-300 mb-4 text-6xl">ðŸ“¦</div>
                    <p className="text-gray-500 text-lg mb-2">No Gelato products configured</p>
                    <p className="text-gray-400 text-sm">Click "Fetch from Gelato API" to import available products</p>
                  </div>
                ) : (
                  <div className="overflow-x-auto">
                    <table className="w-full border-collapse">
                      <thead>
                        <tr className="bg-gray-100">
                          <th className="px-4 py-3 text-left text-sm font-semibold text-gray-700">Status</th>
                          <th className="px-4 py-3 text-left text-sm font-semibold text-gray-700">Product Name</th>
                          <th className="px-4 py-3 text-left text-sm font-semibold text-gray-700">Size</th>
                          <th className="px-4 py-3 text-left text-sm font-semibold text-gray-700">Cover</th>
                          <th className="px-4 py-3 text-center text-sm font-semibold text-gray-700">Pages</th>
                          <th className="px-4 py-3 text-center text-sm font-semibold text-gray-700">Actions</th>
                        </tr>
                      </thead>
                      <tbody>
                        {gelatoProducts.map(product => (
                          <tr key={product.id} className="border-b hover:bg-gray-50">
                            <td className="px-4 py-3 text-sm text-center">
                              <button
                                onClick={() => toggleProductActive(product.id, product.is_active)}
                                className={`px-3 py-1 rounded-full text-xs font-semibold ${
                                  product.is_active
                                    ? 'bg-green-100 text-green-800 hover:bg-green-200'
                                    : 'bg-red-100 text-red-800 hover:bg-red-200'
                                }`}
                              >
                                {product.is_active ? 'âœ“ Active' : 'âœ• Inactive'}
                              </button>
                            </td>
                            <td className="px-4 py-3 text-sm font-medium text-gray-900">
                              {product.product_name}
                              <div className="text-xs text-gray-500 mt-1">{product.description}</div>
                            </td>
                            <td className="px-4 py-3 text-sm">{product.size}</td>
                            <td className="px-4 py-3 text-sm">{product.cover_type}</td>
                            <td className="px-4 py-3 text-sm text-center">
                              {product.min_pages === product.max_pages
                                ? product.min_pages
                                : `${product.min_pages}-${product.max_pages}`}
                            </td>
                            <td className="px-4 py-3 text-sm text-center">
                              <div className="flex gap-2 justify-center">
                                <button
                                  onClick={() => {
                                    setEditingProduct(product);
                                    setProductForm({
                                      product_uid: product.product_uid,
                                      product_name: product.product_name,
                                      description: product.description,
                                      size: product.size,
                                      cover_type: product.cover_type,
                                      min_pages: product.min_pages,
                                      max_pages: product.max_pages,
                                      available_page_counts: product.available_page_counts,
                                      is_active: product.is_active
                                    });
                                    setShowProductForm(true);
                                  }}
                                  className="bg-blue-600 text-white px-3 py-1 rounded hover:bg-blue-700"
                                  title="Edit product"
                                >
                                  âœï¸
                                </button>
                                <button
                                  onClick={() => {
                                    if (confirm(`Delete product "${product.product_name}"?`)) {
                                      deleteGelatoProduct(product.id);
                                    }
                                  }}
                                  className="bg-red-600 text-white px-3 py-1 rounded hover:bg-red-700"
                                  title="Delete product"
                                >
                                  ðŸ—‘ï¸
                                </button>
                              </div>
                            </td>
                          </tr>
                        ))}
                      </tbody>
                    </table>
                  </div>
                )}

                <div className="mt-6 p-4 bg-yellow-50 rounded-lg border border-yellow-200">
                  <h3 className="font-semibold text-yellow-900 mb-2">About Gelato Products:</h3>
                  <ul className="text-sm text-yellow-800 space-y-1">
                    <li>â€¢ Click "Fetch from Gelato API" to import available photobook products</li>
                    <li>â€¢ Active products are available for print ordering</li>
                    <li>â€¢ Page counts must match Gelato's supported values (typically 24, 28, 32, 36, 40)</li>
                    <li>â€¢ Product UIDs come directly from Gelato's catalog</li>
                  </ul>
                </div>
              </div>
            </div>
          )}

          {/* Product Form Modal */}
          {showProductForm && currentUser && currentUser.role === 'admin' && (
            <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4 overflow-y-auto">
              <div className="bg-white rounded-xl shadow-2xl max-w-2xl w-full p-8 animate-fade-in">
                <div className="flex justify-between items-center mb-6">
                  <h2 className="text-2xl font-bold text-yellow-700">
                    {editingProduct ? 'Edit Gelato Product' : 'Add Gelato Product'}
                  </h2>
                  <button
                    onClick={() => {
                      setShowProductForm(false);
                      setEditingProduct(null);
                    }}
                    className="text-gray-500 hover:text-gray-700 text-2xl font-bold"
                  >
                    âœ•
                  </button>
                </div>

                <div className="space-y-4">
                  <div>
                    <label className="block text-sm font-semibold text-gray-700 mb-2">
                      Product UID <span className="text-red-500">*</span>
                    </label>
                    <input
                      type="text"
                      value={productForm.product_uid}
                      onChange={(e) => setProductForm({ ...productForm, product_uid: e.target.value })}
                      placeholder="photobooks-softcover_pf_140x140-mm..."
                      className="w-full px-4 py-2 border-2 border-gray-300 rounded-lg focus:border-yellow-500 focus:outline-none"
                    />
                    <p className="text-xs text-gray-500 mt-1">From Gelato's product catalog API</p>
                  </div>

                  <div>
                    <label className="block text-sm font-semibold text-gray-700 mb-2">
                      Product Name <span className="text-red-500">*</span>
                    </label>
                    <input
                      type="text"
                      value={productForm.product_name}
                      onChange={(e) => setProductForm({ ...productForm, product_name: e.target.value })}
                      placeholder="14x14cm Softcover Photobook - 24 pages"
                      className="w-full px-4 py-2 border-2 border-gray-300 rounded-lg focus:border-yellow-500 focus:outline-none"
                    />
                  </div>

                  <div>
                    <label className="block text-sm font-semibold text-gray-700 mb-2">Description</label>
                    <input
                      type="text"
                      value={productForm.description}
                      onChange={(e) => setProductForm({ ...productForm, description: e.target.value })}
                      placeholder="Square softcover photobook with 24 pages"
                      className="w-full px-4 py-2 border-2 border-gray-300 rounded-lg focus:border-yellow-500 focus:outline-none"
                    />
                  </div>

                  <div className="grid grid-cols-2 gap-4">
                    <div>
                      <label className="block text-sm font-semibold text-gray-700 mb-2">Size</label>
                      <input
                        type="text"
                        value={productForm.size}
                        onChange={(e) => setProductForm({ ...productForm, size: e.target.value })}
                        placeholder="14x14cm"
                        className="w-full px-4 py-2 border-2 border-gray-300 rounded-lg focus:border-yellow-500 focus:outline-none"
                      />
                    </div>
                    <div>
                      <label className="block text-sm font-semibold text-gray-700 mb-2">Cover Type</label>
                      <input
                        type="text"
                        value={productForm.cover_type}
                        onChange={(e) => setProductForm({ ...productForm, cover_type: e.target.value })}
                        placeholder="Softcover"
                        className="w-full px-4 py-2 border-2 border-gray-300 rounded-lg focus:border-yellow-500 focus:outline-none"
                      />
                    </div>
                  </div>

                  <div className="grid grid-cols-2 gap-4">
                    <div>
                      <label className="block text-sm font-semibold text-gray-700 mb-2">
                        Min Pages <span className="text-red-500">*</span>
                      </label>
                      <input
                        type="number"
                        value={productForm.min_pages}
                        onChange={(e) => setProductForm({ ...productForm, min_pages: parseInt(e.target.value) })}
                        min="1"
                        className="w-full px-4 py-2 border-2 border-gray-300 rounded-lg focus:border-yellow-500 focus:outline-none"
                      />
                    </div>
                    <div>
                      <label className="block text-sm font-semibold text-gray-700 mb-2">
                        Max Pages <span className="text-red-500">*</span>
                      </label>
                      <input
                        type="number"
                        value={productForm.max_pages}
                        onChange={(e) => setProductForm({ ...productForm, max_pages: parseInt(e.target.value) })}
                        min="1"
                        className="w-full px-4 py-2 border-2 border-gray-300 rounded-lg focus:border-yellow-500 focus:outline-none"
                      />
                    </div>
                  </div>

                  <div>
                    <label className="block text-sm font-semibold text-gray-700 mb-2">
                      Available Page Counts (JSON Array) <span className="text-red-500">*</span>
                    </label>
                    <input
                      type="text"
                      value={productForm.available_page_counts}
                      onChange={(e) => setProductForm({ ...productForm, available_page_counts: e.target.value })}
                      placeholder="[24,28,32,36,40]"
                      className="w-full px-4 py-2 border-2 border-gray-300 rounded-lg focus:border-yellow-500 focus:outline-none"
                    />
                    <p className="text-xs text-gray-500 mt-1">Format: [24,28,32] - must be valid JSON array</p>
                  </div>

                  <div className="flex items-center gap-2">
                    <input
                      type="checkbox"
                      id="is_active"
                      checked={productForm.is_active}
                      onChange={(e) => setProductForm({ ...productForm, is_active: e.target.checked })}
                      className="w-5 h-5 text-yellow-600"
                    />
                    <label htmlFor="is_active" className="text-sm font-semibold text-gray-700">
                      Active (available for print ordering)
                    </label>
                  </div>

                  <div className="flex gap-3 pt-4">
                    <button
                      onClick={saveGelatoProduct}
                      className="flex-1 bg-yellow-600 text-white px-6 py-3 rounded-lg hover:bg-yellow-700 font-semibold"
                    >
                      {editingProduct ? 'Update Product' : 'Add Product'}
                    </button>
                    <button
                      onClick={() => {
                        setShowProductForm(false);
                        setEditingProduct(null);
                      }}
                      className="px-6 py-3 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 font-semibold"
                    >
                      Cancel
                    </button>
                  </div>
                </div>
              </div>
            </div>
          )}

          {/* Saved Stories Modal */}
          {showSavedStories && (
            <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4 overflow-y-auto">
              <div className="bg-white rounded-xl shadow-2xl max-w-6xl w-full max-h-[90vh] overflow-y-auto p-8 animate-fade-in">
                <div className="flex justify-between items-center mb-6">
                  <h2 className="text-3xl font-bold text-purple-700 flex items-center gap-2">
                    <Icon name="book-open" size={32} />
                    My Saved Stories
                  </h2>
                  <div className="flex items-center gap-2">
                    <button
                      onClick={async () => {
                        console.log('ðŸ”„ Manual refresh of stories...');
                        const stories = await loadStories();
                        console.log('âœ… Refreshed stories:', stories.length);
                        setSavedStories(stories);
                      }}
                      className="text-blue-500 hover:text-blue-700 flex items-center gap-1 px-3 py-1 rounded hover:bg-blue-50"
                      title="Refresh stories"
                    >
                      <Icon name="refresh-cw" size={20} />
                      <span className="text-sm">Refresh</span>
                    </button>
                    <button
                      onClick={() => setShowSavedStories(false)}
                      className="text-gray-500 hover:text-gray-700"
                    >
                      <Icon name="x" size={24} />
                    </button>
                  </div>
                </div>

                {savedStories.length === 0 ? (
                  <div className="text-center py-12">
                    <Icon name="book" size={64} className="mx-auto text-gray-300 mb-4" />
                    <p className="text-gray-500 text-lg">No saved stories yet. Create your first story!</p>
                  </div>
                ) : (
                  <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                    {savedStories.map(story => (
                      <div key={story.id} className="bg-gradient-to-br from-purple-50 to-pink-50 rounded-xl p-6 border-2 border-purple-200 hover:shadow-lg transition-shadow">
                        <div className="flex justify-between items-start mb-4">
                          <h3 className="text-lg font-bold text-purple-700 flex-1">{story.title}</h3>
                          <button
                            onClick={async () => {
                              if (confirm('Delete this story?')) {
                                try {
                                  const response = await fetch(`${API_URL}/api/stories/${story.id}`, {
                                    method: 'DELETE',
                                    headers: { 'Authorization': `Bearer ${authToken}` }
                                  });
                                  if (response.ok) {
                                    const updated = await loadStories();
                                    setSavedStories(updated);
                                  }
                                } catch (err) {
                                  console.error('Error deleting story:', err);
                                }
                              }
                            }}
                            className="text-red-500 hover:text-red-700"
                          >
                            <Icon name="trash-2" size={18} />
                          </button>
                        </div>

                        {/* Thumbnail */}
                        {story.thumbnail && (
                          <div className="mb-4">
                            <img
                              src={story.thumbnail}
                              alt={story.title}
                              className="w-full h-48 object-cover rounded-lg shadow-md"
                            />
                          </div>
                        )}

                        <div className="mb-4">
                          <p className="text-sm text-gray-600 mb-2">
                            <strong>Type:</strong> {story.storyType}
                          </p>
                          <p className="text-sm text-gray-600 mb-2">
                            <strong>Pages:</strong> {story.pages}
                          </p>
                          <p className="text-sm text-gray-600 mb-2">
                            <strong>Characters:</strong> {story.characters?.length || 0}
                          </p>
                          <p className="text-sm text-gray-600">
                            <strong>Created:</strong> {new Date(story.createdAt).toLocaleDateString()}
                          </p>
                        </div>

                        {/* Thumbnail placeholder - removed, now using actual thumbnail above */}

                        <button
                          onClick={async () => {
                            try {
                              console.log(`ðŸ“– Loading full story: ${story.id}`);

                              // Reset progress and show progress modal
                              setLoadingProgress(0);
                              setLoadingBytes(0);
                              setLoadingTotalBytes(0);
                              setShowLoadingProgress(true);

                              // Fetch full story with all images using progress tracking
                              const fullStory = await fetchWithProgress(`${API_URL}/api/stories/${story.id}`, {
                                headers: { 'Authorization': `Bearer ${authToken}` }
                              });

                              console.log(`âœ… Loaded full story with ${fullStory.sceneImages?.length || 0} images`);

                              // Load the full story data
                              setCurrentStoryId(fullStory.id);
                              setStoryType(fullStory.storyType);
                              setArtStyle(fullStory.artStyle);
                              setPages(fullStory.pages);
                              setCharacters(fullStory.characters || []);
                              setStoryOutline(fullStory.outline || '');
                              setGeneratedStory(fullStory.story || '');
                              setSceneDescriptions(fullStory.sceneDescriptions || []);
                              setSceneImages(fullStory.sceneImages || []);
                              setStoryTitle(fullStory.title || '');
                              setCoverImages(fullStory.coverImages || { frontCover: null, page0: null, backCover: null });
                              setStep(5);
                              setShowSavedStories(false);
                              setShowLoadingProgress(false);
                            } catch (err) {
                              console.error('âŒ Error loading story:', err);
                              setShowLoadingProgress(false);
                              alert(`Failed to load story: ${err.message}`);
                            }
                          }}
                          className="w-full bg-purple-600 text-white py-2 rounded-lg hover:bg-purple-700 font-semibold flex items-center justify-center gap-2"
                        >
                          <Icon name="eye" size={18} />
                          View Story
                        </button>
                      </div>
                    ))}
                  </div>
                )}
              </div>
            </div>
          )}

          {/* Shipping Address Modal */}
          {showShippingModal && (
            <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4">
              <div className="bg-white rounded-xl shadow-2xl max-w-2xl w-full p-8 animate-fade-in">
                <div className="flex justify-between items-center mb-6">
                  <h2 className="text-3xl font-bold text-purple-700 flex items-center gap-2">
                    <Icon name="truck" size={32} />
                    {language === 'de' ? 'Lieferadresse' : language === 'fr' ? 'Adresse de livraison' : 'Shipping Address'}
                  </h2>
                  <button
                    onClick={() => setShowShippingModal(false)}
                    className="text-gray-500 hover:text-gray-700"
                  >
                    <Icon name="x" size={24} />
                  </button>
                </div>

                <form onSubmit={(e) => { e.preventDefault(); submitPrintOrder(); }} className="space-y-4">
                  <div className="grid grid-cols-2 gap-4">
                    <div>
                      <label className="block text-sm font-semibold text-gray-700 mb-1">
                        {language === 'de' ? 'Vorname' : language === 'fr' ? 'PrÃ©nom' : 'First Name'}
                      </label>
                      <input
                        type="text"
                        required
                        value={shippingForm.firstName}
                        onChange={(e) => setShippingForm(prev => ({ ...prev, firstName: e.target.value }))}
                        className="w-full px-4 py-2 border-2 border-purple-200 rounded-lg focus:border-purple-500 focus:outline-none"
                      />
                    </div>
                    <div>
                      <label className="block text-sm font-semibold text-gray-700 mb-1">
                        {language === 'de' ? 'Nachname' : language === 'fr' ? 'Nom' : 'Last Name'}
                      </label>
                      <input
                        type="text"
                        required
                        value={shippingForm.lastName}
                        onChange={(e) => setShippingForm(prev => ({ ...prev, lastName: e.target.value }))}
                        className="w-full px-4 py-2 border-2 border-purple-200 rounded-lg focus:border-purple-500 focus:outline-none"
                      />
                    </div>
                  </div>

                  <div>
                    <label className="block text-sm font-semibold text-gray-700 mb-1">
                      {language === 'de' ? 'StraÃŸe und Hausnummer' : language === 'fr' ? 'Adresse' : 'Address Line 1'}
                    </label>
                    <input
                      type="text"
                      required
                      value={shippingForm.addressLine1}
                      onChange={(e) => setShippingForm(prev => ({ ...prev, addressLine1: e.target.value }))}
                      className="w-full px-4 py-2 border-2 border-purple-200 rounded-lg focus:border-purple-500 focus:outline-none"
                    />
                  </div>

                  <div className="grid grid-cols-2 gap-4">
                    <div>
                      <label className="block text-sm font-semibold text-gray-700 mb-1">
                        {language === 'de' ? 'Stadt' : language === 'fr' ? 'Ville' : 'City'}
                      </label>
                      <input
                        type="text"
                        required
                        value={shippingForm.city}
                        onChange={(e) => setShippingForm(prev => ({ ...prev, city: e.target.value }))}
                        className="w-full px-4 py-2 border-2 border-purple-200 rounded-lg focus:border-purple-500 focus:outline-none"
                      />
                    </div>
                    <div>
                      <label className="block text-sm font-semibold text-gray-700 mb-1">
                        {language === 'de' ? 'Postleitzahl' : language === 'fr' ? 'Code postal' : 'Postal Code'}
                      </label>
                      <input
                        type="text"
                        required
                        value={shippingForm.postCode}
                        onChange={(e) => setShippingForm(prev => ({ ...prev, postCode: e.target.value }))}
                        className="w-full px-4 py-2 border-2 border-purple-200 rounded-lg focus:border-purple-500 focus:outline-none"
                      />
                    </div>
                  </div>

                  <div>
                    <label className="block text-sm font-semibold text-gray-700 mb-1">
                      {language === 'de' ? 'Land (2-Buchstaben-Code)' : language === 'fr' ? 'Pays (code Ã  2 lettres)' : 'Country (2-letter code)'}
                    </label>
                    <input
                      type="text"
                      required
                      maxLength="2"
                      value={shippingForm.country}
                      onChange={(e) => setShippingForm(prev => ({ ...prev, country: e.target.value.toUpperCase() }))}
                      placeholder="US, DE, FR, etc."
                      className="w-full px-4 py-2 border-2 border-purple-200 rounded-lg focus:border-purple-500 focus:outline-none uppercase"
                    />
                  </div>

                  <div>
                    <label className="block text-sm font-semibold text-gray-700 mb-1">
                      {language === 'de' ? 'E-Mail' : language === 'fr' ? 'E-mail' : 'Email'}
                    </label>
                    <input
                      type="email"
                      required
                      value={shippingForm.email}
                      onChange={(e) => {
                        setShippingForm(prev => ({ ...prev, email: e.target.value }));
                        setEmailChanged(true);
                      }}
                      className="w-full px-4 py-2 border-2 border-purple-200 rounded-lg focus:border-purple-500 focus:outline-none"
                    />
                    {emailChanged && shippingForm.email !== currentUser?.username && (
                      <p className="text-sm text-orange-600 mt-1">
                        {language === 'de'
                          ? 'Ihre E-Mail-Adresse wird beim Speichern aktualisiert'
                          : language === 'fr'
                          ? 'Votre adresse e-mail sera mise Ã  jour lors de l\'enregistrement'
                          : 'Your email address will be updated when you submit'}
                      </p>
                    )}
                  </div>

                  <div className="flex gap-3 pt-4">
                    <button
                      type="button"
                      onClick={() => setShowShippingModal(false)}
                      className="flex-1 bg-gray-200 text-gray-700 py-3 rounded-lg hover:bg-gray-300 font-semibold"
                    >
                      {language === 'de' ? 'Abbrechen' : language === 'fr' ? 'Annuler' : 'Cancel'}
                    </button>
                    <button
                      type="submit"
                      className="flex-1 bg-purple-600 text-white py-3 rounded-lg hover:bg-purple-700 font-semibold flex items-center justify-center gap-2"
                    >
                      <Icon name="printer" size={20} />
                      {language === 'de' ? 'Druckauftrag erstellen' : language === 'fr' ? 'CrÃ©er la commande' : 'Create Print Order'}
                    </button>
                  </div>
                </form>
              </div>
            </div>
          )}

          {/* Loading Progress Modal */}
          {showLoadingProgress && (
            <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4">
              <div className="bg-white rounded-xl shadow-2xl max-w-md w-full p-8 animate-fade-in">
                <div className="text-center mb-6">
                  <h2 className="text-2xl font-bold text-purple-700 mb-2">Loading Story...</h2>
                  <p className="text-gray-600">
                    {loadingTotalBytes > 0
                      ? `${(loadingBytes / 1024 / 1024).toFixed(2)} MB / ${(loadingTotalBytes / 1024 / 1024).toFixed(2)} MB`
                      : 'Preparing download...'}
                  </p>
                </div>

                {/* Progress Bar */}
                <div className="mb-4">
                  <div className="w-full bg-gray-200 rounded-full h-6 overflow-hidden">
                    <div
                      className="bg-gradient-to-r from-purple-500 to-pink-500 h-full flex items-center justify-center text-white text-sm font-semibold transition-all duration-300"
                      style={{ width: `${loadingProgress}%` }}
                    >
                      {loadingProgress > 0 && `${loadingProgress}%`}
                    </div>
                  </div>
                </div>

                <p className="text-sm text-gray-500 text-center">
                  Please wait while we load your story with all images...
                </p>
              </div>
            </div>
          )}

          {/* Order Success Modal */}
          {showOrderModal && orderData && (
            <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4">
              <div className="bg-white rounded-xl shadow-2xl max-w-2xl w-full p-8 animate-fade-in max-h-[90vh] overflow-y-auto">
                <div className="text-center mb-6">
                  <h2 className="text-3xl font-bold text-purple-700 mb-2">
                    {orderData.isDraft
                      ? (language === 'de' ? 'ðŸ“‹ Vorschau-Bestellung' : language === 'fr' ? 'ðŸ“‹ Commande d\'aperÃ§u' : 'ðŸ“‹ Preview Order')
                      : (language === 'de' ? 'âœ… Bestellung erstellt!' : language === 'fr' ? 'âœ… Commande crÃ©Ã©e!' : 'âœ… Order Created!')
                    }
                  </h2>
                  <p className="text-gray-600">
                    {orderData.isDraft
                      ? (language === 'de' ? 'ENTWURF (wird nicht gedruckt)' : language === 'fr' ? 'BROUILLON (ne sera pas imprimÃ©)' : 'DRAFT (will not be printed)')
                      : (language === 'de' ? 'WIRD GEDRUCKT' : language === 'fr' ? 'EN IMPRESSION' : 'PRINTING')
                    }
                  </p>
                </div>

                <div className="space-y-4 mb-6">
                  {/* Order ID */}
                  <div className="bg-purple-50 border border-purple-200 rounded-lg p-4">
                    <div className="text-sm font-medium text-gray-700 mb-1">
                      {language === 'de' ? 'Bestellnummer' : language === 'fr' ? 'NumÃ©ro de commande' : 'Order ID'}
                    </div>
                    <div className="text-lg font-mono font-bold text-purple-700 select-all">
                      {orderData.orderId}
                    </div>
                  </div>

                  {/* PDF Filename */}
                  <div className="bg-gray-50 border border-gray-200 rounded-lg p-4">
                    <div className="text-sm font-medium text-gray-700 mb-1">PDF</div>
                    <div className="text-gray-900 select-all break-all">{orderData.pdfFilename}</div>
                  </div>

                  {/* Dashboard Link */}
                  <div className="bg-blue-50 border border-blue-200 rounded-lg p-4">
                    <div className="text-sm font-medium text-gray-700 mb-2">
                      {language === 'de' ? 'Gelato Dashboard' : language === 'fr' ? 'Tableau de bord Gelato' : 'Gelato Dashboard'}
                    </div>
                    <a
                      href={orderData.dashboardUrl}
                      target="_blank"
                      rel="noopener noreferrer"
                      className="text-blue-600 hover:text-blue-800 underline break-all select-all"
                    >
                      {orderData.dashboardUrl}
                    </a>
                  </div>

                  {/* Preview URLs (if draft) */}
                  {orderData.isDraft && orderData.previewUrls && orderData.previewUrls.length > 0 && (
                    <div className="bg-green-50 border border-green-200 rounded-lg p-4">
                      <div className="text-sm font-medium text-gray-700 mb-2">
                        {language === 'de' ? 'Vorschau-Links' : language === 'fr' ? 'Liens d\'aperÃ§u' : 'Preview Links'}
                      </div>
                      <div className="space-y-2">
                        {orderData.previewUrls.map((preview, idx) => (
                          <a
                            key={idx}
                            href={preview.url}
                            target="_blank"
                            rel="noopener noreferrer"
                            className="block text-green-600 hover:text-green-800 underline break-all select-all text-sm"
                          >
                            {preview.url}
                          </a>
                        ))}
                      </div>
                    </div>
                  )}

                  {/* Email confirmation (non-draft) */}
                  {!orderData.isDraft && orderData.email && (
                    <div className="bg-yellow-50 border border-yellow-200 rounded-lg p-4">
                      <div className="text-sm text-gray-700">
                        {language === 'de'
                          ? `Sie erhalten eine BestÃ¤tigungs-E-Mail an ${orderData.email}`
                          : language === 'fr'
                          ? `Vous recevrez un e-mail de confirmation Ã  ${orderData.email}`
                          : `You will receive a confirmation email at ${orderData.email}`
                        }
                      </div>
                    </div>
                  )}

                  {/* Draft warning */}
                  {orderData.isDraft && (
                    <div className="bg-orange-50 border border-orange-200 rounded-lg p-4">
                      <div className="text-sm text-orange-700">
                        âš ï¸ {language === 'de'
                          ? 'Um tatsÃ¤chlich zu drucken, Ã¤ndern Sie GELATO_ORDER_TYPE in .env von "draft" auf "order"'
                          : language === 'fr'
                          ? 'Pour imprimer rÃ©ellement, changez GELATO_ORDER_TYPE dans .env de "draft" Ã  "order"'
                          : 'To actually print, change GELATO_ORDER_TYPE in .env from "draft" to "order"'
                        }
                      </div>
                    </div>
                  )}
                </div>

                {/* Action Buttons */}
                <div className="flex gap-4">
                  {/* Admin-only PDF Download Button */}
                  {currentUser && currentUser.role === 'admin' && orderData.pdfUrl && (
                    <a
                      href={orderData.pdfUrl}
                      download={orderData.pdfFilename || 'story.pdf'}
                      className="flex-1 bg-green-600 text-white py-3 rounded-lg hover:bg-green-700 font-semibold flex items-center justify-center gap-2"
                    >
                      <Icon name="download" size={20} />
                      {language === 'de' ? 'PDF herunterladen' : language === 'fr' ? 'TÃ©lÃ©charger PDF' : 'Download PDF'}
                    </a>
                  )}

                  <button
                    onClick={() => setShowOrderModal(false)}
                    className={`${currentUser && currentUser.role === 'admin' ? 'flex-1' : 'w-full'} bg-purple-600 text-white py-3 rounded-lg hover:bg-purple-700 font-semibold`}
                  >
                    {language === 'de' ? 'SchlieÃŸen' : language === 'fr' ? 'Fermer' : 'Close'}
                  </button>
                </div>
              </div>
            </div>
          )}

          {/* Black Navigation Bar - Simplified */}
          <nav className="bg-black text-white px-3 py-2">
            <div className="flex justify-between items-center">
              {/* Left: Title - Always visible */}
              <div className="flex-shrink-0">
                <h1 className="text-sm md:text-base font-bold whitespace-nowrap">âœ¨ {t.title}</h1>
              </div>

              {/* Center: Step Navigation - Always visible */}
              {step > 0 && (
                <div className="flex items-center gap-0.5 md:gap-1 flex-1 justify-center">
                  {[1, 2, 3, 4, 5].map(s => {
                    // Determine if this step is accessible
                    let canAccess = false;
                    if (s === 1) {
                      canAccess = true; // Can always go to step 1
                    } else if (s === 2) {
                      canAccess = storyType !== ''; // Can go to step 2 if story type selected
                    } else if (s === 3) {
                      canAccess = storyType !== '' && characters.length > 0; // Need story type AND characters
                    } else if (s === 4) {
                      canAccess = storyType !== '' && characters.length > 0 && areAllRelationshipsDefined(); // Need all previous data
                    } else if (s === 5) {
                      canAccess = generatedStory !== ''; // Can go to step 5 if story exists
                    }

                    return (
                      <React.Fragment key={s}>
                        <button
                          onClick={() => {
                            if (canAccess) {
                              safeSetStep(s);
                            }
                          }}
                          disabled={!canAccess}
                          className={`w-5 h-5 md:w-6 md:h-6 rounded-full flex items-center justify-center text-[10px] md:text-xs font-bold transition-all ${
                            canAccess
                              ? step === s
                                ? 'bg-purple-600 text-white ring-1 ring-purple-300'
                                : 'bg-purple-500 text-white hover:bg-purple-600 cursor-pointer'
                              : 'bg-gray-600 text-gray-400 cursor-not-allowed'
                          } ${canAccess && step !== s ? 'hover:scale-110' : ''}`}
                        >
                          {s}
                        </button>
                        {s < 5 && <div className={`w-3 md:w-6 h-0.5 ${canAccess ? 'bg-purple-500' : 'bg-gray-600'}`} />}
                      </React.Fragment>
                    );
                  })}
                </div>
              )}

              {/* Quota Display (when no steps) */}
              {step === 0 && isAuthenticated && currentUser && userQuota && !userQuota.unlimited && (
                <div className={`px-3 py-1 rounded text-xs font-semibold ${
                  userQuota.remaining === 0 ? 'bg-red-600 text-white' :
                  userQuota.remaining === 1 ? 'bg-yellow-600 text-white' :
                  'bg-green-600 text-white'
                }`}>
                  {userQuota.remaining} / {userQuota.quota} stories
                </div>
              )}

              {/* Right: Menu Button */}
              <div className="relative">
                <button
                  onClick={() => setShowMenu(!showMenu)}
                  className="bg-gray-800 text-white px-3 py-1.5 rounded text-xs font-semibold hover:bg-gray-700 flex items-center gap-2"
                >
                  <Icon name="menu" size={16} />
                  <span className="hidden md:inline">Menu</span>
                </button>

                {showMenu && (
                  <div className="absolute right-0 mt-2 bg-gray-800 rounded-lg shadow-lg overflow-hidden z-50 min-w-[200px]">
                    {/* User Info Header */}
                    {isAuthenticated && currentUser && (
                      <div className="border-b border-gray-700 px-4 py-3 bg-gray-900">
                        <div className="text-white font-semibold text-sm mb-1">
                          {currentUser.username} {currentUser.role === 'admin' && 'ðŸ‘‘'}
                        </div>
                        {userQuota && !userQuota.unlimited && (
                          <div className={`text-xs px-2 py-1 rounded inline-block ${
                            userQuota.remaining === 0 ? 'bg-red-600 text-white' :
                            userQuota.remaining === 1 ? 'bg-yellow-600 text-white' :
                            'bg-green-600 text-white'
                          }`}>
                            {userQuota.remaining} / {userQuota.quota} {language === 'de' ? 'Geschichten' : language === 'fr' ? 'histoires' : 'stories'}
                          </div>
                        )}
                      </div>
                    )}

                    {/* Language Selection */}
                    <div className="border-b border-gray-700 px-4 py-2">
                      <div className="text-xs text-gray-400 mb-2">
                        {language === 'de' ? 'Sprache' : language === 'fr' ? 'Langue' : 'Language'}
                      </div>
                      <div className="flex gap-2">
                        <button
                          onClick={() => {
                            setLanguage('en');
                            setShowMenu(false);
                          }}
                          className={`flex-1 px-3 py-2 rounded text-xs font-semibold ${language === 'en' ? 'bg-purple-600 text-white' : 'bg-gray-700 text-white hover:bg-gray-600'}`}
                        >
                          EN
                        </button>
                        <button
                          onClick={() => {
                            setLanguage('de');
                            setShowMenu(false);
                          }}
                          className={`flex-1 px-3 py-2 rounded text-xs font-semibold ${language === 'de' ? 'bg-purple-600 text-white' : 'bg-gray-700 text-white hover:bg-gray-600'}`}
                        >
                          DE
                        </button>
                        <button
                          onClick={() => {
                            setLanguage('fr');
                            setShowMenu(false);
                          }}
                          className={`flex-1 px-3 py-2 rounded text-xs font-semibold ${language === 'fr' ? 'bg-purple-600 text-white' : 'bg-gray-700 text-white hover:bg-gray-600'}`}
                        >
                          FR
                        </button>
                      </div>
                    </div>

                    {isAuthenticated && (
                      <>
                        {/* My Stories */}
                        <button
                          onClick={() => {
                            setShowSavedStories(true);
                            setShowMenu(false);
                          }}
                          className="w-full text-left px-4 py-3 hover:bg-gray-700 text-white flex items-center gap-2 border-b border-gray-700"
                        >
                          <Icon name="book-open" size={16} />
                          <span>{language === 'de' ? 'Meine Geschichten' : language === 'fr' ? 'Mes Histoires' : 'My Stories'} ({savedStories.length})</span>
                        </button>

                        {/* Manage Users (Admin only) */}
                        {currentUser && currentUser.role === 'admin' && (
                          <button
                            onClick={() => {
                              setShowAdminPanel(true);
                              setShowMenu(false);
                            }}
                            className="w-full text-left px-4 py-3 hover:bg-gray-700 text-white flex items-center gap-2 border-b border-gray-700"
                          >
                            <Icon name="users" size={16} />
                            <span>{language === 'de' ? 'Benutzer verwalten' : language === 'fr' ? 'GÃ©rer les utilisateurs' : 'Manage Users'}</span>
                          </button>
                        )}

                        {/* Manage Products (Admin only) */}
                        {currentUser && currentUser.role === 'admin' && (
                          <button
                            onClick={() => {
                              setShowProductsPanel(true);
                              setShowMenu(false);
                              fetchGelatoProducts();
                            }}
                            className="w-full text-left px-4 py-3 hover:bg-gray-700 text-white flex items-center gap-2 border-b border-gray-700"
                          >
                            <Icon name="package" size={16} />
                            <span>{language === 'de' ? 'Produkte verwalten' : language === 'fr' ? 'GÃ©rer les produits' : 'Manage Products'}</span>
                          </button>
                        )}

                        {/* Logout */}
                        <button
                          onClick={() => {
                            handleLogout();
                            setShowMenu(false);
                          }}
                          className="w-full text-left px-4 py-3 hover:bg-gray-700 text-white flex items-center gap-2"
                        >
                          <Icon name="log-out" size={16} />
                          <span>{t.logout}</span>
                        </button>
                      </>
                    )}
                  </div>
                )}
              </div>
            </div>
          </nav>

          {showApiKeyPrompt && (
              <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
                <div className="bg-white rounded-xl p-8 max-w-md w-full">
                  <h2 className="text-2xl font-bold text-purple-700 mb-4">{t.apiKeyRequired}</h2>
                  <p className="text-gray-600 mb-4">{t.apiKeyPrompt}</p>
                  <input
                    type="password"
                    value={tempApiKey}
                    onChange={(e) => setTempApiKey(e.target.value)}
                    placeholder={t.apiKeyPlaceholder}
                    className="w-full px-4 py-3 border-2 border-gray-300 rounded-lg mb-4"
                  />
                  <p className="text-xs text-gray-500 mb-4">{t.apiKeyNote}</p>
                  <div className="flex gap-4">
                    <button
                      onClick={() => setShowApiKeyPrompt(false)}
                      className="flex-1 bg-gray-300 text-gray-700 px-6 py-3 rounded-lg hover:bg-gray-400"
                    >
                      {t.cancel}
                    </button>
                    <button
                      onClick={saveApiKeyToStorage}
                      className="flex-1 bg-blue-500 text-white px-6 py-3 rounded-lg hover:bg-blue-600"
                    >
                      {t.saveApiKey}
                    </button>
                  </div>
                </div>
              </div>
            )}

          {step === 0 && renderStep0()}

          {step > 0 && isAuthenticated && (
            <div className="max-w-7xl mx-auto px-2 md:px-8 mt-4 md:mt-8">
              <div className="bg-white md:rounded-2xl md:shadow-xl p-3 md:p-8 mb-4 md:mb-6">
                {step === 1 && renderStep1()}
                {step === 2 && renderStep2()}
                {step === 3 && renderStep3()}
                {step === 4 && renderStep4()}
                {step === 5 && renderStep5()}
              </div>

              {step < 5 && step !== 2 && (
                <div className="flex justify-between">
                <button
                  onClick={() => safeSetStep(Math.max(0, step - 1))}
                  className="bg-white text-purple-600 hover:bg-purple-50 border-2 border-purple-500 px-6 py-3 rounded-lg font-semibold flex items-center gap-2"
                >
                  <Icon name="arrow-left" size={20} /> {t.back}
                </button>

                <button
                  onClick={() => {
                    const nextStep = Math.min(4, step + 1);
                    console.log('ðŸ”µ Next button clicked:', {
                      currentStep: step,
                      nextStep,
                      storyType,
                      isDisabled: (step === 1 && !storyType) || (step === 2 && characters.length === 0) || (step === 3 && !areAllRelationshipsDefined())
                    });
                    safeSetStep(nextStep);
                  }}
                  disabled={
                    (step === 1 && !storyType) ||
                    (step === 2 && characters.length === 0) ||
                    (step === 3 && !areAllRelationshipsDefined())
                  }
                  className={`px-6 py-3 rounded-lg font-semibold flex items-center gap-2 ${
                    (step === 1 && !storyType) ||
                    (step === 2 && characters.length === 0) ||
                    (step === 3 && !areAllRelationshipsDefined())
                      ? 'bg-gray-300 text-gray-500 cursor-not-allowed'
                      : 'bg-blue-500 text-white hover:bg-blue-600'
                  }`}
                >
                  {t.next} <Icon name="arrow-right" size={20} />
                </button>
              </div>
              )}
            </div>
          )}
        </div>
      );
    }

    const root = createRoot(document.getElementById('root'));
    root.render(<StoryCreator />);
  </script>
</body>
</html>